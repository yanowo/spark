// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.6.1
//   protoc               v5.29.3
// source: spark.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import { type CallContext, type CallOptions } from "nice-grpc-common";
import {
  SignatureIntent,
  signatureIntentFromJSON,
  signatureIntentToJSON,
  SigningCommitment,
} from "./common.js";
import { Empty } from "./google/protobuf/empty.js";
import { Timestamp } from "./google/protobuf/timestamp.js";

export const protobufPackage = "spark";

/** Network is the network type of the bitcoin network. */
export enum Network {
  UNSPECIFIED = 0,
  MAINNET = 1,
  REGTEST = 2,
  TESTNET = 3,
  SIGNET = 4,
  UNRECOGNIZED = -1,
}

export function networkFromJSON(object: any): Network {
  switch (object) {
    case 0:
    case "UNSPECIFIED":
      return Network.UNSPECIFIED;
    case 1:
    case "MAINNET":
      return Network.MAINNET;
    case 2:
    case "REGTEST":
      return Network.REGTEST;
    case 3:
    case "TESTNET":
      return Network.TESTNET;
    case 4:
    case "SIGNET":
      return Network.SIGNET;
    case -1:
    case "UNRECOGNIZED":
    default:
      return Network.UNRECOGNIZED;
  }
}

export function networkToJSON(object: Network): string {
  switch (object) {
    case Network.UNSPECIFIED:
      return "UNSPECIFIED";
    case Network.MAINNET:
      return "MAINNET";
    case Network.REGTEST:
      return "REGTEST";
    case Network.TESTNET:
      return "TESTNET";
    case Network.SIGNET:
      return "SIGNET";
    case Network.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export enum TokenTransactionStatus {
  TOKEN_TRANSACTION_STARTED = 0,
  TOKEN_TRANSACTION_SIGNED = 1,
  TOKEN_TRANSACTION_FINALIZED = 2,
  UNRECOGNIZED = -1,
}

export function tokenTransactionStatusFromJSON(
  object: any,
): TokenTransactionStatus {
  switch (object) {
    case 0:
    case "TOKEN_TRANSACTION_STARTED":
      return TokenTransactionStatus.TOKEN_TRANSACTION_STARTED;
    case 1:
    case "TOKEN_TRANSACTION_SIGNED":
      return TokenTransactionStatus.TOKEN_TRANSACTION_SIGNED;
    case 2:
    case "TOKEN_TRANSACTION_FINALIZED":
      return TokenTransactionStatus.TOKEN_TRANSACTION_FINALIZED;
    case -1:
    case "UNRECOGNIZED":
    default:
      return TokenTransactionStatus.UNRECOGNIZED;
  }
}

export function tokenTransactionStatusToJSON(
  object: TokenTransactionStatus,
): string {
  switch (object) {
    case TokenTransactionStatus.TOKEN_TRANSACTION_STARTED:
      return "TOKEN_TRANSACTION_STARTED";
    case TokenTransactionStatus.TOKEN_TRANSACTION_SIGNED:
      return "TOKEN_TRANSACTION_SIGNED";
    case TokenTransactionStatus.TOKEN_TRANSACTION_FINALIZED:
      return "TOKEN_TRANSACTION_FINALIZED";
    case TokenTransactionStatus.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export enum TransferStatus {
  TRANSFER_STATUS_SENDER_INITIATED = 0,
  TRANSFER_STATUS_SENDER_KEY_TWEAK_PENDING = 1,
  TRANSFER_STATUS_SENDER_KEY_TWEAKED = 2,
  TRANSFER_STATUS_RECEIVER_KEY_TWEAKED = 3,
  TRANSFER_STATUSR_RECEIVER_REFUND_SIGNED = 4,
  TRANSFER_STATUS_COMPLETED = 5,
  TRANSFER_STATUS_EXPIRED = 6,
  TRANSFER_STATUS_RETURNED = 7,
  UNRECOGNIZED = -1,
}

export function transferStatusFromJSON(object: any): TransferStatus {
  switch (object) {
    case 0:
    case "TRANSFER_STATUS_SENDER_INITIATED":
      return TransferStatus.TRANSFER_STATUS_SENDER_INITIATED;
    case 1:
    case "TRANSFER_STATUS_SENDER_KEY_TWEAK_PENDING":
      return TransferStatus.TRANSFER_STATUS_SENDER_KEY_TWEAK_PENDING;
    case 2:
    case "TRANSFER_STATUS_SENDER_KEY_TWEAKED":
      return TransferStatus.TRANSFER_STATUS_SENDER_KEY_TWEAKED;
    case 3:
    case "TRANSFER_STATUS_RECEIVER_KEY_TWEAKED":
      return TransferStatus.TRANSFER_STATUS_RECEIVER_KEY_TWEAKED;
    case 4:
    case "TRANSFER_STATUSR_RECEIVER_REFUND_SIGNED":
      return TransferStatus.TRANSFER_STATUSR_RECEIVER_REFUND_SIGNED;
    case 5:
    case "TRANSFER_STATUS_COMPLETED":
      return TransferStatus.TRANSFER_STATUS_COMPLETED;
    case 6:
    case "TRANSFER_STATUS_EXPIRED":
      return TransferStatus.TRANSFER_STATUS_EXPIRED;
    case 7:
    case "TRANSFER_STATUS_RETURNED":
      return TransferStatus.TRANSFER_STATUS_RETURNED;
    case -1:
    case "UNRECOGNIZED":
    default:
      return TransferStatus.UNRECOGNIZED;
  }
}

export function transferStatusToJSON(object: TransferStatus): string {
  switch (object) {
    case TransferStatus.TRANSFER_STATUS_SENDER_INITIATED:
      return "TRANSFER_STATUS_SENDER_INITIATED";
    case TransferStatus.TRANSFER_STATUS_SENDER_KEY_TWEAK_PENDING:
      return "TRANSFER_STATUS_SENDER_KEY_TWEAK_PENDING";
    case TransferStatus.TRANSFER_STATUS_SENDER_KEY_TWEAKED:
      return "TRANSFER_STATUS_SENDER_KEY_TWEAKED";
    case TransferStatus.TRANSFER_STATUS_RECEIVER_KEY_TWEAKED:
      return "TRANSFER_STATUS_RECEIVER_KEY_TWEAKED";
    case TransferStatus.TRANSFER_STATUSR_RECEIVER_REFUND_SIGNED:
      return "TRANSFER_STATUSR_RECEIVER_REFUND_SIGNED";
    case TransferStatus.TRANSFER_STATUS_COMPLETED:
      return "TRANSFER_STATUS_COMPLETED";
    case TransferStatus.TRANSFER_STATUS_EXPIRED:
      return "TRANSFER_STATUS_EXPIRED";
    case TransferStatus.TRANSFER_STATUS_RETURNED:
      return "TRANSFER_STATUS_RETURNED";
    case TransferStatus.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export enum TransferType {
  PREIMAGE_SWAP = 0,
  COOPERATIVE_EXIT = 1,
  TRANSFER = 2,
  SWAP = 30,
  COUNTER_SWAP = 40,
  UNRECOGNIZED = -1,
}

export function transferTypeFromJSON(object: any): TransferType {
  switch (object) {
    case 0:
    case "PREIMAGE_SWAP":
      return TransferType.PREIMAGE_SWAP;
    case 1:
    case "COOPERATIVE_EXIT":
      return TransferType.COOPERATIVE_EXIT;
    case 2:
    case "TRANSFER":
      return TransferType.TRANSFER;
    case 30:
    case "SWAP":
      return TransferType.SWAP;
    case 40:
    case "COUNTER_SWAP":
      return TransferType.COUNTER_SWAP;
    case -1:
    case "UNRECOGNIZED":
    default:
      return TransferType.UNRECOGNIZED;
  }
}

export function transferTypeToJSON(object: TransferType): string {
  switch (object) {
    case TransferType.PREIMAGE_SWAP:
      return "PREIMAGE_SWAP";
    case TransferType.COOPERATIVE_EXIT:
      return "COOPERATIVE_EXIT";
    case TransferType.TRANSFER:
      return "TRANSFER";
    case TransferType.SWAP:
      return "SWAP";
    case TransferType.COUNTER_SWAP:
      return "COUNTER_SWAP";
    case TransferType.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export interface SubscribeToEventsRequest {
  identityPublicKey: Uint8Array;
}

export interface SubscribeToEventsResponse {
  event?:
    | { $case: "transfer"; transfer: TransferEvent }
    | { $case: "deposit"; deposit: DepositEvent }
    | undefined;
}

export interface TransferEvent {
  transfer: Transfer | undefined;
}

export interface DepositEvent {
  deposit: TreeNode | undefined;
}

/**
 * DepositAddressProof is the proof of possession of the deposit address.
 * When a user wants to generate a deposit address, they are sending their public key to the SE,
 * and the SE will respond with an address of user's public key + SE's public key.
 *
 * In the trusty deposit flow, user will need to know that this address is valid, and no single SE
 * can generate this address.
 *
 * The SE will need to sign the address with their identity keys, and have a proof of possession of
 * the signing key piece that the SE holds.
 */
export interface DepositAddressProof {
  /** The signatures of the address by the SE's identity keys. */
  addressSignatures: { [key: string]: Uint8Array };
  /** The proof of possession of the signing key piece by the SE. */
  proofOfPossessionSignature: Uint8Array;
}

export interface DepositAddressProof_AddressSignaturesEntry {
  key: string;
  value: Uint8Array;
}

/**
 * GenerateDepositAddressRequest is the request to generate a deposit address.
 * The user will send their public key to the SE, and the SE will respond with an address of user's
 * public key + SE's public key.
 */
export interface GenerateDepositAddressRequest {
  /** The signing public key of the user. */
  signingPublicKey: Uint8Array;
  /** The identity public key of the user. */
  identityPublicKey: Uint8Array;
  /** The network of the bitcoin network. */
  network: Network;
  /** The UUID to use for the created TreeNode */
  leafId?: string | undefined;
  /** Generate static deposit address */
  isStatic?: boolean | undefined;
}

/** Address is the address of the user's public key + SE's public key. */
export interface Address {
  /** The p2tr address of the user's public key + SE's public key. */
  address: string;
  /** The verifying key of the address, which is user's public key + SE's public key. */
  verifyingKey: Uint8Array;
  /** The proof of possession of the address by the SE. */
  depositAddressProof: DepositAddressProof | undefined;
  /** Is it a static deposit address */
  isStatic: boolean;
}

/** GenerateDepositAddressResponse is the response to the request to generate a deposit address. */
export interface GenerateDepositAddressResponse {
  depositAddress: Address | undefined;
}

/**
 * UTXO represents a utxo on the bitcoin network.
 * The UTXO is used to create a tree on Spark, it can also be an off-chain utxo so that the user
 * can create the tree first and the broadcast the transaction.
 */
export interface UTXO {
  /** The raw transaction of the utxo. */
  rawTx: Uint8Array;
  /** The vout of the raw transaction for the utxo, which will be used to create the tree. */
  vout: number;
  /** The network of the bitcoin network. */
  network: Network;
}

/**
 * NodeOutput represents a node on the tree.
 * This is similar to a UTXO, which is used to create a subtree on Spark. But instead of using
 * a utxo, a existing node on the tree is used as the utxo.
 */
export interface NodeOutput {
  /** The id of the node. */
  nodeId: string;
  /** The vout of the raw transaction for the node, which will be used to create the tree. */
  vout: number;
}

/**
 * SigningJob is the job for signing a transaction.
 * The signing job is used to sign a bitcoin transaction using Spark FROST.
 */
export interface SigningJob {
  /** The signing public key of the user. */
  signingPublicKey: Uint8Array;
  /** The unsigned raw transaction to be signed. */
  rawTx: Uint8Array;
  /** The signing nonce commitment of the user. */
  signingNonceCommitment: SigningCommitment | undefined;
}

/** SigningKeyshare is the keyshare information of the SE keyshare group. */
export interface SigningKeyshare {
  /** The identifiers of the owners of the keyshare. */
  ownerIdentifiers: string[];
  /** The threshold of the keyshare. */
  threshold: number;
}

/**
 * SigningResult is the result of the signing job from the SE keyshare group.
 * It contains all the information for user to sign their part. After user signs, the signature
 * can be aggregated to form the final signature.
 */
export interface SigningResult {
  /** The public keys of the SE keyshare group. */
  publicKeys: { [key: string]: Uint8Array };
  /** The signing nonce commitments of the SE keyshare group. */
  signingNonceCommitments: { [key: string]: SigningCommitment };
  /** The signature shares of the SE keyshare group. */
  signatureShares: { [key: string]: Uint8Array };
  /** The keyshare information of the SE keyshare group. */
  signingKeyshare: SigningKeyshare | undefined;
}

export interface SigningResult_PublicKeysEntry {
  key: string;
  value: Uint8Array;
}

export interface SigningResult_SigningNonceCommitmentsEntry {
  key: string;
  value: SigningCommitment | undefined;
}

export interface SigningResult_SignatureSharesEntry {
  key: string;
  value: Uint8Array;
}

/**
 * NodeSignatureShares is the signature shares for a node on the tree.
 * For each tree node, the verifying key stays the same for both transactions.
 */
export interface NodeSignatureShares {
  /** The id of the node. */
  nodeId: string;
  /** The signing result of the node's transaction. This transaction is to pay to self. */
  nodeTxSigningResult: SigningResult | undefined;
  /** The signing result of the node's refund transaction. This transaction is to pay to the user. */
  refundTxSigningResult: SigningResult | undefined;
  /** The verifying key of the node. */
  verifyingKey: Uint8Array;
}

/**
 * NodeSignatures is the final signatures for a node on the tree.
 * It contains the signature for the node's transaction and refund transaction.
 */
export interface NodeSignatures {
  /** The id of the node. */
  nodeId: string;
  /** The final signature of the node's transaction. This transaction is to pay to self. */
  nodeTxSignature: Uint8Array;
  /** The final signature of the node's refund transaction. This transaction is to pay to the user. */
  refundTxSignature: Uint8Array;
}

/** StartTreeCreationRequest is the request to start the tree creation for a tree root node. */
export interface StartTreeCreationRequest {
  /** The identity public key of the user. */
  identityPublicKey: Uint8Array;
  /** The on-chain utxo to be used to be spent by the root node. */
  onChainUtxo: UTXO | undefined;
  /** The signing job for the root node's transaction. */
  rootTxSigningJob: SigningJob | undefined;
  /** The signing job for the root node's refund transaction. */
  refundTxSigningJob: SigningJob | undefined;
}

/** StartTreeCreationResponse is the response to the request to start the tree creation for a tree root node. */
export interface StartTreeCreationResponse {
  /** The id of the tree. */
  treeId: string;
  /** The signature shares for the root node. */
  rootNodeSignatureShares: NodeSignatureShares | undefined;
}

/** StartDepositTreeCreationRequest is the request to start the tree creation for a tree root node. */
export interface StartDepositTreeCreationRequest {
  /** The identity public key of the user. */
  identityPublicKey: Uint8Array;
  /** The on-chain utxo to be used to be spent by the root node. */
  onChainUtxo: UTXO | undefined;
  /** The signing job for the root node's transaction. */
  rootTxSigningJob: SigningJob | undefined;
  /** The signing job for the root node's refund transaction. */
  refundTxSigningJob: SigningJob | undefined;
}

/** StartDepositTreeCreationResponse is the response to the request to start the tree creation for a tree root node. */
export interface StartDepositTreeCreationResponse {
  /** The id of the tree. */
  treeId: string;
  /** The signature shares for the root node. */
  rootNodeSignatureShares: NodeSignatureShares | undefined;
}

/**
 * This proto is constructed by the wallet to specify leaves it wants to spend as
 * part of the token transaction.
 */
export interface TokenOutputToSpend {
  prevTokenTransactionHash: Uint8Array;
  prevTokenTransactionVout: number;
}

export interface TokenTransferInput {
  outputsToSpend: TokenOutputToSpend[];
}

export interface TokenMintInput {
  issuerPublicKey: Uint8Array;
  /**
   * Issuer provided timestamp of when the transaction was signed/constructed.
   * Helps provide idempotency and ensures that each mint input signature is unique
   * as long as multiple mint signatures are not happening at the same time. Also gives a
   * potentially useful data point for when the issuer authorized from their
   * perspective.  Note that we have no way of proving this is accurate.
   * TODO: Consider whether implementing generic idempotency controls and/or a
   * random nonce would be favorable to populating this field.
   */
  issuerProvidedTimestamp: number;
}

/**
 * This proto is constructed by the wallet to specify outputs it wants to create
 * as part of a token transaction. Output id and revocation public key should remain unfilled
 * so that the SE can fill them as part of the StartTokenTransaction() call.
 */
export interface TokenOutput {
  id?: string | undefined;
  ownerPublicKey: Uint8Array;
  revocationCommitment?: Uint8Array | undefined;
  withdrawBondSats?: number | undefined;
  withdrawRelativeBlockLocktime?: number | undefined;
  tokenPublicKey: Uint8Array;
  /** Decoded uint128 */
  tokenAmount: Uint8Array;
}

/**
 * This proto is constructed by the wallet and is the core transaction data structure.
 * This proto is deterministically hashed to generate the token_transaction_hash that
 * is cooperatively signed by the SO group to confirm a token transaction.
 */
export interface TokenTransaction {
  /**
   * For mint transactions issuer_public_key will be specified without any outputs_to_spend.
   * For transfer transactions the token amount in the input leaves must match the token amount in the output leaves.
   */
  tokenInputs?:
    | { $case: "mintInput"; mintInput: TokenMintInput }
    | {
        $case: "transferInput";
        transferInput: TokenTransferInput;
      }
    | undefined;
  tokenOutputs: TokenOutput[];
  sparkOperatorIdentityPublicKeys: Uint8Array[];
  network: Network;
}

export interface TokenTransactionWithStatus {
  tokenTransaction: TokenTransaction | undefined;
  status: TokenTransactionStatus;
}

export interface TokenTransactionSignatures {
  /**
   * Filled by signing the partial token transaction hash with the owner/issuer private key.
   * For mint transactions this will be one signature for the input issuer_public_key
   * For transfer transactions this will be one for each output for the output owner_public_key
   * This is a Schnorr or ECDSA DER signature which can be between 64 and 73 bytes.
   */
  ownerSignatures: Uint8Array[];
}

export interface StartTokenTransactionRequest {
  identityPublicKey: Uint8Array;
  partialTokenTransaction: TokenTransaction | undefined;
  /** List of ecdsa signatures authorizing movement of tokens from the token input. */
  tokenTransactionSignatures: TokenTransactionSignatures | undefined;
}

export interface StartTokenTransactionResponse {
  /**
   * This is the same token transaction sent by the wallet with output revocation public keys
   * filled. This is the final transaction that is published and gossiped among LRC20 nodes.
   */
  finalTokenTransaction: TokenTransaction | undefined;
  /**
   * Information for fetching and resolving the revocation keyshare on a transfer operation.
   * Contains the threshold of keyshares needed and the SO owners of those keyshares.
   */
  keyshareInfo: SigningKeyshare | undefined;
}

export interface OperatorSpecificTokenTransactionSignablePayload {
  finalTokenTransactionHash: Uint8Array;
  operatorIdentityPublicKey: Uint8Array;
}

/**
 * This message allows the sender of a output being spent to provide final evidence
 * that it owns a output to an SO when requesting signing and release of the  revocation keyshare.
 */
export interface OperatorSpecificOwnerSignature {
  ownerPublicKey: Uint8Array;
  /** This is a Schnorr or ECDSA DER signature which can be between 64 and 73 bytes. */
  ownerSignature: Uint8Array;
  payload: OperatorSpecificTokenTransactionSignablePayload | undefined;
}

export interface SignTokenTransactionRequest {
  finalTokenTransaction: TokenTransaction | undefined;
  operatorSpecificSignatures: OperatorSpecificOwnerSignature[];
  identityPublicKey: Uint8Array;
}

export interface SignTokenTransactionResponse {
  sparkOperatorSignature: Uint8Array;
  tokenTransactionRevocationKeyshares: Uint8Array[];
}

export interface FinalizeTokenTransactionRequest {
  finalTokenTransaction: TokenTransaction | undefined;
  /**
   * List of ordered revocation secrets that map 1:1 with leaves being spent in the
   * token transaction.
   */
  outputToSpendRevocationSecrets: Uint8Array[];
  identityPublicKey: Uint8Array;
}

export interface FreezeTokensPayload {
  ownerPublicKey: Uint8Array;
  tokenPublicKey: Uint8Array;
  issuerProvidedTimestamp: number;
  operatorIdentityPublicKey: Uint8Array;
  /** Set to false when requesting a freeze. */
  shouldUnfreeze: boolean;
}

export interface FreezeTokensRequest {
  freezeTokensPayload: FreezeTokensPayload | undefined;
  /** This is a Schnorr or ECDSA DER signature which can be between 64 and 73 bytes. */
  issuerSignature: Uint8Array;
}

export interface FreezeTokensResponse {
  impactedOutputIds: string[];
  /** Decoded uint128 */
  impactedTokenAmount: Uint8Array;
}

export interface QueryTokenOutputsRequest {
  ownerPublicKeys: Uint8Array[];
  /** Optionally provide token public keys. If not set return leaves for all tokens. */
  tokenPublicKeys: Uint8Array[];
}

/** Request constraints are combined using an AND relation. */
export interface QueryTokenTransactionsRequest {
  /** Returns transactions that have one of these output ids in the input or output. */
  outputIds: string[];
  /** Returns transactions that have this owner public key as the sender or receiver in one or more of the input/output leaves. */
  ownerPublicKeys: Uint8Array[];
  /** Returns transactions that related to this token public key. */
  tokenPublicKeys: Uint8Array[];
  /** Returns transactions that match the provided transaction hashes. */
  tokenTransactionHashes: Uint8Array[];
  limit: number;
  offset: number;
}

export interface QueryTokenTransactionsResponse {
  tokenTransactionsWithStatus: TokenTransactionWithStatus[];
  offset: number;
}

export interface OutputWithPreviousTransactionData {
  output: TokenOutput | undefined;
  previousTransactionHash: Uint8Array;
  previousTransactionVout: number;
}

export interface QueryTokenOutputsResponse {
  outputsWithPreviousTransactionData: OutputWithPreviousTransactionData[];
}

export interface CancelSignedTokenTransactionRequest {
  finalTokenTransaction: TokenTransaction | undefined;
  senderIdentityPublicKey: Uint8Array;
}

/** TreeNode represents a node on the tree. */
export interface TreeNode {
  /** The id of the node. */
  id: string;
  /** The id of the tree for this node . */
  treeId: string;
  /** The value that this node holds. */
  value: number;
  /** The id of the parent node. */
  parentNodeId?: string | undefined;
  /** The transaction of the node, this transaction is to pay to the same address as the node. */
  nodeTx: Uint8Array;
  /** The refund transaction of the node, this transaction is to pay to the user. */
  refundTx: Uint8Array;
  /** This vout is the vout to spend the previous transaction, which is in the parent node. */
  vout: number;
  /** The verifying public key of the node. */
  verifyingPublicKey: Uint8Array;
  /** The identity public key of the owner of the node. */
  ownerIdentityPublicKey: Uint8Array;
  /** The signing keyshare information of the node on the SE side. */
  signingKeyshare: SigningKeyshare | undefined;
  /** The status of the node. */
  status: string;
  /** The network of the node. */
  network: Network;
}

/** FinalizeNodeSignaturesRequest is the request to finalize the signatures for a node. */
export interface FinalizeNodeSignaturesRequest {
  /** The intent of the signature. */
  intent: SignatureIntent;
  /** The signatures for the node. */
  nodeSignatures: NodeSignatures[];
}

/** FinalizeNodeSignaturesResponse is the response to the request to finalize the signatures for a node. */
export interface FinalizeNodeSignaturesResponse {
  /** The nodes that are finalized. */
  nodes: TreeNode[];
}

/**
 * SecretShare is a secret share of a secret, using Feldman VSS.
 * The secret share is in the field of secp256k1 scalar field.
 */
export interface SecretShare {
  /** The secret share. */
  secretShare: Uint8Array;
  /**
   * The proofs for the secret share. They are the compressed public keys in secp256k1 curve.
   * proofs[0] is the public key of the secret, while proofs[1..n] are the public key of the polynomial.
   */
  proofs: Uint8Array[];
}

/**
 * SecretProof is the proof for a secret share using Feldman VSS.
 * The proof is the compressed public keys in secp256k1 curve.
 */
export interface SecretProof {
  /**
   * The proofs for the secret share.
   * proofs[0] is the public key of the secret, while proofs[1..n] are the public key of the polynomial.
   */
  proofs: Uint8Array[];
}

export interface LeafRefundTxSigningJob {
  leafId: string;
  refundTxSigningJob: SigningJob | undefined;
}

export interface UserSignedTxSigningJob {
  leafId: string;
  signingPublicKey: Uint8Array;
  rawTx: Uint8Array;
  signingNonceCommitment: SigningCommitment | undefined;
  userSignature: Uint8Array;
  signingCommitments: SigningCommitments | undefined;
}

export interface LeafRefundTxSigningResult {
  leafId: string;
  refundTxSigningResult: SigningResult | undefined;
  verifyingKey: Uint8Array;
}

export interface StartUserSignedTransferRequest {
  transferId: string;
  ownerIdentityPublicKey: Uint8Array;
  leavesToSend: UserSignedTxSigningJob[];
  receiverIdentityPublicKey: Uint8Array;
  expiryTime: Date | undefined;
}

export interface StartTransferRequest {
  transferId: string;
  ownerIdentityPublicKey: Uint8Array;
  leavesToSend: LeafRefundTxSigningJob[];
  receiverIdentityPublicKey: Uint8Array;
  expiryTime: Date | undefined;
  keyTweakProofs: { [key: string]: SecretProof };
}

export interface StartTransferRequest_KeyTweakProofsEntry {
  key: string;
  value: SecretProof | undefined;
}

export interface StartTransferResponse {
  transfer: Transfer | undefined;
  signingResults: LeafRefundTxSigningResult[];
}

export interface SendLeafKeyTweak {
  leafId: string;
  secretShareTweak: SecretShare | undefined;
  pubkeySharesTweak: { [key: string]: Uint8Array };
  secretCipher: Uint8Array;
  /** Signature over Sha256(leaf_id||transfer_id||secret_cipher) */
  signature: Uint8Array;
  refundSignature: Uint8Array;
}

export interface SendLeafKeyTweak_PubkeySharesTweakEntry {
  key: string;
  value: Uint8Array;
}

export interface FinalizeTransferRequest {
  transferId: string;
  ownerIdentityPublicKey: Uint8Array;
  leavesToSend: SendLeafKeyTweak[];
}

export interface FinalizeTransferResponse {
  transfer: Transfer | undefined;
}

export interface Transfer {
  id: string;
  senderIdentityPublicKey: Uint8Array;
  receiverIdentityPublicKey: Uint8Array;
  status: TransferStatus;
  totalValue: number;
  expiryTime: Date | undefined;
  leaves: TransferLeaf[];
  createdTime: Date | undefined;
  updatedTime: Date | undefined;
  type: TransferType;
}

export interface TransferLeaf {
  leaf: TreeNode | undefined;
  secretCipher: Uint8Array;
  signature: Uint8Array;
  intermediateRefundTx: Uint8Array;
}

export interface TransferFilter {
  participant?:
    | {
        $case: "receiverIdentityPublicKey";
        receiverIdentityPublicKey: Uint8Array;
      }
    | {
        $case: "senderIdentityPublicKey";
        senderIdentityPublicKey: Uint8Array;
      } //
    /** This will include transfers where this public key is the sender or receiver. */
    | {
        $case: "senderOrReceiverIdentityPublicKey";
        senderOrReceiverIdentityPublicKey: Uint8Array;
      }
    | undefined;
  transferIds: string[];
  limit: number;
  offset: number;
  types: TransferType[];
}

export interface QueryTransfersResponse {
  transfers: Transfer[];
  offset: number;
}

export interface ClaimLeafKeyTweak {
  leafId: string;
  secretShareTweak: SecretShare | undefined;
  pubkeySharesTweak: { [key: string]: Uint8Array };
}

export interface ClaimLeafKeyTweak_PubkeySharesTweakEntry {
  key: string;
  value: Uint8Array;
}

export interface ClaimTransferTweakKeysRequest {
  transferId: string;
  ownerIdentityPublicKey: Uint8Array;
  leavesToReceive: ClaimLeafKeyTweak[];
}

export interface ClaimTransferSignRefundsRequest {
  transferId: string;
  ownerIdentityPublicKey: Uint8Array;
  signingJobs: LeafRefundTxSigningJob[];
  keyTweakProofs: { [key: string]: SecretProof };
}

export interface ClaimTransferSignRefundsRequest_KeyTweakProofsEntry {
  key: string;
  value: SecretProof | undefined;
}

export interface ClaimTransferSignRefundsResponse {
  signingResults: LeafRefundTxSigningResult[];
}

export interface AggregateNodesRequest {
  nodeIds: string[];
  signingJob: SigningJob | undefined;
  /** Serves as a temporary identity public key, this should be get from auth process. */
  ownerIdentityPublicKey: Uint8Array;
}

export interface AggregateNodesResponse {
  aggregateSignature: SigningResult | undefined;
  verifyingKey: Uint8Array;
  parentNodeTx: Uint8Array;
  parentNodeVout: number;
}

export interface StorePreimageShareRequest {
  paymentHash: Uint8Array;
  preimageShare: SecretShare | undefined;
  threshold: number;
  invoiceString: string;
  userIdentityPublicKey: Uint8Array;
}

export interface RequestedSigningCommitments {
  signingNonceCommitments: { [key: string]: SigningCommitment };
}

export interface RequestedSigningCommitments_SigningNonceCommitmentsEntry {
  key: string;
  value: SigningCommitment | undefined;
}

export interface GetSigningCommitmentsRequest {
  nodeIds: string[];
}

export interface GetSigningCommitmentsResponse {
  signingCommitments: RequestedSigningCommitments[];
}

export interface SigningCommitments {
  signingCommitments: { [key: string]: SigningCommitment };
}

export interface SigningCommitments_SigningCommitmentsEntry {
  key: string;
  value: SigningCommitment | undefined;
}

export interface UserSignedRefund {
  nodeId: string;
  refundTx: Uint8Array;
  userSignature: Uint8Array;
  signingCommitments: SigningCommitments | undefined;
  userSignatureCommitment: SigningCommitment | undefined;
  network: Network;
}

export interface InvoiceAmountProof {
  bolt11Invoice: string;
}

export interface InvoiceAmount {
  valueSats: number;
  invoiceAmountProof: InvoiceAmountProof | undefined;
}

export interface InitiatePreimageSwapRequest {
  paymentHash: Uint8Array;
  invoiceAmount: InvoiceAmount | undefined;
  reason: InitiatePreimageSwapRequest_Reason;
  transfer: StartUserSignedTransferRequest | undefined;
  receiverIdentityPublicKey: Uint8Array;
  feeSats: number;
}

export enum InitiatePreimageSwapRequest_Reason {
  /** REASON_SEND - The associated lightning service is sending the payment. */
  REASON_SEND = 0,
  /** REASON_RECEIVE - The associated lightning service is receiving the payment. */
  REASON_RECEIVE = 1,
  UNRECOGNIZED = -1,
}

export function initiatePreimageSwapRequest_ReasonFromJSON(
  object: any,
): InitiatePreimageSwapRequest_Reason {
  switch (object) {
    case 0:
    case "REASON_SEND":
      return InitiatePreimageSwapRequest_Reason.REASON_SEND;
    case 1:
    case "REASON_RECEIVE":
      return InitiatePreimageSwapRequest_Reason.REASON_RECEIVE;
    case -1:
    case "UNRECOGNIZED":
    default:
      return InitiatePreimageSwapRequest_Reason.UNRECOGNIZED;
  }
}

export function initiatePreimageSwapRequest_ReasonToJSON(
  object: InitiatePreimageSwapRequest_Reason,
): string {
  switch (object) {
    case InitiatePreimageSwapRequest_Reason.REASON_SEND:
      return "REASON_SEND";
    case InitiatePreimageSwapRequest_Reason.REASON_RECEIVE:
      return "REASON_RECEIVE";
    case InitiatePreimageSwapRequest_Reason.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export interface InitiatePreimageSwapResponse {
  preimage: Uint8Array;
  transfer: Transfer | undefined;
}

export interface OutPoint {
  txid: Uint8Array;
  vout: number;
}

export interface CooperativeExitRequest {
  transfer: StartTransferRequest | undefined;
  exitId: string;
  exitTxid: Uint8Array;
}

export interface CooperativeExitResponse {
  transfer: Transfer | undefined;
  signingResults: LeafRefundTxSigningResult[];
}

export interface CounterLeafSwapRequest {
  transfer: StartTransferRequest | undefined;
  swapId: string;
  adaptorPublicKey: Uint8Array;
}

export interface CounterLeafSwapResponse {
  transfer: Transfer | undefined;
  signingResults: LeafRefundTxSigningResult[];
}

export interface RefreshTimelockRequest {
  leafId: string;
  ownerIdentityPublicKey: Uint8Array;
  signingJobs: SigningJob[];
}

export interface RefreshTimelockSigningResult {
  signingResult: SigningResult | undefined;
  /** Should maybe just be a part of SigningResult? */
  verifyingKey: Uint8Array;
}

export interface RefreshTimelockResponse {
  signingResults: RefreshTimelockSigningResult[];
}

export interface ExtendLeafRequest {
  leafId: string;
  ownerIdentityPublicKey: Uint8Array;
  nodeTxSigningJob: SigningJob | undefined;
  refundTxSigningJob: SigningJob | undefined;
}

export interface ExtendLeafSigningResult {
  signingResult: SigningResult | undefined;
  verifyingKey: Uint8Array;
}

export interface ExtendLeafResponse {
  leafId: string;
  nodeTxSigningResult: ExtendLeafSigningResult | undefined;
  refundTxSigningResult: ExtendLeafSigningResult | undefined;
}

export interface AddressRequestNode {
  userPublicKey: Uint8Array;
  children: AddressRequestNode[];
}

export interface PrepareTreeAddressRequest {
  source?:
    | { $case: "parentNodeOutput"; parentNodeOutput: NodeOutput }
    | { $case: "onChainUtxo"; onChainUtxo: UTXO }
    | undefined;
  /**
   * The tx on this node is to spend the source's utxo.
   * The user's public key should already be registered with the SE for the root node.
   */
  node: AddressRequestNode | undefined;
  userIdentityPublicKey: Uint8Array;
}

export interface AddressNode {
  address: Address | undefined;
  children: AddressNode[];
}

export interface PrepareTreeAddressResponse {
  node: AddressNode | undefined;
}

export interface CreationNode {
  /** This is the tx that spends the parent node's output. */
  nodeTxSigningJob: SigningJob | undefined;
  /** The refund tx can only exist if there's no children. */
  refundTxSigningJob: SigningJob | undefined;
  /** The children will spend the output of the node's tx. Vout is the index of the child. */
  children: CreationNode[];
}

export interface CreateTreeRequest {
  source?:
    | { $case: "parentNodeOutput"; parentNodeOutput: NodeOutput }
    | { $case: "onChainUtxo"; onChainUtxo: UTXO }
    | undefined;
  /** The node should contain the tx that spends the source's utxo. */
  node: CreationNode | undefined;
  /** The owner of the tree. */
  userIdentityPublicKey: Uint8Array;
}

export interface CreationResponseNode {
  nodeId: string;
  nodeTxSigningResult: SigningResult | undefined;
  refundTxSigningResult: SigningResult | undefined;
  children: CreationResponseNode[];
}

export interface CreateTreeResponse {
  node: CreationResponseNode | undefined;
}

export interface SigningOperatorInfo {
  index: number;
  identifier: string;
  publicKey: Uint8Array;
  address: string;
}

export interface GetSigningOperatorListResponse {
  signingOperators: { [key: string]: SigningOperatorInfo };
}

export interface GetSigningOperatorListResponse_SigningOperatorsEntry {
  key: string;
  value: SigningOperatorInfo | undefined;
}

export interface QueryUserSignedRefundsRequest {
  paymentHash: Uint8Array;
  identityPublicKey: Uint8Array;
}

export interface QueryUserSignedRefundsResponse {
  userSignedRefunds: UserSignedRefund[];
}

export interface ProvidePreimageRequest {
  paymentHash: Uint8Array;
  preimage: Uint8Array;
  identityPublicKey: Uint8Array;
}

export interface ProvidePreimageResponse {
  transfer: Transfer | undefined;
}

export interface ReturnLightningPaymentRequest {
  paymentHash: Uint8Array;
  userIdentityPublicKey: Uint8Array;
}

export interface TreeNodeIds {
  nodeIds: string[];
}

export interface QueryNodesRequest {
  source?:
    | { $case: "ownerIdentityPubkey"; ownerIdentityPubkey: Uint8Array }
    | {
        $case: "nodeIds";
        nodeIds: TreeNodeIds;
      }
    | undefined;
  includeParents: boolean;
}

export interface QueryNodesResponse {
  nodes: { [key: string]: TreeNode };
}

export interface QueryNodesResponse_NodesEntry {
  key: string;
  value: TreeNode | undefined;
}

export interface CancelTransferRequest {
  transferId: string;
  senderIdentityPublicKey: Uint8Array;
}

export interface CancelTransferResponse {
  transfer: Transfer | undefined;
}

/**
 * Returns a list of addresses that can be used in express deposit flow.
 * Excludes static deposit addresses.
 */
export interface QueryUnusedDepositAddressesRequest {
  identityPublicKey: Uint8Array;
}

export interface DepositAddressQueryResult {
  depositAddress: string;
  userSigningPublicKey: Uint8Array;
  verifyingPublicKey: Uint8Array;
  leafId?: string | undefined;
}

export interface QueryUnusedDepositAddressesResponse {
  depositAddresses: DepositAddressQueryResult[];
}

export interface QueryBalanceRequest {
  identityPublicKey: Uint8Array;
}

export interface QueryBalanceResponse {
  balance: number;
  nodeBalances: { [key: string]: number };
}

export interface QueryBalanceResponse_NodeBalancesEntry {
  key: string;
  value: number;
}

export interface SparkAddress {
  identityPublicKey: Uint8Array;
}

function createBaseSubscribeToEventsRequest(): SubscribeToEventsRequest {
  return { identityPublicKey: new Uint8Array(0) };
}

export const SubscribeToEventsRequest: MessageFns<SubscribeToEventsRequest> = {
  encode(
    message: SubscribeToEventsRequest,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.identityPublicKey.length !== 0) {
      writer.uint32(82).bytes(message.identityPublicKey);
    }
    return writer;
  },

  decode(
    input: BinaryReader | Uint8Array,
    length?: number,
  ): SubscribeToEventsRequest {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSubscribeToEventsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 10: {
          if (tag !== 82) {
            break;
          }

          message.identityPublicKey = reader.bytes();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SubscribeToEventsRequest {
    return {
      identityPublicKey: isSet(object.identityPublicKey)
        ? bytesFromBase64(object.identityPublicKey)
        : new Uint8Array(0),
    };
  },

  toJSON(message: SubscribeToEventsRequest): unknown {
    const obj: any = {};
    if (message.identityPublicKey.length !== 0) {
      obj.identityPublicKey = base64FromBytes(message.identityPublicKey);
    }
    return obj;
  },

  create(
    base?: DeepPartial<SubscribeToEventsRequest>,
  ): SubscribeToEventsRequest {
    return SubscribeToEventsRequest.fromPartial(base ?? {});
  },
  fromPartial(
    object: DeepPartial<SubscribeToEventsRequest>,
  ): SubscribeToEventsRequest {
    const message = createBaseSubscribeToEventsRequest();
    message.identityPublicKey = object.identityPublicKey ?? new Uint8Array(0);
    return message;
  },
};

function createBaseSubscribeToEventsResponse(): SubscribeToEventsResponse {
  return { event: undefined };
}

export const SubscribeToEventsResponse: MessageFns<SubscribeToEventsResponse> =
  {
    encode(
      message: SubscribeToEventsResponse,
      writer: BinaryWriter = new BinaryWriter(),
    ): BinaryWriter {
      switch (message.event?.$case) {
        case "transfer":
          TransferEvent.encode(
            message.event.transfer,
            writer.uint32(10).fork(),
          ).join();
          break;
        case "deposit":
          DepositEvent.encode(
            message.event.deposit,
            writer.uint32(18).fork(),
          ).join();
          break;
      }
      return writer;
    },

    decode(
      input: BinaryReader | Uint8Array,
      length?: number,
    ): SubscribeToEventsResponse {
      const reader =
        input instanceof BinaryReader ? input : new BinaryReader(input);
      let end = length === undefined ? reader.len : reader.pos + length;
      const message = createBaseSubscribeToEventsResponse();
      while (reader.pos < end) {
        const tag = reader.uint32();
        switch (tag >>> 3) {
          case 1: {
            if (tag !== 10) {
              break;
            }

            message.event = {
              $case: "transfer",
              transfer: TransferEvent.decode(reader, reader.uint32()),
            };
            continue;
          }
          case 2: {
            if (tag !== 18) {
              break;
            }

            message.event = {
              $case: "deposit",
              deposit: DepositEvent.decode(reader, reader.uint32()),
            };
            continue;
          }
        }
        if ((tag & 7) === 4 || tag === 0) {
          break;
        }
        reader.skip(tag & 7);
      }
      return message;
    },

    fromJSON(object: any): SubscribeToEventsResponse {
      return {
        event: isSet(object.transfer)
          ? {
              $case: "transfer",
              transfer: TransferEvent.fromJSON(object.transfer),
            }
          : isSet(object.deposit)
            ? {
                $case: "deposit",
                deposit: DepositEvent.fromJSON(object.deposit),
              }
            : undefined,
      };
    },

    toJSON(message: SubscribeToEventsResponse): unknown {
      const obj: any = {};
      if (message.event?.$case === "transfer") {
        obj.transfer = TransferEvent.toJSON(message.event.transfer);
      } else if (message.event?.$case === "deposit") {
        obj.deposit = DepositEvent.toJSON(message.event.deposit);
      }
      return obj;
    },

    create(
      base?: DeepPartial<SubscribeToEventsResponse>,
    ): SubscribeToEventsResponse {
      return SubscribeToEventsResponse.fromPartial(base ?? {});
    },
    fromPartial(
      object: DeepPartial<SubscribeToEventsResponse>,
    ): SubscribeToEventsResponse {
      const message = createBaseSubscribeToEventsResponse();
      switch (object.event?.$case) {
        case "transfer": {
          if (
            object.event?.transfer !== undefined &&
            object.event?.transfer !== null
          ) {
            message.event = {
              $case: "transfer",
              transfer: TransferEvent.fromPartial(object.event.transfer),
            };
          }
          break;
        }
        case "deposit": {
          if (
            object.event?.deposit !== undefined &&
            object.event?.deposit !== null
          ) {
            message.event = {
              $case: "deposit",
              deposit: DepositEvent.fromPartial(object.event.deposit),
            };
          }
          break;
        }
      }
      return message;
    },
  };

function createBaseTransferEvent(): TransferEvent {
  return { transfer: undefined };
}

export const TransferEvent: MessageFns<TransferEvent> = {
  encode(
    message: TransferEvent,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.transfer !== undefined) {
      Transfer.encode(message.transfer, writer.uint32(82).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TransferEvent {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTransferEvent();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 10: {
          if (tag !== 82) {
            break;
          }

          message.transfer = Transfer.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TransferEvent {
    return {
      transfer: isSet(object.transfer)
        ? Transfer.fromJSON(object.transfer)
        : undefined,
    };
  },

  toJSON(message: TransferEvent): unknown {
    const obj: any = {};
    if (message.transfer !== undefined) {
      obj.transfer = Transfer.toJSON(message.transfer);
    }
    return obj;
  },

  create(base?: DeepPartial<TransferEvent>): TransferEvent {
    return TransferEvent.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<TransferEvent>): TransferEvent {
    const message = createBaseTransferEvent();
    message.transfer =
      object.transfer !== undefined && object.transfer !== null
        ? Transfer.fromPartial(object.transfer)
        : undefined;
    return message;
  },
};

function createBaseDepositEvent(): DepositEvent {
  return { deposit: undefined };
}

export const DepositEvent: MessageFns<DepositEvent> = {
  encode(
    message: DepositEvent,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.deposit !== undefined) {
      TreeNode.encode(message.deposit, writer.uint32(82).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DepositEvent {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDepositEvent();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 10: {
          if (tag !== 82) {
            break;
          }

          message.deposit = TreeNode.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DepositEvent {
    return {
      deposit: isSet(object.deposit)
        ? TreeNode.fromJSON(object.deposit)
        : undefined,
    };
  },

  toJSON(message: DepositEvent): unknown {
    const obj: any = {};
    if (message.deposit !== undefined) {
      obj.deposit = TreeNode.toJSON(message.deposit);
    }
    return obj;
  },

  create(base?: DeepPartial<DepositEvent>): DepositEvent {
    return DepositEvent.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<DepositEvent>): DepositEvent {
    const message = createBaseDepositEvent();
    message.deposit =
      object.deposit !== undefined && object.deposit !== null
        ? TreeNode.fromPartial(object.deposit)
        : undefined;
    return message;
  },
};

function createBaseDepositAddressProof(): DepositAddressProof {
  return {
    addressSignatures: {},
    proofOfPossessionSignature: new Uint8Array(0),
  };
}

export const DepositAddressProof: MessageFns<DepositAddressProof> = {
  encode(
    message: DepositAddressProof,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    Object.entries(message.addressSignatures).forEach(([key, value]) => {
      DepositAddressProof_AddressSignaturesEntry.encode(
        { key: key as any, value },
        writer.uint32(10).fork(),
      ).join();
    });
    if (message.proofOfPossessionSignature.length !== 0) {
      writer.uint32(18).bytes(message.proofOfPossessionSignature);
    }
    return writer;
  },

  decode(
    input: BinaryReader | Uint8Array,
    length?: number,
  ): DepositAddressProof {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDepositAddressProof();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          const entry1 = DepositAddressProof_AddressSignaturesEntry.decode(
            reader,
            reader.uint32(),
          );
          if (entry1.value !== undefined) {
            message.addressSignatures[entry1.key] = entry1.value;
          }
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.proofOfPossessionSignature = reader.bytes();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DepositAddressProof {
    return {
      addressSignatures: isObject(object.addressSignatures)
        ? Object.entries(object.addressSignatures).reduce<{
            [key: string]: Uint8Array;
          }>((acc, [key, value]) => {
            acc[key] = bytesFromBase64(value as string);
            return acc;
          }, {})
        : {},
      proofOfPossessionSignature: isSet(object.proofOfPossessionSignature)
        ? bytesFromBase64(object.proofOfPossessionSignature)
        : new Uint8Array(0),
    };
  },

  toJSON(message: DepositAddressProof): unknown {
    const obj: any = {};
    if (message.addressSignatures) {
      const entries = Object.entries(message.addressSignatures);
      if (entries.length > 0) {
        obj.addressSignatures = {};
        entries.forEach(([k, v]) => {
          obj.addressSignatures[k] = base64FromBytes(v);
        });
      }
    }
    if (message.proofOfPossessionSignature.length !== 0) {
      obj.proofOfPossessionSignature = base64FromBytes(
        message.proofOfPossessionSignature,
      );
    }
    return obj;
  },

  create(base?: DeepPartial<DepositAddressProof>): DepositAddressProof {
    return DepositAddressProof.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<DepositAddressProof>): DepositAddressProof {
    const message = createBaseDepositAddressProof();
    message.addressSignatures = Object.entries(
      object.addressSignatures ?? {},
    ).reduce<{ [key: string]: Uint8Array }>((acc, [key, value]) => {
      if (value !== undefined) {
        acc[key] = value;
      }
      return acc;
    }, {});
    message.proofOfPossessionSignature =
      object.proofOfPossessionSignature ?? new Uint8Array(0);
    return message;
  },
};

function createBaseDepositAddressProof_AddressSignaturesEntry(): DepositAddressProof_AddressSignaturesEntry {
  return { key: "", value: new Uint8Array(0) };
}

export const DepositAddressProof_AddressSignaturesEntry: MessageFns<DepositAddressProof_AddressSignaturesEntry> =
  {
    encode(
      message: DepositAddressProof_AddressSignaturesEntry,
      writer: BinaryWriter = new BinaryWriter(),
    ): BinaryWriter {
      if (message.key !== "") {
        writer.uint32(10).string(message.key);
      }
      if (message.value.length !== 0) {
        writer.uint32(18).bytes(message.value);
      }
      return writer;
    },

    decode(
      input: BinaryReader | Uint8Array,
      length?: number,
    ): DepositAddressProof_AddressSignaturesEntry {
      const reader =
        input instanceof BinaryReader ? input : new BinaryReader(input);
      let end = length === undefined ? reader.len : reader.pos + length;
      const message = createBaseDepositAddressProof_AddressSignaturesEntry();
      while (reader.pos < end) {
        const tag = reader.uint32();
        switch (tag >>> 3) {
          case 1: {
            if (tag !== 10) {
              break;
            }

            message.key = reader.string();
            continue;
          }
          case 2: {
            if (tag !== 18) {
              break;
            }

            message.value = reader.bytes();
            continue;
          }
        }
        if ((tag & 7) === 4 || tag === 0) {
          break;
        }
        reader.skip(tag & 7);
      }
      return message;
    },

    fromJSON(object: any): DepositAddressProof_AddressSignaturesEntry {
      return {
        key: isSet(object.key) ? globalThis.String(object.key) : "",
        value: isSet(object.value)
          ? bytesFromBase64(object.value)
          : new Uint8Array(0),
      };
    },

    toJSON(message: DepositAddressProof_AddressSignaturesEntry): unknown {
      const obj: any = {};
      if (message.key !== "") {
        obj.key = message.key;
      }
      if (message.value.length !== 0) {
        obj.value = base64FromBytes(message.value);
      }
      return obj;
    },

    create(
      base?: DeepPartial<DepositAddressProof_AddressSignaturesEntry>,
    ): DepositAddressProof_AddressSignaturesEntry {
      return DepositAddressProof_AddressSignaturesEntry.fromPartial(base ?? {});
    },
    fromPartial(
      object: DeepPartial<DepositAddressProof_AddressSignaturesEntry>,
    ): DepositAddressProof_AddressSignaturesEntry {
      const message = createBaseDepositAddressProof_AddressSignaturesEntry();
      message.key = object.key ?? "";
      message.value = object.value ?? new Uint8Array(0);
      return message;
    },
  };

function createBaseGenerateDepositAddressRequest(): GenerateDepositAddressRequest {
  return {
    signingPublicKey: new Uint8Array(0),
    identityPublicKey: new Uint8Array(0),
    network: 0,
    leafId: undefined,
    isStatic: undefined,
  };
}

export const GenerateDepositAddressRequest: MessageFns<GenerateDepositAddressRequest> =
  {
    encode(
      message: GenerateDepositAddressRequest,
      writer: BinaryWriter = new BinaryWriter(),
    ): BinaryWriter {
      if (message.signingPublicKey.length !== 0) {
        writer.uint32(10).bytes(message.signingPublicKey);
      }
      if (message.identityPublicKey.length !== 0) {
        writer.uint32(18).bytes(message.identityPublicKey);
      }
      if (message.network !== 0) {
        writer.uint32(24).int32(message.network);
      }
      if (message.leafId !== undefined) {
        writer.uint32(34).string(message.leafId);
      }
      if (message.isStatic !== undefined) {
        writer.uint32(40).bool(message.isStatic);
      }
      return writer;
    },

    decode(
      input: BinaryReader | Uint8Array,
      length?: number,
    ): GenerateDepositAddressRequest {
      const reader =
        input instanceof BinaryReader ? input : new BinaryReader(input);
      let end = length === undefined ? reader.len : reader.pos + length;
      const message = createBaseGenerateDepositAddressRequest();
      while (reader.pos < end) {
        const tag = reader.uint32();
        switch (tag >>> 3) {
          case 1: {
            if (tag !== 10) {
              break;
            }

            message.signingPublicKey = reader.bytes();
            continue;
          }
          case 2: {
            if (tag !== 18) {
              break;
            }

            message.identityPublicKey = reader.bytes();
            continue;
          }
          case 3: {
            if (tag !== 24) {
              break;
            }

            message.network = reader.int32() as any;
            continue;
          }
          case 4: {
            if (tag !== 34) {
              break;
            }

            message.leafId = reader.string();
            continue;
          }
          case 5: {
            if (tag !== 40) {
              break;
            }

            message.isStatic = reader.bool();
            continue;
          }
        }
        if ((tag & 7) === 4 || tag === 0) {
          break;
        }
        reader.skip(tag & 7);
      }
      return message;
    },

    fromJSON(object: any): GenerateDepositAddressRequest {
      return {
        signingPublicKey: isSet(object.signingPublicKey)
          ? bytesFromBase64(object.signingPublicKey)
          : new Uint8Array(0),
        identityPublicKey: isSet(object.identityPublicKey)
          ? bytesFromBase64(object.identityPublicKey)
          : new Uint8Array(0),
        network: isSet(object.network) ? networkFromJSON(object.network) : 0,
        leafId: isSet(object.leafId)
          ? globalThis.String(object.leafId)
          : undefined,
        isStatic: isSet(object.isStatic)
          ? globalThis.Boolean(object.isStatic)
          : undefined,
      };
    },

    toJSON(message: GenerateDepositAddressRequest): unknown {
      const obj: any = {};
      if (message.signingPublicKey.length !== 0) {
        obj.signingPublicKey = base64FromBytes(message.signingPublicKey);
      }
      if (message.identityPublicKey.length !== 0) {
        obj.identityPublicKey = base64FromBytes(message.identityPublicKey);
      }
      if (message.network !== 0) {
        obj.network = networkToJSON(message.network);
      }
      if (message.leafId !== undefined) {
        obj.leafId = message.leafId;
      }
      if (message.isStatic !== undefined) {
        obj.isStatic = message.isStatic;
      }
      return obj;
    },

    create(
      base?: DeepPartial<GenerateDepositAddressRequest>,
    ): GenerateDepositAddressRequest {
      return GenerateDepositAddressRequest.fromPartial(base ?? {});
    },
    fromPartial(
      object: DeepPartial<GenerateDepositAddressRequest>,
    ): GenerateDepositAddressRequest {
      const message = createBaseGenerateDepositAddressRequest();
      message.signingPublicKey = object.signingPublicKey ?? new Uint8Array(0);
      message.identityPublicKey = object.identityPublicKey ?? new Uint8Array(0);
      message.network = object.network ?? 0;
      message.leafId = object.leafId ?? undefined;
      message.isStatic = object.isStatic ?? undefined;
      return message;
    },
  };

function createBaseAddress(): Address {
  return {
    address: "",
    verifyingKey: new Uint8Array(0),
    depositAddressProof: undefined,
    isStatic: false,
  };
}

export const Address: MessageFns<Address> = {
  encode(
    message: Address,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.address !== "") {
      writer.uint32(10).string(message.address);
    }
    if (message.verifyingKey.length !== 0) {
      writer.uint32(18).bytes(message.verifyingKey);
    }
    if (message.depositAddressProof !== undefined) {
      DepositAddressProof.encode(
        message.depositAddressProof,
        writer.uint32(26).fork(),
      ).join();
    }
    if (message.isStatic !== false) {
      writer.uint32(40).bool(message.isStatic);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Address {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAddress();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.address = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.verifyingKey = reader.bytes();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.depositAddressProof = DepositAddressProof.decode(
            reader,
            reader.uint32(),
          );
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.isStatic = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Address {
    return {
      address: isSet(object.address) ? globalThis.String(object.address) : "",
      verifyingKey: isSet(object.verifyingKey)
        ? bytesFromBase64(object.verifyingKey)
        : new Uint8Array(0),
      depositAddressProof: isSet(object.depositAddressProof)
        ? DepositAddressProof.fromJSON(object.depositAddressProof)
        : undefined,
      isStatic: isSet(object.isStatic)
        ? globalThis.Boolean(object.isStatic)
        : false,
    };
  },

  toJSON(message: Address): unknown {
    const obj: any = {};
    if (message.address !== "") {
      obj.address = message.address;
    }
    if (message.verifyingKey.length !== 0) {
      obj.verifyingKey = base64FromBytes(message.verifyingKey);
    }
    if (message.depositAddressProof !== undefined) {
      obj.depositAddressProof = DepositAddressProof.toJSON(
        message.depositAddressProof,
      );
    }
    if (message.isStatic !== false) {
      obj.isStatic = message.isStatic;
    }
    return obj;
  },

  create(base?: DeepPartial<Address>): Address {
    return Address.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Address>): Address {
    const message = createBaseAddress();
    message.address = object.address ?? "";
    message.verifyingKey = object.verifyingKey ?? new Uint8Array(0);
    message.depositAddressProof =
      object.depositAddressProof !== undefined &&
      object.depositAddressProof !== null
        ? DepositAddressProof.fromPartial(object.depositAddressProof)
        : undefined;
    message.isStatic = object.isStatic ?? false;
    return message;
  },
};

function createBaseGenerateDepositAddressResponse(): GenerateDepositAddressResponse {
  return { depositAddress: undefined };
}

export const GenerateDepositAddressResponse: MessageFns<GenerateDepositAddressResponse> =
  {
    encode(
      message: GenerateDepositAddressResponse,
      writer: BinaryWriter = new BinaryWriter(),
    ): BinaryWriter {
      if (message.depositAddress !== undefined) {
        Address.encode(message.depositAddress, writer.uint32(10).fork()).join();
      }
      return writer;
    },

    decode(
      input: BinaryReader | Uint8Array,
      length?: number,
    ): GenerateDepositAddressResponse {
      const reader =
        input instanceof BinaryReader ? input : new BinaryReader(input);
      let end = length === undefined ? reader.len : reader.pos + length;
      const message = createBaseGenerateDepositAddressResponse();
      while (reader.pos < end) {
        const tag = reader.uint32();
        switch (tag >>> 3) {
          case 1: {
            if (tag !== 10) {
              break;
            }

            message.depositAddress = Address.decode(reader, reader.uint32());
            continue;
          }
        }
        if ((tag & 7) === 4 || tag === 0) {
          break;
        }
        reader.skip(tag & 7);
      }
      return message;
    },

    fromJSON(object: any): GenerateDepositAddressResponse {
      return {
        depositAddress: isSet(object.depositAddress)
          ? Address.fromJSON(object.depositAddress)
          : undefined,
      };
    },

    toJSON(message: GenerateDepositAddressResponse): unknown {
      const obj: any = {};
      if (message.depositAddress !== undefined) {
        obj.depositAddress = Address.toJSON(message.depositAddress);
      }
      return obj;
    },

    create(
      base?: DeepPartial<GenerateDepositAddressResponse>,
    ): GenerateDepositAddressResponse {
      return GenerateDepositAddressResponse.fromPartial(base ?? {});
    },
    fromPartial(
      object: DeepPartial<GenerateDepositAddressResponse>,
    ): GenerateDepositAddressResponse {
      const message = createBaseGenerateDepositAddressResponse();
      message.depositAddress =
        object.depositAddress !== undefined && object.depositAddress !== null
          ? Address.fromPartial(object.depositAddress)
          : undefined;
      return message;
    },
  };

function createBaseUTXO(): UTXO {
  return { rawTx: new Uint8Array(0), vout: 0, network: 0 };
}

export const UTXO: MessageFns<UTXO> = {
  encode(
    message: UTXO,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.rawTx.length !== 0) {
      writer.uint32(10).bytes(message.rawTx);
    }
    if (message.vout !== 0) {
      writer.uint32(16).uint32(message.vout);
    }
    if (message.network !== 0) {
      writer.uint32(24).int32(message.network);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UTXO {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUTXO();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.rawTx = reader.bytes();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.vout = reader.uint32();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.network = reader.int32() as any;
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UTXO {
    return {
      rawTx: isSet(object.rawTx)
        ? bytesFromBase64(object.rawTx)
        : new Uint8Array(0),
      vout: isSet(object.vout) ? globalThis.Number(object.vout) : 0,
      network: isSet(object.network) ? networkFromJSON(object.network) : 0,
    };
  },

  toJSON(message: UTXO): unknown {
    const obj: any = {};
    if (message.rawTx.length !== 0) {
      obj.rawTx = base64FromBytes(message.rawTx);
    }
    if (message.vout !== 0) {
      obj.vout = Math.round(message.vout);
    }
    if (message.network !== 0) {
      obj.network = networkToJSON(message.network);
    }
    return obj;
  },

  create(base?: DeepPartial<UTXO>): UTXO {
    return UTXO.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<UTXO>): UTXO {
    const message = createBaseUTXO();
    message.rawTx = object.rawTx ?? new Uint8Array(0);
    message.vout = object.vout ?? 0;
    message.network = object.network ?? 0;
    return message;
  },
};

function createBaseNodeOutput(): NodeOutput {
  return { nodeId: "", vout: 0 };
}

export const NodeOutput: MessageFns<NodeOutput> = {
  encode(
    message: NodeOutput,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.nodeId !== "") {
      writer.uint32(10).string(message.nodeId);
    }
    if (message.vout !== 0) {
      writer.uint32(16).uint32(message.vout);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): NodeOutput {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseNodeOutput();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.nodeId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.vout = reader.uint32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): NodeOutput {
    return {
      nodeId: isSet(object.nodeId) ? globalThis.String(object.nodeId) : "",
      vout: isSet(object.vout) ? globalThis.Number(object.vout) : 0,
    };
  },

  toJSON(message: NodeOutput): unknown {
    const obj: any = {};
    if (message.nodeId !== "") {
      obj.nodeId = message.nodeId;
    }
    if (message.vout !== 0) {
      obj.vout = Math.round(message.vout);
    }
    return obj;
  },

  create(base?: DeepPartial<NodeOutput>): NodeOutput {
    return NodeOutput.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<NodeOutput>): NodeOutput {
    const message = createBaseNodeOutput();
    message.nodeId = object.nodeId ?? "";
    message.vout = object.vout ?? 0;
    return message;
  },
};

function createBaseSigningJob(): SigningJob {
  return {
    signingPublicKey: new Uint8Array(0),
    rawTx: new Uint8Array(0),
    signingNonceCommitment: undefined,
  };
}

export const SigningJob: MessageFns<SigningJob> = {
  encode(
    message: SigningJob,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.signingPublicKey.length !== 0) {
      writer.uint32(10).bytes(message.signingPublicKey);
    }
    if (message.rawTx.length !== 0) {
      writer.uint32(18).bytes(message.rawTx);
    }
    if (message.signingNonceCommitment !== undefined) {
      SigningCommitment.encode(
        message.signingNonceCommitment,
        writer.uint32(26).fork(),
      ).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SigningJob {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSigningJob();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.signingPublicKey = reader.bytes();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.rawTx = reader.bytes();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.signingNonceCommitment = SigningCommitment.decode(
            reader,
            reader.uint32(),
          );
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SigningJob {
    return {
      signingPublicKey: isSet(object.signingPublicKey)
        ? bytesFromBase64(object.signingPublicKey)
        : new Uint8Array(0),
      rawTx: isSet(object.rawTx)
        ? bytesFromBase64(object.rawTx)
        : new Uint8Array(0),
      signingNonceCommitment: isSet(object.signingNonceCommitment)
        ? SigningCommitment.fromJSON(object.signingNonceCommitment)
        : undefined,
    };
  },

  toJSON(message: SigningJob): unknown {
    const obj: any = {};
    if (message.signingPublicKey.length !== 0) {
      obj.signingPublicKey = base64FromBytes(message.signingPublicKey);
    }
    if (message.rawTx.length !== 0) {
      obj.rawTx = base64FromBytes(message.rawTx);
    }
    if (message.signingNonceCommitment !== undefined) {
      obj.signingNonceCommitment = SigningCommitment.toJSON(
        message.signingNonceCommitment,
      );
    }
    return obj;
  },

  create(base?: DeepPartial<SigningJob>): SigningJob {
    return SigningJob.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<SigningJob>): SigningJob {
    const message = createBaseSigningJob();
    message.signingPublicKey = object.signingPublicKey ?? new Uint8Array(0);
    message.rawTx = object.rawTx ?? new Uint8Array(0);
    message.signingNonceCommitment =
      object.signingNonceCommitment !== undefined &&
      object.signingNonceCommitment !== null
        ? SigningCommitment.fromPartial(object.signingNonceCommitment)
        : undefined;
    return message;
  },
};

function createBaseSigningKeyshare(): SigningKeyshare {
  return { ownerIdentifiers: [], threshold: 0 };
}

export const SigningKeyshare: MessageFns<SigningKeyshare> = {
  encode(
    message: SigningKeyshare,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    for (const v of message.ownerIdentifiers) {
      writer.uint32(10).string(v!);
    }
    if (message.threshold !== 0) {
      writer.uint32(16).uint32(message.threshold);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SigningKeyshare {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSigningKeyshare();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.ownerIdentifiers.push(reader.string());
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.threshold = reader.uint32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SigningKeyshare {
    return {
      ownerIdentifiers: globalThis.Array.isArray(object?.ownerIdentifiers)
        ? object.ownerIdentifiers.map((e: any) => globalThis.String(e))
        : [],
      threshold: isSet(object.threshold)
        ? globalThis.Number(object.threshold)
        : 0,
    };
  },

  toJSON(message: SigningKeyshare): unknown {
    const obj: any = {};
    if (message.ownerIdentifiers?.length) {
      obj.ownerIdentifiers = message.ownerIdentifiers;
    }
    if (message.threshold !== 0) {
      obj.threshold = Math.round(message.threshold);
    }
    return obj;
  },

  create(base?: DeepPartial<SigningKeyshare>): SigningKeyshare {
    return SigningKeyshare.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<SigningKeyshare>): SigningKeyshare {
    const message = createBaseSigningKeyshare();
    message.ownerIdentifiers = object.ownerIdentifiers?.map((e) => e) || [];
    message.threshold = object.threshold ?? 0;
    return message;
  },
};

function createBaseSigningResult(): SigningResult {
  return {
    publicKeys: {},
    signingNonceCommitments: {},
    signatureShares: {},
    signingKeyshare: undefined,
  };
}

export const SigningResult: MessageFns<SigningResult> = {
  encode(
    message: SigningResult,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    Object.entries(message.publicKeys).forEach(([key, value]) => {
      SigningResult_PublicKeysEntry.encode(
        { key: key as any, value },
        writer.uint32(10).fork(),
      ).join();
    });
    Object.entries(message.signingNonceCommitments).forEach(([key, value]) => {
      SigningResult_SigningNonceCommitmentsEntry.encode(
        { key: key as any, value },
        writer.uint32(18).fork(),
      ).join();
    });
    Object.entries(message.signatureShares).forEach(([key, value]) => {
      SigningResult_SignatureSharesEntry.encode(
        { key: key as any, value },
        writer.uint32(26).fork(),
      ).join();
    });
    if (message.signingKeyshare !== undefined) {
      SigningKeyshare.encode(
        message.signingKeyshare,
        writer.uint32(34).fork(),
      ).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SigningResult {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSigningResult();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          const entry1 = SigningResult_PublicKeysEntry.decode(
            reader,
            reader.uint32(),
          );
          if (entry1.value !== undefined) {
            message.publicKeys[entry1.key] = entry1.value;
          }
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          const entry2 = SigningResult_SigningNonceCommitmentsEntry.decode(
            reader,
            reader.uint32(),
          );
          if (entry2.value !== undefined) {
            message.signingNonceCommitments[entry2.key] = entry2.value;
          }
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          const entry3 = SigningResult_SignatureSharesEntry.decode(
            reader,
            reader.uint32(),
          );
          if (entry3.value !== undefined) {
            message.signatureShares[entry3.key] = entry3.value;
          }
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.signingKeyshare = SigningKeyshare.decode(
            reader,
            reader.uint32(),
          );
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SigningResult {
    return {
      publicKeys: isObject(object.publicKeys)
        ? Object.entries(object.publicKeys).reduce<{
            [key: string]: Uint8Array;
          }>((acc, [key, value]) => {
            acc[key] = bytesFromBase64(value as string);
            return acc;
          }, {})
        : {},
      signingNonceCommitments: isObject(object.signingNonceCommitments)
        ? Object.entries(object.signingNonceCommitments).reduce<{
            [key: string]: SigningCommitment;
          }>((acc, [key, value]) => {
            acc[key] = SigningCommitment.fromJSON(value);
            return acc;
          }, {})
        : {},
      signatureShares: isObject(object.signatureShares)
        ? Object.entries(object.signatureShares).reduce<{
            [key: string]: Uint8Array;
          }>((acc, [key, value]) => {
            acc[key] = bytesFromBase64(value as string);
            return acc;
          }, {})
        : {},
      signingKeyshare: isSet(object.signingKeyshare)
        ? SigningKeyshare.fromJSON(object.signingKeyshare)
        : undefined,
    };
  },

  toJSON(message: SigningResult): unknown {
    const obj: any = {};
    if (message.publicKeys) {
      const entries = Object.entries(message.publicKeys);
      if (entries.length > 0) {
        obj.publicKeys = {};
        entries.forEach(([k, v]) => {
          obj.publicKeys[k] = base64FromBytes(v);
        });
      }
    }
    if (message.signingNonceCommitments) {
      const entries = Object.entries(message.signingNonceCommitments);
      if (entries.length > 0) {
        obj.signingNonceCommitments = {};
        entries.forEach(([k, v]) => {
          obj.signingNonceCommitments[k] = SigningCommitment.toJSON(v);
        });
      }
    }
    if (message.signatureShares) {
      const entries = Object.entries(message.signatureShares);
      if (entries.length > 0) {
        obj.signatureShares = {};
        entries.forEach(([k, v]) => {
          obj.signatureShares[k] = base64FromBytes(v);
        });
      }
    }
    if (message.signingKeyshare !== undefined) {
      obj.signingKeyshare = SigningKeyshare.toJSON(message.signingKeyshare);
    }
    return obj;
  },

  create(base?: DeepPartial<SigningResult>): SigningResult {
    return SigningResult.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<SigningResult>): SigningResult {
    const message = createBaseSigningResult();
    message.publicKeys = Object.entries(object.publicKeys ?? {}).reduce<{
      [key: string]: Uint8Array;
    }>((acc, [key, value]) => {
      if (value !== undefined) {
        acc[key] = value;
      }
      return acc;
    }, {});
    message.signingNonceCommitments = Object.entries(
      object.signingNonceCommitments ?? {},
    ).reduce<{ [key: string]: SigningCommitment }>((acc, [key, value]) => {
      if (value !== undefined) {
        acc[key] = SigningCommitment.fromPartial(value);
      }
      return acc;
    }, {});
    message.signatureShares = Object.entries(
      object.signatureShares ?? {},
    ).reduce<{ [key: string]: Uint8Array }>((acc, [key, value]) => {
      if (value !== undefined) {
        acc[key] = value;
      }
      return acc;
    }, {});
    message.signingKeyshare =
      object.signingKeyshare !== undefined && object.signingKeyshare !== null
        ? SigningKeyshare.fromPartial(object.signingKeyshare)
        : undefined;
    return message;
  },
};

function createBaseSigningResult_PublicKeysEntry(): SigningResult_PublicKeysEntry {
  return { key: "", value: new Uint8Array(0) };
}

export const SigningResult_PublicKeysEntry: MessageFns<SigningResult_PublicKeysEntry> =
  {
    encode(
      message: SigningResult_PublicKeysEntry,
      writer: BinaryWriter = new BinaryWriter(),
    ): BinaryWriter {
      if (message.key !== "") {
        writer.uint32(10).string(message.key);
      }
      if (message.value.length !== 0) {
        writer.uint32(18).bytes(message.value);
      }
      return writer;
    },

    decode(
      input: BinaryReader | Uint8Array,
      length?: number,
    ): SigningResult_PublicKeysEntry {
      const reader =
        input instanceof BinaryReader ? input : new BinaryReader(input);
      let end = length === undefined ? reader.len : reader.pos + length;
      const message = createBaseSigningResult_PublicKeysEntry();
      while (reader.pos < end) {
        const tag = reader.uint32();
        switch (tag >>> 3) {
          case 1: {
            if (tag !== 10) {
              break;
            }

            message.key = reader.string();
            continue;
          }
          case 2: {
            if (tag !== 18) {
              break;
            }

            message.value = reader.bytes();
            continue;
          }
        }
        if ((tag & 7) === 4 || tag === 0) {
          break;
        }
        reader.skip(tag & 7);
      }
      return message;
    },

    fromJSON(object: any): SigningResult_PublicKeysEntry {
      return {
        key: isSet(object.key) ? globalThis.String(object.key) : "",
        value: isSet(object.value)
          ? bytesFromBase64(object.value)
          : new Uint8Array(0),
      };
    },

    toJSON(message: SigningResult_PublicKeysEntry): unknown {
      const obj: any = {};
      if (message.key !== "") {
        obj.key = message.key;
      }
      if (message.value.length !== 0) {
        obj.value = base64FromBytes(message.value);
      }
      return obj;
    },

    create(
      base?: DeepPartial<SigningResult_PublicKeysEntry>,
    ): SigningResult_PublicKeysEntry {
      return SigningResult_PublicKeysEntry.fromPartial(base ?? {});
    },
    fromPartial(
      object: DeepPartial<SigningResult_PublicKeysEntry>,
    ): SigningResult_PublicKeysEntry {
      const message = createBaseSigningResult_PublicKeysEntry();
      message.key = object.key ?? "";
      message.value = object.value ?? new Uint8Array(0);
      return message;
    },
  };

function createBaseSigningResult_SigningNonceCommitmentsEntry(): SigningResult_SigningNonceCommitmentsEntry {
  return { key: "", value: undefined };
}

export const SigningResult_SigningNonceCommitmentsEntry: MessageFns<SigningResult_SigningNonceCommitmentsEntry> =
  {
    encode(
      message: SigningResult_SigningNonceCommitmentsEntry,
      writer: BinaryWriter = new BinaryWriter(),
    ): BinaryWriter {
      if (message.key !== "") {
        writer.uint32(10).string(message.key);
      }
      if (message.value !== undefined) {
        SigningCommitment.encode(
          message.value,
          writer.uint32(18).fork(),
        ).join();
      }
      return writer;
    },

    decode(
      input: BinaryReader | Uint8Array,
      length?: number,
    ): SigningResult_SigningNonceCommitmentsEntry {
      const reader =
        input instanceof BinaryReader ? input : new BinaryReader(input);
      let end = length === undefined ? reader.len : reader.pos + length;
      const message = createBaseSigningResult_SigningNonceCommitmentsEntry();
      while (reader.pos < end) {
        const tag = reader.uint32();
        switch (tag >>> 3) {
          case 1: {
            if (tag !== 10) {
              break;
            }

            message.key = reader.string();
            continue;
          }
          case 2: {
            if (tag !== 18) {
              break;
            }

            message.value = SigningCommitment.decode(reader, reader.uint32());
            continue;
          }
        }
        if ((tag & 7) === 4 || tag === 0) {
          break;
        }
        reader.skip(tag & 7);
      }
      return message;
    },

    fromJSON(object: any): SigningResult_SigningNonceCommitmentsEntry {
      return {
        key: isSet(object.key) ? globalThis.String(object.key) : "",
        value: isSet(object.value)
          ? SigningCommitment.fromJSON(object.value)
          : undefined,
      };
    },

    toJSON(message: SigningResult_SigningNonceCommitmentsEntry): unknown {
      const obj: any = {};
      if (message.key !== "") {
        obj.key = message.key;
      }
      if (message.value !== undefined) {
        obj.value = SigningCommitment.toJSON(message.value);
      }
      return obj;
    },

    create(
      base?: DeepPartial<SigningResult_SigningNonceCommitmentsEntry>,
    ): SigningResult_SigningNonceCommitmentsEntry {
      return SigningResult_SigningNonceCommitmentsEntry.fromPartial(base ?? {});
    },
    fromPartial(
      object: DeepPartial<SigningResult_SigningNonceCommitmentsEntry>,
    ): SigningResult_SigningNonceCommitmentsEntry {
      const message = createBaseSigningResult_SigningNonceCommitmentsEntry();
      message.key = object.key ?? "";
      message.value =
        object.value !== undefined && object.value !== null
          ? SigningCommitment.fromPartial(object.value)
          : undefined;
      return message;
    },
  };

function createBaseSigningResult_SignatureSharesEntry(): SigningResult_SignatureSharesEntry {
  return { key: "", value: new Uint8Array(0) };
}

export const SigningResult_SignatureSharesEntry: MessageFns<SigningResult_SignatureSharesEntry> =
  {
    encode(
      message: SigningResult_SignatureSharesEntry,
      writer: BinaryWriter = new BinaryWriter(),
    ): BinaryWriter {
      if (message.key !== "") {
        writer.uint32(10).string(message.key);
      }
      if (message.value.length !== 0) {
        writer.uint32(18).bytes(message.value);
      }
      return writer;
    },

    decode(
      input: BinaryReader | Uint8Array,
      length?: number,
    ): SigningResult_SignatureSharesEntry {
      const reader =
        input instanceof BinaryReader ? input : new BinaryReader(input);
      let end = length === undefined ? reader.len : reader.pos + length;
      const message = createBaseSigningResult_SignatureSharesEntry();
      while (reader.pos < end) {
        const tag = reader.uint32();
        switch (tag >>> 3) {
          case 1: {
            if (tag !== 10) {
              break;
            }

            message.key = reader.string();
            continue;
          }
          case 2: {
            if (tag !== 18) {
              break;
            }

            message.value = reader.bytes();
            continue;
          }
        }
        if ((tag & 7) === 4 || tag === 0) {
          break;
        }
        reader.skip(tag & 7);
      }
      return message;
    },

    fromJSON(object: any): SigningResult_SignatureSharesEntry {
      return {
        key: isSet(object.key) ? globalThis.String(object.key) : "",
        value: isSet(object.value)
          ? bytesFromBase64(object.value)
          : new Uint8Array(0),
      };
    },

    toJSON(message: SigningResult_SignatureSharesEntry): unknown {
      const obj: any = {};
      if (message.key !== "") {
        obj.key = message.key;
      }
      if (message.value.length !== 0) {
        obj.value = base64FromBytes(message.value);
      }
      return obj;
    },

    create(
      base?: DeepPartial<SigningResult_SignatureSharesEntry>,
    ): SigningResult_SignatureSharesEntry {
      return SigningResult_SignatureSharesEntry.fromPartial(base ?? {});
    },
    fromPartial(
      object: DeepPartial<SigningResult_SignatureSharesEntry>,
    ): SigningResult_SignatureSharesEntry {
      const message = createBaseSigningResult_SignatureSharesEntry();
      message.key = object.key ?? "";
      message.value = object.value ?? new Uint8Array(0);
      return message;
    },
  };

function createBaseNodeSignatureShares(): NodeSignatureShares {
  return {
    nodeId: "",
    nodeTxSigningResult: undefined,
    refundTxSigningResult: undefined,
    verifyingKey: new Uint8Array(0),
  };
}

export const NodeSignatureShares: MessageFns<NodeSignatureShares> = {
  encode(
    message: NodeSignatureShares,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.nodeId !== "") {
      writer.uint32(10).string(message.nodeId);
    }
    if (message.nodeTxSigningResult !== undefined) {
      SigningResult.encode(
        message.nodeTxSigningResult,
        writer.uint32(18).fork(),
      ).join();
    }
    if (message.refundTxSigningResult !== undefined) {
      SigningResult.encode(
        message.refundTxSigningResult,
        writer.uint32(26).fork(),
      ).join();
    }
    if (message.verifyingKey.length !== 0) {
      writer.uint32(34).bytes(message.verifyingKey);
    }
    return writer;
  },

  decode(
    input: BinaryReader | Uint8Array,
    length?: number,
  ): NodeSignatureShares {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseNodeSignatureShares();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.nodeId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.nodeTxSigningResult = SigningResult.decode(
            reader,
            reader.uint32(),
          );
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.refundTxSigningResult = SigningResult.decode(
            reader,
            reader.uint32(),
          );
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.verifyingKey = reader.bytes();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): NodeSignatureShares {
    return {
      nodeId: isSet(object.nodeId) ? globalThis.String(object.nodeId) : "",
      nodeTxSigningResult: isSet(object.nodeTxSigningResult)
        ? SigningResult.fromJSON(object.nodeTxSigningResult)
        : undefined,
      refundTxSigningResult: isSet(object.refundTxSigningResult)
        ? SigningResult.fromJSON(object.refundTxSigningResult)
        : undefined,
      verifyingKey: isSet(object.verifyingKey)
        ? bytesFromBase64(object.verifyingKey)
        : new Uint8Array(0),
    };
  },

  toJSON(message: NodeSignatureShares): unknown {
    const obj: any = {};
    if (message.nodeId !== "") {
      obj.nodeId = message.nodeId;
    }
    if (message.nodeTxSigningResult !== undefined) {
      obj.nodeTxSigningResult = SigningResult.toJSON(
        message.nodeTxSigningResult,
      );
    }
    if (message.refundTxSigningResult !== undefined) {
      obj.refundTxSigningResult = SigningResult.toJSON(
        message.refundTxSigningResult,
      );
    }
    if (message.verifyingKey.length !== 0) {
      obj.verifyingKey = base64FromBytes(message.verifyingKey);
    }
    return obj;
  },

  create(base?: DeepPartial<NodeSignatureShares>): NodeSignatureShares {
    return NodeSignatureShares.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<NodeSignatureShares>): NodeSignatureShares {
    const message = createBaseNodeSignatureShares();
    message.nodeId = object.nodeId ?? "";
    message.nodeTxSigningResult =
      object.nodeTxSigningResult !== undefined &&
      object.nodeTxSigningResult !== null
        ? SigningResult.fromPartial(object.nodeTxSigningResult)
        : undefined;
    message.refundTxSigningResult =
      object.refundTxSigningResult !== undefined &&
      object.refundTxSigningResult !== null
        ? SigningResult.fromPartial(object.refundTxSigningResult)
        : undefined;
    message.verifyingKey = object.verifyingKey ?? new Uint8Array(0);
    return message;
  },
};

function createBaseNodeSignatures(): NodeSignatures {
  return {
    nodeId: "",
    nodeTxSignature: new Uint8Array(0),
    refundTxSignature: new Uint8Array(0),
  };
}

export const NodeSignatures: MessageFns<NodeSignatures> = {
  encode(
    message: NodeSignatures,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.nodeId !== "") {
      writer.uint32(10).string(message.nodeId);
    }
    if (message.nodeTxSignature.length !== 0) {
      writer.uint32(18).bytes(message.nodeTxSignature);
    }
    if (message.refundTxSignature.length !== 0) {
      writer.uint32(26).bytes(message.refundTxSignature);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): NodeSignatures {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseNodeSignatures();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.nodeId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.nodeTxSignature = reader.bytes();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.refundTxSignature = reader.bytes();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): NodeSignatures {
    return {
      nodeId: isSet(object.nodeId) ? globalThis.String(object.nodeId) : "",
      nodeTxSignature: isSet(object.nodeTxSignature)
        ? bytesFromBase64(object.nodeTxSignature)
        : new Uint8Array(0),
      refundTxSignature: isSet(object.refundTxSignature)
        ? bytesFromBase64(object.refundTxSignature)
        : new Uint8Array(0),
    };
  },

  toJSON(message: NodeSignatures): unknown {
    const obj: any = {};
    if (message.nodeId !== "") {
      obj.nodeId = message.nodeId;
    }
    if (message.nodeTxSignature.length !== 0) {
      obj.nodeTxSignature = base64FromBytes(message.nodeTxSignature);
    }
    if (message.refundTxSignature.length !== 0) {
      obj.refundTxSignature = base64FromBytes(message.refundTxSignature);
    }
    return obj;
  },

  create(base?: DeepPartial<NodeSignatures>): NodeSignatures {
    return NodeSignatures.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<NodeSignatures>): NodeSignatures {
    const message = createBaseNodeSignatures();
    message.nodeId = object.nodeId ?? "";
    message.nodeTxSignature = object.nodeTxSignature ?? new Uint8Array(0);
    message.refundTxSignature = object.refundTxSignature ?? new Uint8Array(0);
    return message;
  },
};

function createBaseStartTreeCreationRequest(): StartTreeCreationRequest {
  return {
    identityPublicKey: new Uint8Array(0),
    onChainUtxo: undefined,
    rootTxSigningJob: undefined,
    refundTxSigningJob: undefined,
  };
}

export const StartTreeCreationRequest: MessageFns<StartTreeCreationRequest> = {
  encode(
    message: StartTreeCreationRequest,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.identityPublicKey.length !== 0) {
      writer.uint32(10).bytes(message.identityPublicKey);
    }
    if (message.onChainUtxo !== undefined) {
      UTXO.encode(message.onChainUtxo, writer.uint32(18).fork()).join();
    }
    if (message.rootTxSigningJob !== undefined) {
      SigningJob.encode(
        message.rootTxSigningJob,
        writer.uint32(26).fork(),
      ).join();
    }
    if (message.refundTxSigningJob !== undefined) {
      SigningJob.encode(
        message.refundTxSigningJob,
        writer.uint32(34).fork(),
      ).join();
    }
    return writer;
  },

  decode(
    input: BinaryReader | Uint8Array,
    length?: number,
  ): StartTreeCreationRequest {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseStartTreeCreationRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.identityPublicKey = reader.bytes();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.onChainUtxo = UTXO.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.rootTxSigningJob = SigningJob.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.refundTxSigningJob = SigningJob.decode(
            reader,
            reader.uint32(),
          );
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): StartTreeCreationRequest {
    return {
      identityPublicKey: isSet(object.identityPublicKey)
        ? bytesFromBase64(object.identityPublicKey)
        : new Uint8Array(0),
      onChainUtxo: isSet(object.onChainUtxo)
        ? UTXO.fromJSON(object.onChainUtxo)
        : undefined,
      rootTxSigningJob: isSet(object.rootTxSigningJob)
        ? SigningJob.fromJSON(object.rootTxSigningJob)
        : undefined,
      refundTxSigningJob: isSet(object.refundTxSigningJob)
        ? SigningJob.fromJSON(object.refundTxSigningJob)
        : undefined,
    };
  },

  toJSON(message: StartTreeCreationRequest): unknown {
    const obj: any = {};
    if (message.identityPublicKey.length !== 0) {
      obj.identityPublicKey = base64FromBytes(message.identityPublicKey);
    }
    if (message.onChainUtxo !== undefined) {
      obj.onChainUtxo = UTXO.toJSON(message.onChainUtxo);
    }
    if (message.rootTxSigningJob !== undefined) {
      obj.rootTxSigningJob = SigningJob.toJSON(message.rootTxSigningJob);
    }
    if (message.refundTxSigningJob !== undefined) {
      obj.refundTxSigningJob = SigningJob.toJSON(message.refundTxSigningJob);
    }
    return obj;
  },

  create(
    base?: DeepPartial<StartTreeCreationRequest>,
  ): StartTreeCreationRequest {
    return StartTreeCreationRequest.fromPartial(base ?? {});
  },
  fromPartial(
    object: DeepPartial<StartTreeCreationRequest>,
  ): StartTreeCreationRequest {
    const message = createBaseStartTreeCreationRequest();
    message.identityPublicKey = object.identityPublicKey ?? new Uint8Array(0);
    message.onChainUtxo =
      object.onChainUtxo !== undefined && object.onChainUtxo !== null
        ? UTXO.fromPartial(object.onChainUtxo)
        : undefined;
    message.rootTxSigningJob =
      object.rootTxSigningJob !== undefined && object.rootTxSigningJob !== null
        ? SigningJob.fromPartial(object.rootTxSigningJob)
        : undefined;
    message.refundTxSigningJob =
      object.refundTxSigningJob !== undefined &&
      object.refundTxSigningJob !== null
        ? SigningJob.fromPartial(object.refundTxSigningJob)
        : undefined;
    return message;
  },
};

function createBaseStartTreeCreationResponse(): StartTreeCreationResponse {
  return { treeId: "", rootNodeSignatureShares: undefined };
}

export const StartTreeCreationResponse: MessageFns<StartTreeCreationResponse> =
  {
    encode(
      message: StartTreeCreationResponse,
      writer: BinaryWriter = new BinaryWriter(),
    ): BinaryWriter {
      if (message.treeId !== "") {
        writer.uint32(10).string(message.treeId);
      }
      if (message.rootNodeSignatureShares !== undefined) {
        NodeSignatureShares.encode(
          message.rootNodeSignatureShares,
          writer.uint32(18).fork(),
        ).join();
      }
      return writer;
    },

    decode(
      input: BinaryReader | Uint8Array,
      length?: number,
    ): StartTreeCreationResponse {
      const reader =
        input instanceof BinaryReader ? input : new BinaryReader(input);
      let end = length === undefined ? reader.len : reader.pos + length;
      const message = createBaseStartTreeCreationResponse();
      while (reader.pos < end) {
        const tag = reader.uint32();
        switch (tag >>> 3) {
          case 1: {
            if (tag !== 10) {
              break;
            }

            message.treeId = reader.string();
            continue;
          }
          case 2: {
            if (tag !== 18) {
              break;
            }

            message.rootNodeSignatureShares = NodeSignatureShares.decode(
              reader,
              reader.uint32(),
            );
            continue;
          }
        }
        if ((tag & 7) === 4 || tag === 0) {
          break;
        }
        reader.skip(tag & 7);
      }
      return message;
    },

    fromJSON(object: any): StartTreeCreationResponse {
      return {
        treeId: isSet(object.treeId) ? globalThis.String(object.treeId) : "",
        rootNodeSignatureShares: isSet(object.rootNodeSignatureShares)
          ? NodeSignatureShares.fromJSON(object.rootNodeSignatureShares)
          : undefined,
      };
    },

    toJSON(message: StartTreeCreationResponse): unknown {
      const obj: any = {};
      if (message.treeId !== "") {
        obj.treeId = message.treeId;
      }
      if (message.rootNodeSignatureShares !== undefined) {
        obj.rootNodeSignatureShares = NodeSignatureShares.toJSON(
          message.rootNodeSignatureShares,
        );
      }
      return obj;
    },

    create(
      base?: DeepPartial<StartTreeCreationResponse>,
    ): StartTreeCreationResponse {
      return StartTreeCreationResponse.fromPartial(base ?? {});
    },
    fromPartial(
      object: DeepPartial<StartTreeCreationResponse>,
    ): StartTreeCreationResponse {
      const message = createBaseStartTreeCreationResponse();
      message.treeId = object.treeId ?? "";
      message.rootNodeSignatureShares =
        object.rootNodeSignatureShares !== undefined &&
        object.rootNodeSignatureShares !== null
          ? NodeSignatureShares.fromPartial(object.rootNodeSignatureShares)
          : undefined;
      return message;
    },
  };

function createBaseStartDepositTreeCreationRequest(): StartDepositTreeCreationRequest {
  return {
    identityPublicKey: new Uint8Array(0),
    onChainUtxo: undefined,
    rootTxSigningJob: undefined,
    refundTxSigningJob: undefined,
  };
}

export const StartDepositTreeCreationRequest: MessageFns<StartDepositTreeCreationRequest> =
  {
    encode(
      message: StartDepositTreeCreationRequest,
      writer: BinaryWriter = new BinaryWriter(),
    ): BinaryWriter {
      if (message.identityPublicKey.length !== 0) {
        writer.uint32(10).bytes(message.identityPublicKey);
      }
      if (message.onChainUtxo !== undefined) {
        UTXO.encode(message.onChainUtxo, writer.uint32(18).fork()).join();
      }
      if (message.rootTxSigningJob !== undefined) {
        SigningJob.encode(
          message.rootTxSigningJob,
          writer.uint32(26).fork(),
        ).join();
      }
      if (message.refundTxSigningJob !== undefined) {
        SigningJob.encode(
          message.refundTxSigningJob,
          writer.uint32(34).fork(),
        ).join();
      }
      return writer;
    },

    decode(
      input: BinaryReader | Uint8Array,
      length?: number,
    ): StartDepositTreeCreationRequest {
      const reader =
        input instanceof BinaryReader ? input : new BinaryReader(input);
      let end = length === undefined ? reader.len : reader.pos + length;
      const message = createBaseStartDepositTreeCreationRequest();
      while (reader.pos < end) {
        const tag = reader.uint32();
        switch (tag >>> 3) {
          case 1: {
            if (tag !== 10) {
              break;
            }

            message.identityPublicKey = reader.bytes();
            continue;
          }
          case 2: {
            if (tag !== 18) {
              break;
            }

            message.onChainUtxo = UTXO.decode(reader, reader.uint32());
            continue;
          }
          case 3: {
            if (tag !== 26) {
              break;
            }

            message.rootTxSigningJob = SigningJob.decode(
              reader,
              reader.uint32(),
            );
            continue;
          }
          case 4: {
            if (tag !== 34) {
              break;
            }

            message.refundTxSigningJob = SigningJob.decode(
              reader,
              reader.uint32(),
            );
            continue;
          }
        }
        if ((tag & 7) === 4 || tag === 0) {
          break;
        }
        reader.skip(tag & 7);
      }
      return message;
    },

    fromJSON(object: any): StartDepositTreeCreationRequest {
      return {
        identityPublicKey: isSet(object.identityPublicKey)
          ? bytesFromBase64(object.identityPublicKey)
          : new Uint8Array(0),
        onChainUtxo: isSet(object.onChainUtxo)
          ? UTXO.fromJSON(object.onChainUtxo)
          : undefined,
        rootTxSigningJob: isSet(object.rootTxSigningJob)
          ? SigningJob.fromJSON(object.rootTxSigningJob)
          : undefined,
        refundTxSigningJob: isSet(object.refundTxSigningJob)
          ? SigningJob.fromJSON(object.refundTxSigningJob)
          : undefined,
      };
    },

    toJSON(message: StartDepositTreeCreationRequest): unknown {
      const obj: any = {};
      if (message.identityPublicKey.length !== 0) {
        obj.identityPublicKey = base64FromBytes(message.identityPublicKey);
      }
      if (message.onChainUtxo !== undefined) {
        obj.onChainUtxo = UTXO.toJSON(message.onChainUtxo);
      }
      if (message.rootTxSigningJob !== undefined) {
        obj.rootTxSigningJob = SigningJob.toJSON(message.rootTxSigningJob);
      }
      if (message.refundTxSigningJob !== undefined) {
        obj.refundTxSigningJob = SigningJob.toJSON(message.refundTxSigningJob);
      }
      return obj;
    },

    create(
      base?: DeepPartial<StartDepositTreeCreationRequest>,
    ): StartDepositTreeCreationRequest {
      return StartDepositTreeCreationRequest.fromPartial(base ?? {});
    },
    fromPartial(
      object: DeepPartial<StartDepositTreeCreationRequest>,
    ): StartDepositTreeCreationRequest {
      const message = createBaseStartDepositTreeCreationRequest();
      message.identityPublicKey = object.identityPublicKey ?? new Uint8Array(0);
      message.onChainUtxo =
        object.onChainUtxo !== undefined && object.onChainUtxo !== null
          ? UTXO.fromPartial(object.onChainUtxo)
          : undefined;
      message.rootTxSigningJob =
        object.rootTxSigningJob !== undefined &&
        object.rootTxSigningJob !== null
          ? SigningJob.fromPartial(object.rootTxSigningJob)
          : undefined;
      message.refundTxSigningJob =
        object.refundTxSigningJob !== undefined &&
        object.refundTxSigningJob !== null
          ? SigningJob.fromPartial(object.refundTxSigningJob)
          : undefined;
      return message;
    },
  };

function createBaseStartDepositTreeCreationResponse(): StartDepositTreeCreationResponse {
  return { treeId: "", rootNodeSignatureShares: undefined };
}

export const StartDepositTreeCreationResponse: MessageFns<StartDepositTreeCreationResponse> =
  {
    encode(
      message: StartDepositTreeCreationResponse,
      writer: BinaryWriter = new BinaryWriter(),
    ): BinaryWriter {
      if (message.treeId !== "") {
        writer.uint32(10).string(message.treeId);
      }
      if (message.rootNodeSignatureShares !== undefined) {
        NodeSignatureShares.encode(
          message.rootNodeSignatureShares,
          writer.uint32(18).fork(),
        ).join();
      }
      return writer;
    },

    decode(
      input: BinaryReader | Uint8Array,
      length?: number,
    ): StartDepositTreeCreationResponse {
      const reader =
        input instanceof BinaryReader ? input : new BinaryReader(input);
      let end = length === undefined ? reader.len : reader.pos + length;
      const message = createBaseStartDepositTreeCreationResponse();
      while (reader.pos < end) {
        const tag = reader.uint32();
        switch (tag >>> 3) {
          case 1: {
            if (tag !== 10) {
              break;
            }

            message.treeId = reader.string();
            continue;
          }
          case 2: {
            if (tag !== 18) {
              break;
            }

            message.rootNodeSignatureShares = NodeSignatureShares.decode(
              reader,
              reader.uint32(),
            );
            continue;
          }
        }
        if ((tag & 7) === 4 || tag === 0) {
          break;
        }
        reader.skip(tag & 7);
      }
      return message;
    },

    fromJSON(object: any): StartDepositTreeCreationResponse {
      return {
        treeId: isSet(object.treeId) ? globalThis.String(object.treeId) : "",
        rootNodeSignatureShares: isSet(object.rootNodeSignatureShares)
          ? NodeSignatureShares.fromJSON(object.rootNodeSignatureShares)
          : undefined,
      };
    },

    toJSON(message: StartDepositTreeCreationResponse): unknown {
      const obj: any = {};
      if (message.treeId !== "") {
        obj.treeId = message.treeId;
      }
      if (message.rootNodeSignatureShares !== undefined) {
        obj.rootNodeSignatureShares = NodeSignatureShares.toJSON(
          message.rootNodeSignatureShares,
        );
      }
      return obj;
    },

    create(
      base?: DeepPartial<StartDepositTreeCreationResponse>,
    ): StartDepositTreeCreationResponse {
      return StartDepositTreeCreationResponse.fromPartial(base ?? {});
    },
    fromPartial(
      object: DeepPartial<StartDepositTreeCreationResponse>,
    ): StartDepositTreeCreationResponse {
      const message = createBaseStartDepositTreeCreationResponse();
      message.treeId = object.treeId ?? "";
      message.rootNodeSignatureShares =
        object.rootNodeSignatureShares !== undefined &&
        object.rootNodeSignatureShares !== null
          ? NodeSignatureShares.fromPartial(object.rootNodeSignatureShares)
          : undefined;
      return message;
    },
  };

function createBaseTokenOutputToSpend(): TokenOutputToSpend {
  return {
    prevTokenTransactionHash: new Uint8Array(0),
    prevTokenTransactionVout: 0,
  };
}

export const TokenOutputToSpend: MessageFns<TokenOutputToSpend> = {
  encode(
    message: TokenOutputToSpend,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.prevTokenTransactionHash.length !== 0) {
      writer.uint32(10).bytes(message.prevTokenTransactionHash);
    }
    if (message.prevTokenTransactionVout !== 0) {
      writer.uint32(16).uint32(message.prevTokenTransactionVout);
    }
    return writer;
  },

  decode(
    input: BinaryReader | Uint8Array,
    length?: number,
  ): TokenOutputToSpend {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTokenOutputToSpend();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.prevTokenTransactionHash = reader.bytes();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.prevTokenTransactionVout = reader.uint32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TokenOutputToSpend {
    return {
      prevTokenTransactionHash: isSet(object.prevTokenTransactionHash)
        ? bytesFromBase64(object.prevTokenTransactionHash)
        : new Uint8Array(0),
      prevTokenTransactionVout: isSet(object.prevTokenTransactionVout)
        ? globalThis.Number(object.prevTokenTransactionVout)
        : 0,
    };
  },

  toJSON(message: TokenOutputToSpend): unknown {
    const obj: any = {};
    if (message.prevTokenTransactionHash.length !== 0) {
      obj.prevTokenTransactionHash = base64FromBytes(
        message.prevTokenTransactionHash,
      );
    }
    if (message.prevTokenTransactionVout !== 0) {
      obj.prevTokenTransactionVout = Math.round(
        message.prevTokenTransactionVout,
      );
    }
    return obj;
  },

  create(base?: DeepPartial<TokenOutputToSpend>): TokenOutputToSpend {
    return TokenOutputToSpend.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<TokenOutputToSpend>): TokenOutputToSpend {
    const message = createBaseTokenOutputToSpend();
    message.prevTokenTransactionHash =
      object.prevTokenTransactionHash ?? new Uint8Array(0);
    message.prevTokenTransactionVout = object.prevTokenTransactionVout ?? 0;
    return message;
  },
};

function createBaseTokenTransferInput(): TokenTransferInput {
  return { outputsToSpend: [] };
}

export const TokenTransferInput: MessageFns<TokenTransferInput> = {
  encode(
    message: TokenTransferInput,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    for (const v of message.outputsToSpend) {
      TokenOutputToSpend.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(
    input: BinaryReader | Uint8Array,
    length?: number,
  ): TokenTransferInput {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTokenTransferInput();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.outputsToSpend.push(
            TokenOutputToSpend.decode(reader, reader.uint32()),
          );
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TokenTransferInput {
    return {
      outputsToSpend: globalThis.Array.isArray(object?.outputsToSpend)
        ? object.outputsToSpend.map((e: any) => TokenOutputToSpend.fromJSON(e))
        : [],
    };
  },

  toJSON(message: TokenTransferInput): unknown {
    const obj: any = {};
    if (message.outputsToSpend?.length) {
      obj.outputsToSpend = message.outputsToSpend.map((e) =>
        TokenOutputToSpend.toJSON(e),
      );
    }
    return obj;
  },

  create(base?: DeepPartial<TokenTransferInput>): TokenTransferInput {
    return TokenTransferInput.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<TokenTransferInput>): TokenTransferInput {
    const message = createBaseTokenTransferInput();
    message.outputsToSpend =
      object.outputsToSpend?.map((e) => TokenOutputToSpend.fromPartial(e)) ||
      [];
    return message;
  },
};

function createBaseTokenMintInput(): TokenMintInput {
  return { issuerPublicKey: new Uint8Array(0), issuerProvidedTimestamp: 0 };
}

export const TokenMintInput: MessageFns<TokenMintInput> = {
  encode(
    message: TokenMintInput,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.issuerPublicKey.length !== 0) {
      writer.uint32(10).bytes(message.issuerPublicKey);
    }
    if (message.issuerProvidedTimestamp !== 0) {
      writer.uint32(16).uint64(message.issuerProvidedTimestamp);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TokenMintInput {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTokenMintInput();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.issuerPublicKey = reader.bytes();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.issuerProvidedTimestamp = longToNumber(reader.uint64());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TokenMintInput {
    return {
      issuerPublicKey: isSet(object.issuerPublicKey)
        ? bytesFromBase64(object.issuerPublicKey)
        : new Uint8Array(0),
      issuerProvidedTimestamp: isSet(object.issuerProvidedTimestamp)
        ? globalThis.Number(object.issuerProvidedTimestamp)
        : 0,
    };
  },

  toJSON(message: TokenMintInput): unknown {
    const obj: any = {};
    if (message.issuerPublicKey.length !== 0) {
      obj.issuerPublicKey = base64FromBytes(message.issuerPublicKey);
    }
    if (message.issuerProvidedTimestamp !== 0) {
      obj.issuerProvidedTimestamp = Math.round(message.issuerProvidedTimestamp);
    }
    return obj;
  },

  create(base?: DeepPartial<TokenMintInput>): TokenMintInput {
    return TokenMintInput.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<TokenMintInput>): TokenMintInput {
    const message = createBaseTokenMintInput();
    message.issuerPublicKey = object.issuerPublicKey ?? new Uint8Array(0);
    message.issuerProvidedTimestamp = object.issuerProvidedTimestamp ?? 0;
    return message;
  },
};

function createBaseTokenOutput(): TokenOutput {
  return {
    id: undefined,
    ownerPublicKey: new Uint8Array(0),
    revocationCommitment: undefined,
    withdrawBondSats: undefined,
    withdrawRelativeBlockLocktime: undefined,
    tokenPublicKey: new Uint8Array(0),
    tokenAmount: new Uint8Array(0),
  };
}

export const TokenOutput: MessageFns<TokenOutput> = {
  encode(
    message: TokenOutput,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.id !== undefined) {
      writer.uint32(10).string(message.id);
    }
    if (message.ownerPublicKey.length !== 0) {
      writer.uint32(18).bytes(message.ownerPublicKey);
    }
    if (message.revocationCommitment !== undefined) {
      writer.uint32(26).bytes(message.revocationCommitment);
    }
    if (message.withdrawBondSats !== undefined) {
      writer.uint32(32).uint64(message.withdrawBondSats);
    }
    if (message.withdrawRelativeBlockLocktime !== undefined) {
      writer.uint32(40).uint64(message.withdrawRelativeBlockLocktime);
    }
    if (message.tokenPublicKey.length !== 0) {
      writer.uint32(50).bytes(message.tokenPublicKey);
    }
    if (message.tokenAmount.length !== 0) {
      writer.uint32(58).bytes(message.tokenAmount);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TokenOutput {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTokenOutput();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.ownerPublicKey = reader.bytes();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.revocationCommitment = reader.bytes();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.withdrawBondSats = longToNumber(reader.uint64());
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.withdrawRelativeBlockLocktime = longToNumber(reader.uint64());
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.tokenPublicKey = reader.bytes();
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.tokenAmount = reader.bytes();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TokenOutput {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : undefined,
      ownerPublicKey: isSet(object.ownerPublicKey)
        ? bytesFromBase64(object.ownerPublicKey)
        : new Uint8Array(0),
      revocationCommitment: isSet(object.revocationCommitment)
        ? bytesFromBase64(object.revocationCommitment)
        : undefined,
      withdrawBondSats: isSet(object.withdrawBondSats)
        ? globalThis.Number(object.withdrawBondSats)
        : undefined,
      withdrawRelativeBlockLocktime: isSet(object.withdrawRelativeBlockLocktime)
        ? globalThis.Number(object.withdrawRelativeBlockLocktime)
        : undefined,
      tokenPublicKey: isSet(object.tokenPublicKey)
        ? bytesFromBase64(object.tokenPublicKey)
        : new Uint8Array(0),
      tokenAmount: isSet(object.tokenAmount)
        ? bytesFromBase64(object.tokenAmount)
        : new Uint8Array(0),
    };
  },

  toJSON(message: TokenOutput): unknown {
    const obj: any = {};
    if (message.id !== undefined) {
      obj.id = message.id;
    }
    if (message.ownerPublicKey.length !== 0) {
      obj.ownerPublicKey = base64FromBytes(message.ownerPublicKey);
    }
    if (message.revocationCommitment !== undefined) {
      obj.revocationCommitment = base64FromBytes(message.revocationCommitment);
    }
    if (message.withdrawBondSats !== undefined) {
      obj.withdrawBondSats = Math.round(message.withdrawBondSats);
    }
    if (message.withdrawRelativeBlockLocktime !== undefined) {
      obj.withdrawRelativeBlockLocktime = Math.round(
        message.withdrawRelativeBlockLocktime,
      );
    }
    if (message.tokenPublicKey.length !== 0) {
      obj.tokenPublicKey = base64FromBytes(message.tokenPublicKey);
    }
    if (message.tokenAmount.length !== 0) {
      obj.tokenAmount = base64FromBytes(message.tokenAmount);
    }
    return obj;
  },

  create(base?: DeepPartial<TokenOutput>): TokenOutput {
    return TokenOutput.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<TokenOutput>): TokenOutput {
    const message = createBaseTokenOutput();
    message.id = object.id ?? undefined;
    message.ownerPublicKey = object.ownerPublicKey ?? new Uint8Array(0);
    message.revocationCommitment = object.revocationCommitment ?? undefined;
    message.withdrawBondSats = object.withdrawBondSats ?? undefined;
    message.withdrawRelativeBlockLocktime =
      object.withdrawRelativeBlockLocktime ?? undefined;
    message.tokenPublicKey = object.tokenPublicKey ?? new Uint8Array(0);
    message.tokenAmount = object.tokenAmount ?? new Uint8Array(0);
    return message;
  },
};

function createBaseTokenTransaction(): TokenTransaction {
  return {
    tokenInputs: undefined,
    tokenOutputs: [],
    sparkOperatorIdentityPublicKeys: [],
    network: 0,
  };
}

export const TokenTransaction: MessageFns<TokenTransaction> = {
  encode(
    message: TokenTransaction,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    switch (message.tokenInputs?.$case) {
      case "mintInput":
        TokenMintInput.encode(
          message.tokenInputs.mintInput,
          writer.uint32(10).fork(),
        ).join();
        break;
      case "transferInput":
        TokenTransferInput.encode(
          message.tokenInputs.transferInput,
          writer.uint32(18).fork(),
        ).join();
        break;
    }
    for (const v of message.tokenOutputs) {
      TokenOutput.encode(v!, writer.uint32(26).fork()).join();
    }
    for (const v of message.sparkOperatorIdentityPublicKeys) {
      writer.uint32(34).bytes(v!);
    }
    if (message.network !== 0) {
      writer.uint32(80).int32(message.network);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TokenTransaction {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTokenTransaction();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.tokenInputs = {
            $case: "mintInput",
            mintInput: TokenMintInput.decode(reader, reader.uint32()),
          };
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.tokenInputs = {
            $case: "transferInput",
            transferInput: TokenTransferInput.decode(reader, reader.uint32()),
          };
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.tokenOutputs.push(
            TokenOutput.decode(reader, reader.uint32()),
          );
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.sparkOperatorIdentityPublicKeys.push(reader.bytes());
          continue;
        }
        case 10: {
          if (tag !== 80) {
            break;
          }

          message.network = reader.int32() as any;
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TokenTransaction {
    return {
      tokenInputs: isSet(object.mintInput)
        ? {
            $case: "mintInput",
            mintInput: TokenMintInput.fromJSON(object.mintInput),
          }
        : isSet(object.transferInput)
          ? {
              $case: "transferInput",
              transferInput: TokenTransferInput.fromJSON(object.transferInput),
            }
          : undefined,
      tokenOutputs: globalThis.Array.isArray(object?.tokenOutputs)
        ? object.tokenOutputs.map((e: any) => TokenOutput.fromJSON(e))
        : [],
      sparkOperatorIdentityPublicKeys: globalThis.Array.isArray(
        object?.sparkOperatorIdentityPublicKeys,
      )
        ? object.sparkOperatorIdentityPublicKeys.map((e: any) =>
            bytesFromBase64(e),
          )
        : [],
      network: isSet(object.network) ? networkFromJSON(object.network) : 0,
    };
  },

  toJSON(message: TokenTransaction): unknown {
    const obj: any = {};
    if (message.tokenInputs?.$case === "mintInput") {
      obj.mintInput = TokenMintInput.toJSON(message.tokenInputs.mintInput);
    } else if (message.tokenInputs?.$case === "transferInput") {
      obj.transferInput = TokenTransferInput.toJSON(
        message.tokenInputs.transferInput,
      );
    }
    if (message.tokenOutputs?.length) {
      obj.tokenOutputs = message.tokenOutputs.map((e) => TokenOutput.toJSON(e));
    }
    if (message.sparkOperatorIdentityPublicKeys?.length) {
      obj.sparkOperatorIdentityPublicKeys =
        message.sparkOperatorIdentityPublicKeys.map((e) => base64FromBytes(e));
    }
    if (message.network !== 0) {
      obj.network = networkToJSON(message.network);
    }
    return obj;
  },

  create(base?: DeepPartial<TokenTransaction>): TokenTransaction {
    return TokenTransaction.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<TokenTransaction>): TokenTransaction {
    const message = createBaseTokenTransaction();
    switch (object.tokenInputs?.$case) {
      case "mintInput": {
        if (
          object.tokenInputs?.mintInput !== undefined &&
          object.tokenInputs?.mintInput !== null
        ) {
          message.tokenInputs = {
            $case: "mintInput",
            mintInput: TokenMintInput.fromPartial(object.tokenInputs.mintInput),
          };
        }
        break;
      }
      case "transferInput": {
        if (
          object.tokenInputs?.transferInput !== undefined &&
          object.tokenInputs?.transferInput !== null
        ) {
          message.tokenInputs = {
            $case: "transferInput",
            transferInput: TokenTransferInput.fromPartial(
              object.tokenInputs.transferInput,
            ),
          };
        }
        break;
      }
    }
    message.tokenOutputs =
      object.tokenOutputs?.map((e) => TokenOutput.fromPartial(e)) || [];
    message.sparkOperatorIdentityPublicKeys =
      object.sparkOperatorIdentityPublicKeys?.map((e) => e) || [];
    message.network = object.network ?? 0;
    return message;
  },
};

function createBaseTokenTransactionWithStatus(): TokenTransactionWithStatus {
  return { tokenTransaction: undefined, status: 0 };
}

export const TokenTransactionWithStatus: MessageFns<TokenTransactionWithStatus> =
  {
    encode(
      message: TokenTransactionWithStatus,
      writer: BinaryWriter = new BinaryWriter(),
    ): BinaryWriter {
      if (message.tokenTransaction !== undefined) {
        TokenTransaction.encode(
          message.tokenTransaction,
          writer.uint32(10).fork(),
        ).join();
      }
      if (message.status !== 0) {
        writer.uint32(16).int32(message.status);
      }
      return writer;
    },

    decode(
      input: BinaryReader | Uint8Array,
      length?: number,
    ): TokenTransactionWithStatus {
      const reader =
        input instanceof BinaryReader ? input : new BinaryReader(input);
      let end = length === undefined ? reader.len : reader.pos + length;
      const message = createBaseTokenTransactionWithStatus();
      while (reader.pos < end) {
        const tag = reader.uint32();
        switch (tag >>> 3) {
          case 1: {
            if (tag !== 10) {
              break;
            }

            message.tokenTransaction = TokenTransaction.decode(
              reader,
              reader.uint32(),
            );
            continue;
          }
          case 2: {
            if (tag !== 16) {
              break;
            }

            message.status = reader.int32() as any;
            continue;
          }
        }
        if ((tag & 7) === 4 || tag === 0) {
          break;
        }
        reader.skip(tag & 7);
      }
      return message;
    },

    fromJSON(object: any): TokenTransactionWithStatus {
      return {
        tokenTransaction: isSet(object.tokenTransaction)
          ? TokenTransaction.fromJSON(object.tokenTransaction)
          : undefined,
        status: isSet(object.status)
          ? tokenTransactionStatusFromJSON(object.status)
          : 0,
      };
    },

    toJSON(message: TokenTransactionWithStatus): unknown {
      const obj: any = {};
      if (message.tokenTransaction !== undefined) {
        obj.tokenTransaction = TokenTransaction.toJSON(
          message.tokenTransaction,
        );
      }
      if (message.status !== 0) {
        obj.status = tokenTransactionStatusToJSON(message.status);
      }
      return obj;
    },

    create(
      base?: DeepPartial<TokenTransactionWithStatus>,
    ): TokenTransactionWithStatus {
      return TokenTransactionWithStatus.fromPartial(base ?? {});
    },
    fromPartial(
      object: DeepPartial<TokenTransactionWithStatus>,
    ): TokenTransactionWithStatus {
      const message = createBaseTokenTransactionWithStatus();
      message.tokenTransaction =
        object.tokenTransaction !== undefined &&
        object.tokenTransaction !== null
          ? TokenTransaction.fromPartial(object.tokenTransaction)
          : undefined;
      message.status = object.status ?? 0;
      return message;
    },
  };

function createBaseTokenTransactionSignatures(): TokenTransactionSignatures {
  return { ownerSignatures: [] };
}

export const TokenTransactionSignatures: MessageFns<TokenTransactionSignatures> =
  {
    encode(
      message: TokenTransactionSignatures,
      writer: BinaryWriter = new BinaryWriter(),
    ): BinaryWriter {
      for (const v of message.ownerSignatures) {
        writer.uint32(10).bytes(v!);
      }
      return writer;
    },

    decode(
      input: BinaryReader | Uint8Array,
      length?: number,
    ): TokenTransactionSignatures {
      const reader =
        input instanceof BinaryReader ? input : new BinaryReader(input);
      let end = length === undefined ? reader.len : reader.pos + length;
      const message = createBaseTokenTransactionSignatures();
      while (reader.pos < end) {
        const tag = reader.uint32();
        switch (tag >>> 3) {
          case 1: {
            if (tag !== 10) {
              break;
            }

            message.ownerSignatures.push(reader.bytes());
            continue;
          }
        }
        if ((tag & 7) === 4 || tag === 0) {
          break;
        }
        reader.skip(tag & 7);
      }
      return message;
    },

    fromJSON(object: any): TokenTransactionSignatures {
      return {
        ownerSignatures: globalThis.Array.isArray(object?.ownerSignatures)
          ? object.ownerSignatures.map((e: any) => bytesFromBase64(e))
          : [],
      };
    },

    toJSON(message: TokenTransactionSignatures): unknown {
      const obj: any = {};
      if (message.ownerSignatures?.length) {
        obj.ownerSignatures = message.ownerSignatures.map((e) =>
          base64FromBytes(e),
        );
      }
      return obj;
    },

    create(
      base?: DeepPartial<TokenTransactionSignatures>,
    ): TokenTransactionSignatures {
      return TokenTransactionSignatures.fromPartial(base ?? {});
    },
    fromPartial(
      object: DeepPartial<TokenTransactionSignatures>,
    ): TokenTransactionSignatures {
      const message = createBaseTokenTransactionSignatures();
      message.ownerSignatures = object.ownerSignatures?.map((e) => e) || [];
      return message;
    },
  };

function createBaseStartTokenTransactionRequest(): StartTokenTransactionRequest {
  return {
    identityPublicKey: new Uint8Array(0),
    partialTokenTransaction: undefined,
    tokenTransactionSignatures: undefined,
  };
}

export const StartTokenTransactionRequest: MessageFns<StartTokenTransactionRequest> =
  {
    encode(
      message: StartTokenTransactionRequest,
      writer: BinaryWriter = new BinaryWriter(),
    ): BinaryWriter {
      if (message.identityPublicKey.length !== 0) {
        writer.uint32(10).bytes(message.identityPublicKey);
      }
      if (message.partialTokenTransaction !== undefined) {
        TokenTransaction.encode(
          message.partialTokenTransaction,
          writer.uint32(18).fork(),
        ).join();
      }
      if (message.tokenTransactionSignatures !== undefined) {
        TokenTransactionSignatures.encode(
          message.tokenTransactionSignatures,
          writer.uint32(26).fork(),
        ).join();
      }
      return writer;
    },

    decode(
      input: BinaryReader | Uint8Array,
      length?: number,
    ): StartTokenTransactionRequest {
      const reader =
        input instanceof BinaryReader ? input : new BinaryReader(input);
      let end = length === undefined ? reader.len : reader.pos + length;
      const message = createBaseStartTokenTransactionRequest();
      while (reader.pos < end) {
        const tag = reader.uint32();
        switch (tag >>> 3) {
          case 1: {
            if (tag !== 10) {
              break;
            }

            message.identityPublicKey = reader.bytes();
            continue;
          }
          case 2: {
            if (tag !== 18) {
              break;
            }

            message.partialTokenTransaction = TokenTransaction.decode(
              reader,
              reader.uint32(),
            );
            continue;
          }
          case 3: {
            if (tag !== 26) {
              break;
            }

            message.tokenTransactionSignatures =
              TokenTransactionSignatures.decode(reader, reader.uint32());
            continue;
          }
        }
        if ((tag & 7) === 4 || tag === 0) {
          break;
        }
        reader.skip(tag & 7);
      }
      return message;
    },

    fromJSON(object: any): StartTokenTransactionRequest {
      return {
        identityPublicKey: isSet(object.identityPublicKey)
          ? bytesFromBase64(object.identityPublicKey)
          : new Uint8Array(0),
        partialTokenTransaction: isSet(object.partialTokenTransaction)
          ? TokenTransaction.fromJSON(object.partialTokenTransaction)
          : undefined,
        tokenTransactionSignatures: isSet(object.tokenTransactionSignatures)
          ? TokenTransactionSignatures.fromJSON(
              object.tokenTransactionSignatures,
            )
          : undefined,
      };
    },

    toJSON(message: StartTokenTransactionRequest): unknown {
      const obj: any = {};
      if (message.identityPublicKey.length !== 0) {
        obj.identityPublicKey = base64FromBytes(message.identityPublicKey);
      }
      if (message.partialTokenTransaction !== undefined) {
        obj.partialTokenTransaction = TokenTransaction.toJSON(
          message.partialTokenTransaction,
        );
      }
      if (message.tokenTransactionSignatures !== undefined) {
        obj.tokenTransactionSignatures = TokenTransactionSignatures.toJSON(
          message.tokenTransactionSignatures,
        );
      }
      return obj;
    },

    create(
      base?: DeepPartial<StartTokenTransactionRequest>,
    ): StartTokenTransactionRequest {
      return StartTokenTransactionRequest.fromPartial(base ?? {});
    },
    fromPartial(
      object: DeepPartial<StartTokenTransactionRequest>,
    ): StartTokenTransactionRequest {
      const message = createBaseStartTokenTransactionRequest();
      message.identityPublicKey = object.identityPublicKey ?? new Uint8Array(0);
      message.partialTokenTransaction =
        object.partialTokenTransaction !== undefined &&
        object.partialTokenTransaction !== null
          ? TokenTransaction.fromPartial(object.partialTokenTransaction)
          : undefined;
      message.tokenTransactionSignatures =
        object.tokenTransactionSignatures !== undefined &&
        object.tokenTransactionSignatures !== null
          ? TokenTransactionSignatures.fromPartial(
              object.tokenTransactionSignatures,
            )
          : undefined;
      return message;
    },
  };

function createBaseStartTokenTransactionResponse(): StartTokenTransactionResponse {
  return { finalTokenTransaction: undefined, keyshareInfo: undefined };
}

export const StartTokenTransactionResponse: MessageFns<StartTokenTransactionResponse> =
  {
    encode(
      message: StartTokenTransactionResponse,
      writer: BinaryWriter = new BinaryWriter(),
    ): BinaryWriter {
      if (message.finalTokenTransaction !== undefined) {
        TokenTransaction.encode(
          message.finalTokenTransaction,
          writer.uint32(10).fork(),
        ).join();
      }
      if (message.keyshareInfo !== undefined) {
        SigningKeyshare.encode(
          message.keyshareInfo,
          writer.uint32(18).fork(),
        ).join();
      }
      return writer;
    },

    decode(
      input: BinaryReader | Uint8Array,
      length?: number,
    ): StartTokenTransactionResponse {
      const reader =
        input instanceof BinaryReader ? input : new BinaryReader(input);
      let end = length === undefined ? reader.len : reader.pos + length;
      const message = createBaseStartTokenTransactionResponse();
      while (reader.pos < end) {
        const tag = reader.uint32();
        switch (tag >>> 3) {
          case 1: {
            if (tag !== 10) {
              break;
            }

            message.finalTokenTransaction = TokenTransaction.decode(
              reader,
              reader.uint32(),
            );
            continue;
          }
          case 2: {
            if (tag !== 18) {
              break;
            }

            message.keyshareInfo = SigningKeyshare.decode(
              reader,
              reader.uint32(),
            );
            continue;
          }
        }
        if ((tag & 7) === 4 || tag === 0) {
          break;
        }
        reader.skip(tag & 7);
      }
      return message;
    },

    fromJSON(object: any): StartTokenTransactionResponse {
      return {
        finalTokenTransaction: isSet(object.finalTokenTransaction)
          ? TokenTransaction.fromJSON(object.finalTokenTransaction)
          : undefined,
        keyshareInfo: isSet(object.keyshareInfo)
          ? SigningKeyshare.fromJSON(object.keyshareInfo)
          : undefined,
      };
    },

    toJSON(message: StartTokenTransactionResponse): unknown {
      const obj: any = {};
      if (message.finalTokenTransaction !== undefined) {
        obj.finalTokenTransaction = TokenTransaction.toJSON(
          message.finalTokenTransaction,
        );
      }
      if (message.keyshareInfo !== undefined) {
        obj.keyshareInfo = SigningKeyshare.toJSON(message.keyshareInfo);
      }
      return obj;
    },

    create(
      base?: DeepPartial<StartTokenTransactionResponse>,
    ): StartTokenTransactionResponse {
      return StartTokenTransactionResponse.fromPartial(base ?? {});
    },
    fromPartial(
      object: DeepPartial<StartTokenTransactionResponse>,
    ): StartTokenTransactionResponse {
      const message = createBaseStartTokenTransactionResponse();
      message.finalTokenTransaction =
        object.finalTokenTransaction !== undefined &&
        object.finalTokenTransaction !== null
          ? TokenTransaction.fromPartial(object.finalTokenTransaction)
          : undefined;
      message.keyshareInfo =
        object.keyshareInfo !== undefined && object.keyshareInfo !== null
          ? SigningKeyshare.fromPartial(object.keyshareInfo)
          : undefined;
      return message;
    },
  };

function createBaseOperatorSpecificTokenTransactionSignablePayload(): OperatorSpecificTokenTransactionSignablePayload {
  return {
    finalTokenTransactionHash: new Uint8Array(0),
    operatorIdentityPublicKey: new Uint8Array(0),
  };
}

export const OperatorSpecificTokenTransactionSignablePayload: MessageFns<OperatorSpecificTokenTransactionSignablePayload> =
  {
    encode(
      message: OperatorSpecificTokenTransactionSignablePayload,
      writer: BinaryWriter = new BinaryWriter(),
    ): BinaryWriter {
      if (message.finalTokenTransactionHash.length !== 0) {
        writer.uint32(10).bytes(message.finalTokenTransactionHash);
      }
      if (message.operatorIdentityPublicKey.length !== 0) {
        writer.uint32(18).bytes(message.operatorIdentityPublicKey);
      }
      return writer;
    },

    decode(
      input: BinaryReader | Uint8Array,
      length?: number,
    ): OperatorSpecificTokenTransactionSignablePayload {
      const reader =
        input instanceof BinaryReader ? input : new BinaryReader(input);
      let end = length === undefined ? reader.len : reader.pos + length;
      const message =
        createBaseOperatorSpecificTokenTransactionSignablePayload();
      while (reader.pos < end) {
        const tag = reader.uint32();
        switch (tag >>> 3) {
          case 1: {
            if (tag !== 10) {
              break;
            }

            message.finalTokenTransactionHash = reader.bytes();
            continue;
          }
          case 2: {
            if (tag !== 18) {
              break;
            }

            message.operatorIdentityPublicKey = reader.bytes();
            continue;
          }
        }
        if ((tag & 7) === 4 || tag === 0) {
          break;
        }
        reader.skip(tag & 7);
      }
      return message;
    },

    fromJSON(object: any): OperatorSpecificTokenTransactionSignablePayload {
      return {
        finalTokenTransactionHash: isSet(object.finalTokenTransactionHash)
          ? bytesFromBase64(object.finalTokenTransactionHash)
          : new Uint8Array(0),
        operatorIdentityPublicKey: isSet(object.operatorIdentityPublicKey)
          ? bytesFromBase64(object.operatorIdentityPublicKey)
          : new Uint8Array(0),
      };
    },

    toJSON(message: OperatorSpecificTokenTransactionSignablePayload): unknown {
      const obj: any = {};
      if (message.finalTokenTransactionHash.length !== 0) {
        obj.finalTokenTransactionHash = base64FromBytes(
          message.finalTokenTransactionHash,
        );
      }
      if (message.operatorIdentityPublicKey.length !== 0) {
        obj.operatorIdentityPublicKey = base64FromBytes(
          message.operatorIdentityPublicKey,
        );
      }
      return obj;
    },

    create(
      base?: DeepPartial<OperatorSpecificTokenTransactionSignablePayload>,
    ): OperatorSpecificTokenTransactionSignablePayload {
      return OperatorSpecificTokenTransactionSignablePayload.fromPartial(
        base ?? {},
      );
    },
    fromPartial(
      object: DeepPartial<OperatorSpecificTokenTransactionSignablePayload>,
    ): OperatorSpecificTokenTransactionSignablePayload {
      const message =
        createBaseOperatorSpecificTokenTransactionSignablePayload();
      message.finalTokenTransactionHash =
        object.finalTokenTransactionHash ?? new Uint8Array(0);
      message.operatorIdentityPublicKey =
        object.operatorIdentityPublicKey ?? new Uint8Array(0);
      return message;
    },
  };

function createBaseOperatorSpecificOwnerSignature(): OperatorSpecificOwnerSignature {
  return {
    ownerPublicKey: new Uint8Array(0),
    ownerSignature: new Uint8Array(0),
    payload: undefined,
  };
}

export const OperatorSpecificOwnerSignature: MessageFns<OperatorSpecificOwnerSignature> =
  {
    encode(
      message: OperatorSpecificOwnerSignature,
      writer: BinaryWriter = new BinaryWriter(),
    ): BinaryWriter {
      if (message.ownerPublicKey.length !== 0) {
        writer.uint32(10).bytes(message.ownerPublicKey);
      }
      if (message.ownerSignature.length !== 0) {
        writer.uint32(18).bytes(message.ownerSignature);
      }
      if (message.payload !== undefined) {
        OperatorSpecificTokenTransactionSignablePayload.encode(
          message.payload,
          writer.uint32(26).fork(),
        ).join();
      }
      return writer;
    },

    decode(
      input: BinaryReader | Uint8Array,
      length?: number,
    ): OperatorSpecificOwnerSignature {
      const reader =
        input instanceof BinaryReader ? input : new BinaryReader(input);
      let end = length === undefined ? reader.len : reader.pos + length;
      const message = createBaseOperatorSpecificOwnerSignature();
      while (reader.pos < end) {
        const tag = reader.uint32();
        switch (tag >>> 3) {
          case 1: {
            if (tag !== 10) {
              break;
            }

            message.ownerPublicKey = reader.bytes();
            continue;
          }
          case 2: {
            if (tag !== 18) {
              break;
            }

            message.ownerSignature = reader.bytes();
            continue;
          }
          case 3: {
            if (tag !== 26) {
              break;
            }

            message.payload =
              OperatorSpecificTokenTransactionSignablePayload.decode(
                reader,
                reader.uint32(),
              );
            continue;
          }
        }
        if ((tag & 7) === 4 || tag === 0) {
          break;
        }
        reader.skip(tag & 7);
      }
      return message;
    },

    fromJSON(object: any): OperatorSpecificOwnerSignature {
      return {
        ownerPublicKey: isSet(object.ownerPublicKey)
          ? bytesFromBase64(object.ownerPublicKey)
          : new Uint8Array(0),
        ownerSignature: isSet(object.ownerSignature)
          ? bytesFromBase64(object.ownerSignature)
          : new Uint8Array(0),
        payload: isSet(object.payload)
          ? OperatorSpecificTokenTransactionSignablePayload.fromJSON(
              object.payload,
            )
          : undefined,
      };
    },

    toJSON(message: OperatorSpecificOwnerSignature): unknown {
      const obj: any = {};
      if (message.ownerPublicKey.length !== 0) {
        obj.ownerPublicKey = base64FromBytes(message.ownerPublicKey);
      }
      if (message.ownerSignature.length !== 0) {
        obj.ownerSignature = base64FromBytes(message.ownerSignature);
      }
      if (message.payload !== undefined) {
        obj.payload = OperatorSpecificTokenTransactionSignablePayload.toJSON(
          message.payload,
        );
      }
      return obj;
    },

    create(
      base?: DeepPartial<OperatorSpecificOwnerSignature>,
    ): OperatorSpecificOwnerSignature {
      return OperatorSpecificOwnerSignature.fromPartial(base ?? {});
    },
    fromPartial(
      object: DeepPartial<OperatorSpecificOwnerSignature>,
    ): OperatorSpecificOwnerSignature {
      const message = createBaseOperatorSpecificOwnerSignature();
      message.ownerPublicKey = object.ownerPublicKey ?? new Uint8Array(0);
      message.ownerSignature = object.ownerSignature ?? new Uint8Array(0);
      message.payload =
        object.payload !== undefined && object.payload !== null
          ? OperatorSpecificTokenTransactionSignablePayload.fromPartial(
              object.payload,
            )
          : undefined;
      return message;
    },
  };

function createBaseSignTokenTransactionRequest(): SignTokenTransactionRequest {
  return {
    finalTokenTransaction: undefined,
    operatorSpecificSignatures: [],
    identityPublicKey: new Uint8Array(0),
  };
}

export const SignTokenTransactionRequest: MessageFns<SignTokenTransactionRequest> =
  {
    encode(
      message: SignTokenTransactionRequest,
      writer: BinaryWriter = new BinaryWriter(),
    ): BinaryWriter {
      if (message.finalTokenTransaction !== undefined) {
        TokenTransaction.encode(
          message.finalTokenTransaction,
          writer.uint32(10).fork(),
        ).join();
      }
      for (const v of message.operatorSpecificSignatures) {
        OperatorSpecificOwnerSignature.encode(
          v!,
          writer.uint32(18).fork(),
        ).join();
      }
      if (message.identityPublicKey.length !== 0) {
        writer.uint32(26).bytes(message.identityPublicKey);
      }
      return writer;
    },

    decode(
      input: BinaryReader | Uint8Array,
      length?: number,
    ): SignTokenTransactionRequest {
      const reader =
        input instanceof BinaryReader ? input : new BinaryReader(input);
      let end = length === undefined ? reader.len : reader.pos + length;
      const message = createBaseSignTokenTransactionRequest();
      while (reader.pos < end) {
        const tag = reader.uint32();
        switch (tag >>> 3) {
          case 1: {
            if (tag !== 10) {
              break;
            }

            message.finalTokenTransaction = TokenTransaction.decode(
              reader,
              reader.uint32(),
            );
            continue;
          }
          case 2: {
            if (tag !== 18) {
              break;
            }

            message.operatorSpecificSignatures.push(
              OperatorSpecificOwnerSignature.decode(reader, reader.uint32()),
            );
            continue;
          }
          case 3: {
            if (tag !== 26) {
              break;
            }

            message.identityPublicKey = reader.bytes();
            continue;
          }
        }
        if ((tag & 7) === 4 || tag === 0) {
          break;
        }
        reader.skip(tag & 7);
      }
      return message;
    },

    fromJSON(object: any): SignTokenTransactionRequest {
      return {
        finalTokenTransaction: isSet(object.finalTokenTransaction)
          ? TokenTransaction.fromJSON(object.finalTokenTransaction)
          : undefined,
        operatorSpecificSignatures: globalThis.Array.isArray(
          object?.operatorSpecificSignatures,
        )
          ? object.operatorSpecificSignatures.map((e: any) =>
              OperatorSpecificOwnerSignature.fromJSON(e),
            )
          : [],
        identityPublicKey: isSet(object.identityPublicKey)
          ? bytesFromBase64(object.identityPublicKey)
          : new Uint8Array(0),
      };
    },

    toJSON(message: SignTokenTransactionRequest): unknown {
      const obj: any = {};
      if (message.finalTokenTransaction !== undefined) {
        obj.finalTokenTransaction = TokenTransaction.toJSON(
          message.finalTokenTransaction,
        );
      }
      if (message.operatorSpecificSignatures?.length) {
        obj.operatorSpecificSignatures = message.operatorSpecificSignatures.map(
          (e) => OperatorSpecificOwnerSignature.toJSON(e),
        );
      }
      if (message.identityPublicKey.length !== 0) {
        obj.identityPublicKey = base64FromBytes(message.identityPublicKey);
      }
      return obj;
    },

    create(
      base?: DeepPartial<SignTokenTransactionRequest>,
    ): SignTokenTransactionRequest {
      return SignTokenTransactionRequest.fromPartial(base ?? {});
    },
    fromPartial(
      object: DeepPartial<SignTokenTransactionRequest>,
    ): SignTokenTransactionRequest {
      const message = createBaseSignTokenTransactionRequest();
      message.finalTokenTransaction =
        object.finalTokenTransaction !== undefined &&
        object.finalTokenTransaction !== null
          ? TokenTransaction.fromPartial(object.finalTokenTransaction)
          : undefined;
      message.operatorSpecificSignatures =
        object.operatorSpecificSignatures?.map((e) =>
          OperatorSpecificOwnerSignature.fromPartial(e),
        ) || [];
      message.identityPublicKey = object.identityPublicKey ?? new Uint8Array(0);
      return message;
    },
  };

function createBaseSignTokenTransactionResponse(): SignTokenTransactionResponse {
  return {
    sparkOperatorSignature: new Uint8Array(0),
    tokenTransactionRevocationKeyshares: [],
  };
}

export const SignTokenTransactionResponse: MessageFns<SignTokenTransactionResponse> =
  {
    encode(
      message: SignTokenTransactionResponse,
      writer: BinaryWriter = new BinaryWriter(),
    ): BinaryWriter {
      if (message.sparkOperatorSignature.length !== 0) {
        writer.uint32(10).bytes(message.sparkOperatorSignature);
      }
      for (const v of message.tokenTransactionRevocationKeyshares) {
        writer.uint32(18).bytes(v!);
      }
      return writer;
    },

    decode(
      input: BinaryReader | Uint8Array,
      length?: number,
    ): SignTokenTransactionResponse {
      const reader =
        input instanceof BinaryReader ? input : new BinaryReader(input);
      let end = length === undefined ? reader.len : reader.pos + length;
      const message = createBaseSignTokenTransactionResponse();
      while (reader.pos < end) {
        const tag = reader.uint32();
        switch (tag >>> 3) {
          case 1: {
            if (tag !== 10) {
              break;
            }

            message.sparkOperatorSignature = reader.bytes();
            continue;
          }
          case 2: {
            if (tag !== 18) {
              break;
            }

            message.tokenTransactionRevocationKeyshares.push(reader.bytes());
            continue;
          }
        }
        if ((tag & 7) === 4 || tag === 0) {
          break;
        }
        reader.skip(tag & 7);
      }
      return message;
    },

    fromJSON(object: any): SignTokenTransactionResponse {
      return {
        sparkOperatorSignature: isSet(object.sparkOperatorSignature)
          ? bytesFromBase64(object.sparkOperatorSignature)
          : new Uint8Array(0),
        tokenTransactionRevocationKeyshares: globalThis.Array.isArray(
          object?.tokenTransactionRevocationKeyshares,
        )
          ? object.tokenTransactionRevocationKeyshares.map((e: any) =>
              bytesFromBase64(e),
            )
          : [],
      };
    },

    toJSON(message: SignTokenTransactionResponse): unknown {
      const obj: any = {};
      if (message.sparkOperatorSignature.length !== 0) {
        obj.sparkOperatorSignature = base64FromBytes(
          message.sparkOperatorSignature,
        );
      }
      if (message.tokenTransactionRevocationKeyshares?.length) {
        obj.tokenTransactionRevocationKeyshares =
          message.tokenTransactionRevocationKeyshares.map((e) =>
            base64FromBytes(e),
          );
      }
      return obj;
    },

    create(
      base?: DeepPartial<SignTokenTransactionResponse>,
    ): SignTokenTransactionResponse {
      return SignTokenTransactionResponse.fromPartial(base ?? {});
    },
    fromPartial(
      object: DeepPartial<SignTokenTransactionResponse>,
    ): SignTokenTransactionResponse {
      const message = createBaseSignTokenTransactionResponse();
      message.sparkOperatorSignature =
        object.sparkOperatorSignature ?? new Uint8Array(0);
      message.tokenTransactionRevocationKeyshares =
        object.tokenTransactionRevocationKeyshares?.map((e) => e) || [];
      return message;
    },
  };

function createBaseFinalizeTokenTransactionRequest(): FinalizeTokenTransactionRequest {
  return {
    finalTokenTransaction: undefined,
    outputToSpendRevocationSecrets: [],
    identityPublicKey: new Uint8Array(0),
  };
}

export const FinalizeTokenTransactionRequest: MessageFns<FinalizeTokenTransactionRequest> =
  {
    encode(
      message: FinalizeTokenTransactionRequest,
      writer: BinaryWriter = new BinaryWriter(),
    ): BinaryWriter {
      if (message.finalTokenTransaction !== undefined) {
        TokenTransaction.encode(
          message.finalTokenTransaction,
          writer.uint32(10).fork(),
        ).join();
      }
      for (const v of message.outputToSpendRevocationSecrets) {
        writer.uint32(18).bytes(v!);
      }
      if (message.identityPublicKey.length !== 0) {
        writer.uint32(26).bytes(message.identityPublicKey);
      }
      return writer;
    },

    decode(
      input: BinaryReader | Uint8Array,
      length?: number,
    ): FinalizeTokenTransactionRequest {
      const reader =
        input instanceof BinaryReader ? input : new BinaryReader(input);
      let end = length === undefined ? reader.len : reader.pos + length;
      const message = createBaseFinalizeTokenTransactionRequest();
      while (reader.pos < end) {
        const tag = reader.uint32();
        switch (tag >>> 3) {
          case 1: {
            if (tag !== 10) {
              break;
            }

            message.finalTokenTransaction = TokenTransaction.decode(
              reader,
              reader.uint32(),
            );
            continue;
          }
          case 2: {
            if (tag !== 18) {
              break;
            }

            message.outputToSpendRevocationSecrets.push(reader.bytes());
            continue;
          }
          case 3: {
            if (tag !== 26) {
              break;
            }

            message.identityPublicKey = reader.bytes();
            continue;
          }
        }
        if ((tag & 7) === 4 || tag === 0) {
          break;
        }
        reader.skip(tag & 7);
      }
      return message;
    },

    fromJSON(object: any): FinalizeTokenTransactionRequest {
      return {
        finalTokenTransaction: isSet(object.finalTokenTransaction)
          ? TokenTransaction.fromJSON(object.finalTokenTransaction)
          : undefined,
        outputToSpendRevocationSecrets: globalThis.Array.isArray(
          object?.outputToSpendRevocationSecrets,
        )
          ? object.outputToSpendRevocationSecrets.map((e: any) =>
              bytesFromBase64(e),
            )
          : [],
        identityPublicKey: isSet(object.identityPublicKey)
          ? bytesFromBase64(object.identityPublicKey)
          : new Uint8Array(0),
      };
    },

    toJSON(message: FinalizeTokenTransactionRequest): unknown {
      const obj: any = {};
      if (message.finalTokenTransaction !== undefined) {
        obj.finalTokenTransaction = TokenTransaction.toJSON(
          message.finalTokenTransaction,
        );
      }
      if (message.outputToSpendRevocationSecrets?.length) {
        obj.outputToSpendRevocationSecrets =
          message.outputToSpendRevocationSecrets.map((e) => base64FromBytes(e));
      }
      if (message.identityPublicKey.length !== 0) {
        obj.identityPublicKey = base64FromBytes(message.identityPublicKey);
      }
      return obj;
    },

    create(
      base?: DeepPartial<FinalizeTokenTransactionRequest>,
    ): FinalizeTokenTransactionRequest {
      return FinalizeTokenTransactionRequest.fromPartial(base ?? {});
    },
    fromPartial(
      object: DeepPartial<FinalizeTokenTransactionRequest>,
    ): FinalizeTokenTransactionRequest {
      const message = createBaseFinalizeTokenTransactionRequest();
      message.finalTokenTransaction =
        object.finalTokenTransaction !== undefined &&
        object.finalTokenTransaction !== null
          ? TokenTransaction.fromPartial(object.finalTokenTransaction)
          : undefined;
      message.outputToSpendRevocationSecrets =
        object.outputToSpendRevocationSecrets?.map((e) => e) || [];
      message.identityPublicKey = object.identityPublicKey ?? new Uint8Array(0);
      return message;
    },
  };

function createBaseFreezeTokensPayload(): FreezeTokensPayload {
  return {
    ownerPublicKey: new Uint8Array(0),
    tokenPublicKey: new Uint8Array(0),
    issuerProvidedTimestamp: 0,
    operatorIdentityPublicKey: new Uint8Array(0),
    shouldUnfreeze: false,
  };
}

export const FreezeTokensPayload: MessageFns<FreezeTokensPayload> = {
  encode(
    message: FreezeTokensPayload,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.ownerPublicKey.length !== 0) {
      writer.uint32(10).bytes(message.ownerPublicKey);
    }
    if (message.tokenPublicKey.length !== 0) {
      writer.uint32(18).bytes(message.tokenPublicKey);
    }
    if (message.issuerProvidedTimestamp !== 0) {
      writer.uint32(24).uint64(message.issuerProvidedTimestamp);
    }
    if (message.operatorIdentityPublicKey.length !== 0) {
      writer.uint32(34).bytes(message.operatorIdentityPublicKey);
    }
    if (message.shouldUnfreeze !== false) {
      writer.uint32(40).bool(message.shouldUnfreeze);
    }
    return writer;
  },

  decode(
    input: BinaryReader | Uint8Array,
    length?: number,
  ): FreezeTokensPayload {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseFreezeTokensPayload();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.ownerPublicKey = reader.bytes();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.tokenPublicKey = reader.bytes();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.issuerProvidedTimestamp = longToNumber(reader.uint64());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.operatorIdentityPublicKey = reader.bytes();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.shouldUnfreeze = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): FreezeTokensPayload {
    return {
      ownerPublicKey: isSet(object.ownerPublicKey)
        ? bytesFromBase64(object.ownerPublicKey)
        : new Uint8Array(0),
      tokenPublicKey: isSet(object.tokenPublicKey)
        ? bytesFromBase64(object.tokenPublicKey)
        : new Uint8Array(0),
      issuerProvidedTimestamp: isSet(object.issuerProvidedTimestamp)
        ? globalThis.Number(object.issuerProvidedTimestamp)
        : 0,
      operatorIdentityPublicKey: isSet(object.operatorIdentityPublicKey)
        ? bytesFromBase64(object.operatorIdentityPublicKey)
        : new Uint8Array(0),
      shouldUnfreeze: isSet(object.shouldUnfreeze)
        ? globalThis.Boolean(object.shouldUnfreeze)
        : false,
    };
  },

  toJSON(message: FreezeTokensPayload): unknown {
    const obj: any = {};
    if (message.ownerPublicKey.length !== 0) {
      obj.ownerPublicKey = base64FromBytes(message.ownerPublicKey);
    }
    if (message.tokenPublicKey.length !== 0) {
      obj.tokenPublicKey = base64FromBytes(message.tokenPublicKey);
    }
    if (message.issuerProvidedTimestamp !== 0) {
      obj.issuerProvidedTimestamp = Math.round(message.issuerProvidedTimestamp);
    }
    if (message.operatorIdentityPublicKey.length !== 0) {
      obj.operatorIdentityPublicKey = base64FromBytes(
        message.operatorIdentityPublicKey,
      );
    }
    if (message.shouldUnfreeze !== false) {
      obj.shouldUnfreeze = message.shouldUnfreeze;
    }
    return obj;
  },

  create(base?: DeepPartial<FreezeTokensPayload>): FreezeTokensPayload {
    return FreezeTokensPayload.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<FreezeTokensPayload>): FreezeTokensPayload {
    const message = createBaseFreezeTokensPayload();
    message.ownerPublicKey = object.ownerPublicKey ?? new Uint8Array(0);
    message.tokenPublicKey = object.tokenPublicKey ?? new Uint8Array(0);
    message.issuerProvidedTimestamp = object.issuerProvidedTimestamp ?? 0;
    message.operatorIdentityPublicKey =
      object.operatorIdentityPublicKey ?? new Uint8Array(0);
    message.shouldUnfreeze = object.shouldUnfreeze ?? false;
    return message;
  },
};

function createBaseFreezeTokensRequest(): FreezeTokensRequest {
  return { freezeTokensPayload: undefined, issuerSignature: new Uint8Array(0) };
}

export const FreezeTokensRequest: MessageFns<FreezeTokensRequest> = {
  encode(
    message: FreezeTokensRequest,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.freezeTokensPayload !== undefined) {
      FreezeTokensPayload.encode(
        message.freezeTokensPayload,
        writer.uint32(10).fork(),
      ).join();
    }
    if (message.issuerSignature.length !== 0) {
      writer.uint32(18).bytes(message.issuerSignature);
    }
    return writer;
  },

  decode(
    input: BinaryReader | Uint8Array,
    length?: number,
  ): FreezeTokensRequest {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseFreezeTokensRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.freezeTokensPayload = FreezeTokensPayload.decode(
            reader,
            reader.uint32(),
          );
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.issuerSignature = reader.bytes();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): FreezeTokensRequest {
    return {
      freezeTokensPayload: isSet(object.freezeTokensPayload)
        ? FreezeTokensPayload.fromJSON(object.freezeTokensPayload)
        : undefined,
      issuerSignature: isSet(object.issuerSignature)
        ? bytesFromBase64(object.issuerSignature)
        : new Uint8Array(0),
    };
  },

  toJSON(message: FreezeTokensRequest): unknown {
    const obj: any = {};
    if (message.freezeTokensPayload !== undefined) {
      obj.freezeTokensPayload = FreezeTokensPayload.toJSON(
        message.freezeTokensPayload,
      );
    }
    if (message.issuerSignature.length !== 0) {
      obj.issuerSignature = base64FromBytes(message.issuerSignature);
    }
    return obj;
  },

  create(base?: DeepPartial<FreezeTokensRequest>): FreezeTokensRequest {
    return FreezeTokensRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<FreezeTokensRequest>): FreezeTokensRequest {
    const message = createBaseFreezeTokensRequest();
    message.freezeTokensPayload =
      object.freezeTokensPayload !== undefined &&
      object.freezeTokensPayload !== null
        ? FreezeTokensPayload.fromPartial(object.freezeTokensPayload)
        : undefined;
    message.issuerSignature = object.issuerSignature ?? new Uint8Array(0);
    return message;
  },
};

function createBaseFreezeTokensResponse(): FreezeTokensResponse {
  return { impactedOutputIds: [], impactedTokenAmount: new Uint8Array(0) };
}

export const FreezeTokensResponse: MessageFns<FreezeTokensResponse> = {
  encode(
    message: FreezeTokensResponse,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    for (const v of message.impactedOutputIds) {
      writer.uint32(10).string(v!);
    }
    if (message.impactedTokenAmount.length !== 0) {
      writer.uint32(18).bytes(message.impactedTokenAmount);
    }
    return writer;
  },

  decode(
    input: BinaryReader | Uint8Array,
    length?: number,
  ): FreezeTokensResponse {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseFreezeTokensResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.impactedOutputIds.push(reader.string());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.impactedTokenAmount = reader.bytes();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): FreezeTokensResponse {
    return {
      impactedOutputIds: globalThis.Array.isArray(object?.impactedOutputIds)
        ? object.impactedOutputIds.map((e: any) => globalThis.String(e))
        : [],
      impactedTokenAmount: isSet(object.impactedTokenAmount)
        ? bytesFromBase64(object.impactedTokenAmount)
        : new Uint8Array(0),
    };
  },

  toJSON(message: FreezeTokensResponse): unknown {
    const obj: any = {};
    if (message.impactedOutputIds?.length) {
      obj.impactedOutputIds = message.impactedOutputIds;
    }
    if (message.impactedTokenAmount.length !== 0) {
      obj.impactedTokenAmount = base64FromBytes(message.impactedTokenAmount);
    }
    return obj;
  },

  create(base?: DeepPartial<FreezeTokensResponse>): FreezeTokensResponse {
    return FreezeTokensResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<FreezeTokensResponse>): FreezeTokensResponse {
    const message = createBaseFreezeTokensResponse();
    message.impactedOutputIds = object.impactedOutputIds?.map((e) => e) || [];
    message.impactedTokenAmount =
      object.impactedTokenAmount ?? new Uint8Array(0);
    return message;
  },
};

function createBaseQueryTokenOutputsRequest(): QueryTokenOutputsRequest {
  return { ownerPublicKeys: [], tokenPublicKeys: [] };
}

export const QueryTokenOutputsRequest: MessageFns<QueryTokenOutputsRequest> = {
  encode(
    message: QueryTokenOutputsRequest,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    for (const v of message.ownerPublicKeys) {
      writer.uint32(10).bytes(v!);
    }
    for (const v of message.tokenPublicKeys) {
      writer.uint32(18).bytes(v!);
    }
    return writer;
  },

  decode(
    input: BinaryReader | Uint8Array,
    length?: number,
  ): QueryTokenOutputsRequest {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryTokenOutputsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.ownerPublicKeys.push(reader.bytes());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.tokenPublicKeys.push(reader.bytes());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): QueryTokenOutputsRequest {
    return {
      ownerPublicKeys: globalThis.Array.isArray(object?.ownerPublicKeys)
        ? object.ownerPublicKeys.map((e: any) => bytesFromBase64(e))
        : [],
      tokenPublicKeys: globalThis.Array.isArray(object?.tokenPublicKeys)
        ? object.tokenPublicKeys.map((e: any) => bytesFromBase64(e))
        : [],
    };
  },

  toJSON(message: QueryTokenOutputsRequest): unknown {
    const obj: any = {};
    if (message.ownerPublicKeys?.length) {
      obj.ownerPublicKeys = message.ownerPublicKeys.map((e) =>
        base64FromBytes(e),
      );
    }
    if (message.tokenPublicKeys?.length) {
      obj.tokenPublicKeys = message.tokenPublicKeys.map((e) =>
        base64FromBytes(e),
      );
    }
    return obj;
  },

  create(
    base?: DeepPartial<QueryTokenOutputsRequest>,
  ): QueryTokenOutputsRequest {
    return QueryTokenOutputsRequest.fromPartial(base ?? {});
  },
  fromPartial(
    object: DeepPartial<QueryTokenOutputsRequest>,
  ): QueryTokenOutputsRequest {
    const message = createBaseQueryTokenOutputsRequest();
    message.ownerPublicKeys = object.ownerPublicKeys?.map((e) => e) || [];
    message.tokenPublicKeys = object.tokenPublicKeys?.map((e) => e) || [];
    return message;
  },
};

function createBaseQueryTokenTransactionsRequest(): QueryTokenTransactionsRequest {
  return {
    outputIds: [],
    ownerPublicKeys: [],
    tokenPublicKeys: [],
    tokenTransactionHashes: [],
    limit: 0,
    offset: 0,
  };
}

export const QueryTokenTransactionsRequest: MessageFns<QueryTokenTransactionsRequest> =
  {
    encode(
      message: QueryTokenTransactionsRequest,
      writer: BinaryWriter = new BinaryWriter(),
    ): BinaryWriter {
      for (const v of message.outputIds) {
        writer.uint32(10).string(v!);
      }
      for (const v of message.ownerPublicKeys) {
        writer.uint32(18).bytes(v!);
      }
      for (const v of message.tokenPublicKeys) {
        writer.uint32(26).bytes(v!);
      }
      for (const v of message.tokenTransactionHashes) {
        writer.uint32(34).bytes(v!);
      }
      if (message.limit !== 0) {
        writer.uint32(40).int64(message.limit);
      }
      if (message.offset !== 0) {
        writer.uint32(48).int64(message.offset);
      }
      return writer;
    },

    decode(
      input: BinaryReader | Uint8Array,
      length?: number,
    ): QueryTokenTransactionsRequest {
      const reader =
        input instanceof BinaryReader ? input : new BinaryReader(input);
      let end = length === undefined ? reader.len : reader.pos + length;
      const message = createBaseQueryTokenTransactionsRequest();
      while (reader.pos < end) {
        const tag = reader.uint32();
        switch (tag >>> 3) {
          case 1: {
            if (tag !== 10) {
              break;
            }

            message.outputIds.push(reader.string());
            continue;
          }
          case 2: {
            if (tag !== 18) {
              break;
            }

            message.ownerPublicKeys.push(reader.bytes());
            continue;
          }
          case 3: {
            if (tag !== 26) {
              break;
            }

            message.tokenPublicKeys.push(reader.bytes());
            continue;
          }
          case 4: {
            if (tag !== 34) {
              break;
            }

            message.tokenTransactionHashes.push(reader.bytes());
            continue;
          }
          case 5: {
            if (tag !== 40) {
              break;
            }

            message.limit = longToNumber(reader.int64());
            continue;
          }
          case 6: {
            if (tag !== 48) {
              break;
            }

            message.offset = longToNumber(reader.int64());
            continue;
          }
        }
        if ((tag & 7) === 4 || tag === 0) {
          break;
        }
        reader.skip(tag & 7);
      }
      return message;
    },

    fromJSON(object: any): QueryTokenTransactionsRequest {
      return {
        outputIds: globalThis.Array.isArray(object?.outputIds)
          ? object.outputIds.map((e: any) => globalThis.String(e))
          : [],
        ownerPublicKeys: globalThis.Array.isArray(object?.ownerPublicKeys)
          ? object.ownerPublicKeys.map((e: any) => bytesFromBase64(e))
          : [],
        tokenPublicKeys: globalThis.Array.isArray(object?.tokenPublicKeys)
          ? object.tokenPublicKeys.map((e: any) => bytesFromBase64(e))
          : [],
        tokenTransactionHashes: globalThis.Array.isArray(
          object?.tokenTransactionHashes,
        )
          ? object.tokenTransactionHashes.map((e: any) => bytesFromBase64(e))
          : [],
        limit: isSet(object.limit) ? globalThis.Number(object.limit) : 0,
        offset: isSet(object.offset) ? globalThis.Number(object.offset) : 0,
      };
    },

    toJSON(message: QueryTokenTransactionsRequest): unknown {
      const obj: any = {};
      if (message.outputIds?.length) {
        obj.outputIds = message.outputIds;
      }
      if (message.ownerPublicKeys?.length) {
        obj.ownerPublicKeys = message.ownerPublicKeys.map((e) =>
          base64FromBytes(e),
        );
      }
      if (message.tokenPublicKeys?.length) {
        obj.tokenPublicKeys = message.tokenPublicKeys.map((e) =>
          base64FromBytes(e),
        );
      }
      if (message.tokenTransactionHashes?.length) {
        obj.tokenTransactionHashes = message.tokenTransactionHashes.map((e) =>
          base64FromBytes(e),
        );
      }
      if (message.limit !== 0) {
        obj.limit = Math.round(message.limit);
      }
      if (message.offset !== 0) {
        obj.offset = Math.round(message.offset);
      }
      return obj;
    },

    create(
      base?: DeepPartial<QueryTokenTransactionsRequest>,
    ): QueryTokenTransactionsRequest {
      return QueryTokenTransactionsRequest.fromPartial(base ?? {});
    },
    fromPartial(
      object: DeepPartial<QueryTokenTransactionsRequest>,
    ): QueryTokenTransactionsRequest {
      const message = createBaseQueryTokenTransactionsRequest();
      message.outputIds = object.outputIds?.map((e) => e) || [];
      message.ownerPublicKeys = object.ownerPublicKeys?.map((e) => e) || [];
      message.tokenPublicKeys = object.tokenPublicKeys?.map((e) => e) || [];
      message.tokenTransactionHashes =
        object.tokenTransactionHashes?.map((e) => e) || [];
      message.limit = object.limit ?? 0;
      message.offset = object.offset ?? 0;
      return message;
    },
  };

function createBaseQueryTokenTransactionsResponse(): QueryTokenTransactionsResponse {
  return { tokenTransactionsWithStatus: [], offset: 0 };
}

export const QueryTokenTransactionsResponse: MessageFns<QueryTokenTransactionsResponse> =
  {
    encode(
      message: QueryTokenTransactionsResponse,
      writer: BinaryWriter = new BinaryWriter(),
    ): BinaryWriter {
      for (const v of message.tokenTransactionsWithStatus) {
        TokenTransactionWithStatus.encode(v!, writer.uint32(10).fork()).join();
      }
      if (message.offset !== 0) {
        writer.uint32(16).int64(message.offset);
      }
      return writer;
    },

    decode(
      input: BinaryReader | Uint8Array,
      length?: number,
    ): QueryTokenTransactionsResponse {
      const reader =
        input instanceof BinaryReader ? input : new BinaryReader(input);
      let end = length === undefined ? reader.len : reader.pos + length;
      const message = createBaseQueryTokenTransactionsResponse();
      while (reader.pos < end) {
        const tag = reader.uint32();
        switch (tag >>> 3) {
          case 1: {
            if (tag !== 10) {
              break;
            }

            message.tokenTransactionsWithStatus.push(
              TokenTransactionWithStatus.decode(reader, reader.uint32()),
            );
            continue;
          }
          case 2: {
            if (tag !== 16) {
              break;
            }

            message.offset = longToNumber(reader.int64());
            continue;
          }
        }
        if ((tag & 7) === 4 || tag === 0) {
          break;
        }
        reader.skip(tag & 7);
      }
      return message;
    },

    fromJSON(object: any): QueryTokenTransactionsResponse {
      return {
        tokenTransactionsWithStatus: globalThis.Array.isArray(
          object?.tokenTransactionsWithStatus,
        )
          ? object.tokenTransactionsWithStatus.map((e: any) =>
              TokenTransactionWithStatus.fromJSON(e),
            )
          : [],
        offset: isSet(object.offset) ? globalThis.Number(object.offset) : 0,
      };
    },

    toJSON(message: QueryTokenTransactionsResponse): unknown {
      const obj: any = {};
      if (message.tokenTransactionsWithStatus?.length) {
        obj.tokenTransactionsWithStatus =
          message.tokenTransactionsWithStatus.map((e) =>
            TokenTransactionWithStatus.toJSON(e),
          );
      }
      if (message.offset !== 0) {
        obj.offset = Math.round(message.offset);
      }
      return obj;
    },

    create(
      base?: DeepPartial<QueryTokenTransactionsResponse>,
    ): QueryTokenTransactionsResponse {
      return QueryTokenTransactionsResponse.fromPartial(base ?? {});
    },
    fromPartial(
      object: DeepPartial<QueryTokenTransactionsResponse>,
    ): QueryTokenTransactionsResponse {
      const message = createBaseQueryTokenTransactionsResponse();
      message.tokenTransactionsWithStatus =
        object.tokenTransactionsWithStatus?.map((e) =>
          TokenTransactionWithStatus.fromPartial(e),
        ) || [];
      message.offset = object.offset ?? 0;
      return message;
    },
  };

function createBaseOutputWithPreviousTransactionData(): OutputWithPreviousTransactionData {
  return {
    output: undefined,
    previousTransactionHash: new Uint8Array(0),
    previousTransactionVout: 0,
  };
}

export const OutputWithPreviousTransactionData: MessageFns<OutputWithPreviousTransactionData> =
  {
    encode(
      message: OutputWithPreviousTransactionData,
      writer: BinaryWriter = new BinaryWriter(),
    ): BinaryWriter {
      if (message.output !== undefined) {
        TokenOutput.encode(message.output, writer.uint32(10).fork()).join();
      }
      if (message.previousTransactionHash.length !== 0) {
        writer.uint32(18).bytes(message.previousTransactionHash);
      }
      if (message.previousTransactionVout !== 0) {
        writer.uint32(24).uint32(message.previousTransactionVout);
      }
      return writer;
    },

    decode(
      input: BinaryReader | Uint8Array,
      length?: number,
    ): OutputWithPreviousTransactionData {
      const reader =
        input instanceof BinaryReader ? input : new BinaryReader(input);
      let end = length === undefined ? reader.len : reader.pos + length;
      const message = createBaseOutputWithPreviousTransactionData();
      while (reader.pos < end) {
        const tag = reader.uint32();
        switch (tag >>> 3) {
          case 1: {
            if (tag !== 10) {
              break;
            }

            message.output = TokenOutput.decode(reader, reader.uint32());
            continue;
          }
          case 2: {
            if (tag !== 18) {
              break;
            }

            message.previousTransactionHash = reader.bytes();
            continue;
          }
          case 3: {
            if (tag !== 24) {
              break;
            }

            message.previousTransactionVout = reader.uint32();
            continue;
          }
        }
        if ((tag & 7) === 4 || tag === 0) {
          break;
        }
        reader.skip(tag & 7);
      }
      return message;
    },

    fromJSON(object: any): OutputWithPreviousTransactionData {
      return {
        output: isSet(object.output)
          ? TokenOutput.fromJSON(object.output)
          : undefined,
        previousTransactionHash: isSet(object.previousTransactionHash)
          ? bytesFromBase64(object.previousTransactionHash)
          : new Uint8Array(0),
        previousTransactionVout: isSet(object.previousTransactionVout)
          ? globalThis.Number(object.previousTransactionVout)
          : 0,
      };
    },

    toJSON(message: OutputWithPreviousTransactionData): unknown {
      const obj: any = {};
      if (message.output !== undefined) {
        obj.output = TokenOutput.toJSON(message.output);
      }
      if (message.previousTransactionHash.length !== 0) {
        obj.previousTransactionHash = base64FromBytes(
          message.previousTransactionHash,
        );
      }
      if (message.previousTransactionVout !== 0) {
        obj.previousTransactionVout = Math.round(
          message.previousTransactionVout,
        );
      }
      return obj;
    },

    create(
      base?: DeepPartial<OutputWithPreviousTransactionData>,
    ): OutputWithPreviousTransactionData {
      return OutputWithPreviousTransactionData.fromPartial(base ?? {});
    },
    fromPartial(
      object: DeepPartial<OutputWithPreviousTransactionData>,
    ): OutputWithPreviousTransactionData {
      const message = createBaseOutputWithPreviousTransactionData();
      message.output =
        object.output !== undefined && object.output !== null
          ? TokenOutput.fromPartial(object.output)
          : undefined;
      message.previousTransactionHash =
        object.previousTransactionHash ?? new Uint8Array(0);
      message.previousTransactionVout = object.previousTransactionVout ?? 0;
      return message;
    },
  };

function createBaseQueryTokenOutputsResponse(): QueryTokenOutputsResponse {
  return { outputsWithPreviousTransactionData: [] };
}

export const QueryTokenOutputsResponse: MessageFns<QueryTokenOutputsResponse> =
  {
    encode(
      message: QueryTokenOutputsResponse,
      writer: BinaryWriter = new BinaryWriter(),
    ): BinaryWriter {
      for (const v of message.outputsWithPreviousTransactionData) {
        OutputWithPreviousTransactionData.encode(
          v!,
          writer.uint32(10).fork(),
        ).join();
      }
      return writer;
    },

    decode(
      input: BinaryReader | Uint8Array,
      length?: number,
    ): QueryTokenOutputsResponse {
      const reader =
        input instanceof BinaryReader ? input : new BinaryReader(input);
      let end = length === undefined ? reader.len : reader.pos + length;
      const message = createBaseQueryTokenOutputsResponse();
      while (reader.pos < end) {
        const tag = reader.uint32();
        switch (tag >>> 3) {
          case 1: {
            if (tag !== 10) {
              break;
            }

            message.outputsWithPreviousTransactionData.push(
              OutputWithPreviousTransactionData.decode(reader, reader.uint32()),
            );
            continue;
          }
        }
        if ((tag & 7) === 4 || tag === 0) {
          break;
        }
        reader.skip(tag & 7);
      }
      return message;
    },

    fromJSON(object: any): QueryTokenOutputsResponse {
      return {
        outputsWithPreviousTransactionData: globalThis.Array.isArray(
          object?.outputsWithPreviousTransactionData,
        )
          ? object.outputsWithPreviousTransactionData.map((e: any) =>
              OutputWithPreviousTransactionData.fromJSON(e),
            )
          : [],
      };
    },

    toJSON(message: QueryTokenOutputsResponse): unknown {
      const obj: any = {};
      if (message.outputsWithPreviousTransactionData?.length) {
        obj.outputsWithPreviousTransactionData =
          message.outputsWithPreviousTransactionData.map((e) =>
            OutputWithPreviousTransactionData.toJSON(e),
          );
      }
      return obj;
    },

    create(
      base?: DeepPartial<QueryTokenOutputsResponse>,
    ): QueryTokenOutputsResponse {
      return QueryTokenOutputsResponse.fromPartial(base ?? {});
    },
    fromPartial(
      object: DeepPartial<QueryTokenOutputsResponse>,
    ): QueryTokenOutputsResponse {
      const message = createBaseQueryTokenOutputsResponse();
      message.outputsWithPreviousTransactionData =
        object.outputsWithPreviousTransactionData?.map((e) =>
          OutputWithPreviousTransactionData.fromPartial(e),
        ) || [];
      return message;
    },
  };

function createBaseCancelSignedTokenTransactionRequest(): CancelSignedTokenTransactionRequest {
  return {
    finalTokenTransaction: undefined,
    senderIdentityPublicKey: new Uint8Array(0),
  };
}

export const CancelSignedTokenTransactionRequest: MessageFns<CancelSignedTokenTransactionRequest> =
  {
    encode(
      message: CancelSignedTokenTransactionRequest,
      writer: BinaryWriter = new BinaryWriter(),
    ): BinaryWriter {
      if (message.finalTokenTransaction !== undefined) {
        TokenTransaction.encode(
          message.finalTokenTransaction,
          writer.uint32(10).fork(),
        ).join();
      }
      if (message.senderIdentityPublicKey.length !== 0) {
        writer.uint32(18).bytes(message.senderIdentityPublicKey);
      }
      return writer;
    },

    decode(
      input: BinaryReader | Uint8Array,
      length?: number,
    ): CancelSignedTokenTransactionRequest {
      const reader =
        input instanceof BinaryReader ? input : new BinaryReader(input);
      let end = length === undefined ? reader.len : reader.pos + length;
      const message = createBaseCancelSignedTokenTransactionRequest();
      while (reader.pos < end) {
        const tag = reader.uint32();
        switch (tag >>> 3) {
          case 1: {
            if (tag !== 10) {
              break;
            }

            message.finalTokenTransaction = TokenTransaction.decode(
              reader,
              reader.uint32(),
            );
            continue;
          }
          case 2: {
            if (tag !== 18) {
              break;
            }

            message.senderIdentityPublicKey = reader.bytes();
            continue;
          }
        }
        if ((tag & 7) === 4 || tag === 0) {
          break;
        }
        reader.skip(tag & 7);
      }
      return message;
    },

    fromJSON(object: any): CancelSignedTokenTransactionRequest {
      return {
        finalTokenTransaction: isSet(object.finalTokenTransaction)
          ? TokenTransaction.fromJSON(object.finalTokenTransaction)
          : undefined,
        senderIdentityPublicKey: isSet(object.senderIdentityPublicKey)
          ? bytesFromBase64(object.senderIdentityPublicKey)
          : new Uint8Array(0),
      };
    },

    toJSON(message: CancelSignedTokenTransactionRequest): unknown {
      const obj: any = {};
      if (message.finalTokenTransaction !== undefined) {
        obj.finalTokenTransaction = TokenTransaction.toJSON(
          message.finalTokenTransaction,
        );
      }
      if (message.senderIdentityPublicKey.length !== 0) {
        obj.senderIdentityPublicKey = base64FromBytes(
          message.senderIdentityPublicKey,
        );
      }
      return obj;
    },

    create(
      base?: DeepPartial<CancelSignedTokenTransactionRequest>,
    ): CancelSignedTokenTransactionRequest {
      return CancelSignedTokenTransactionRequest.fromPartial(base ?? {});
    },
    fromPartial(
      object: DeepPartial<CancelSignedTokenTransactionRequest>,
    ): CancelSignedTokenTransactionRequest {
      const message = createBaseCancelSignedTokenTransactionRequest();
      message.finalTokenTransaction =
        object.finalTokenTransaction !== undefined &&
        object.finalTokenTransaction !== null
          ? TokenTransaction.fromPartial(object.finalTokenTransaction)
          : undefined;
      message.senderIdentityPublicKey =
        object.senderIdentityPublicKey ?? new Uint8Array(0);
      return message;
    },
  };

function createBaseTreeNode(): TreeNode {
  return {
    id: "",
    treeId: "",
    value: 0,
    parentNodeId: undefined,
    nodeTx: new Uint8Array(0),
    refundTx: new Uint8Array(0),
    vout: 0,
    verifyingPublicKey: new Uint8Array(0),
    ownerIdentityPublicKey: new Uint8Array(0),
    signingKeyshare: undefined,
    status: "",
    network: 0,
  };
}

export const TreeNode: MessageFns<TreeNode> = {
  encode(
    message: TreeNode,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.treeId !== "") {
      writer.uint32(18).string(message.treeId);
    }
    if (message.value !== 0) {
      writer.uint32(24).uint64(message.value);
    }
    if (message.parentNodeId !== undefined) {
      writer.uint32(34).string(message.parentNodeId);
    }
    if (message.nodeTx.length !== 0) {
      writer.uint32(42).bytes(message.nodeTx);
    }
    if (message.refundTx.length !== 0) {
      writer.uint32(50).bytes(message.refundTx);
    }
    if (message.vout !== 0) {
      writer.uint32(56).uint32(message.vout);
    }
    if (message.verifyingPublicKey.length !== 0) {
      writer.uint32(66).bytes(message.verifyingPublicKey);
    }
    if (message.ownerIdentityPublicKey.length !== 0) {
      writer.uint32(74).bytes(message.ownerIdentityPublicKey);
    }
    if (message.signingKeyshare !== undefined) {
      SigningKeyshare.encode(
        message.signingKeyshare,
        writer.uint32(82).fork(),
      ).join();
    }
    if (message.status !== "") {
      writer.uint32(90).string(message.status);
    }
    if (message.network !== 0) {
      writer.uint32(96).int32(message.network);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TreeNode {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTreeNode();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.treeId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.value = longToNumber(reader.uint64());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.parentNodeId = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.nodeTx = reader.bytes();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.refundTx = reader.bytes();
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }

          message.vout = reader.uint32();
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.verifyingPublicKey = reader.bytes();
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.ownerIdentityPublicKey = reader.bytes();
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          message.signingKeyshare = SigningKeyshare.decode(
            reader,
            reader.uint32(),
          );
          continue;
        }
        case 11: {
          if (tag !== 90) {
            break;
          }

          message.status = reader.string();
          continue;
        }
        case 12: {
          if (tag !== 96) {
            break;
          }

          message.network = reader.int32() as any;
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TreeNode {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      treeId: isSet(object.treeId) ? globalThis.String(object.treeId) : "",
      value: isSet(object.value) ? globalThis.Number(object.value) : 0,
      parentNodeId: isSet(object.parentNodeId)
        ? globalThis.String(object.parentNodeId)
        : undefined,
      nodeTx: isSet(object.nodeTx)
        ? bytesFromBase64(object.nodeTx)
        : new Uint8Array(0),
      refundTx: isSet(object.refundTx)
        ? bytesFromBase64(object.refundTx)
        : new Uint8Array(0),
      vout: isSet(object.vout) ? globalThis.Number(object.vout) : 0,
      verifyingPublicKey: isSet(object.verifyingPublicKey)
        ? bytesFromBase64(object.verifyingPublicKey)
        : new Uint8Array(0),
      ownerIdentityPublicKey: isSet(object.ownerIdentityPublicKey)
        ? bytesFromBase64(object.ownerIdentityPublicKey)
        : new Uint8Array(0),
      signingKeyshare: isSet(object.signingKeyshare)
        ? SigningKeyshare.fromJSON(object.signingKeyshare)
        : undefined,
      status: isSet(object.status) ? globalThis.String(object.status) : "",
      network: isSet(object.network) ? networkFromJSON(object.network) : 0,
    };
  },

  toJSON(message: TreeNode): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.treeId !== "") {
      obj.treeId = message.treeId;
    }
    if (message.value !== 0) {
      obj.value = Math.round(message.value);
    }
    if (message.parentNodeId !== undefined) {
      obj.parentNodeId = message.parentNodeId;
    }
    if (message.nodeTx.length !== 0) {
      obj.nodeTx = base64FromBytes(message.nodeTx);
    }
    if (message.refundTx.length !== 0) {
      obj.refundTx = base64FromBytes(message.refundTx);
    }
    if (message.vout !== 0) {
      obj.vout = Math.round(message.vout);
    }
    if (message.verifyingPublicKey.length !== 0) {
      obj.verifyingPublicKey = base64FromBytes(message.verifyingPublicKey);
    }
    if (message.ownerIdentityPublicKey.length !== 0) {
      obj.ownerIdentityPublicKey = base64FromBytes(
        message.ownerIdentityPublicKey,
      );
    }
    if (message.signingKeyshare !== undefined) {
      obj.signingKeyshare = SigningKeyshare.toJSON(message.signingKeyshare);
    }
    if (message.status !== "") {
      obj.status = message.status;
    }
    if (message.network !== 0) {
      obj.network = networkToJSON(message.network);
    }
    return obj;
  },

  create(base?: DeepPartial<TreeNode>): TreeNode {
    return TreeNode.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<TreeNode>): TreeNode {
    const message = createBaseTreeNode();
    message.id = object.id ?? "";
    message.treeId = object.treeId ?? "";
    message.value = object.value ?? 0;
    message.parentNodeId = object.parentNodeId ?? undefined;
    message.nodeTx = object.nodeTx ?? new Uint8Array(0);
    message.refundTx = object.refundTx ?? new Uint8Array(0);
    message.vout = object.vout ?? 0;
    message.verifyingPublicKey = object.verifyingPublicKey ?? new Uint8Array(0);
    message.ownerIdentityPublicKey =
      object.ownerIdentityPublicKey ?? new Uint8Array(0);
    message.signingKeyshare =
      object.signingKeyshare !== undefined && object.signingKeyshare !== null
        ? SigningKeyshare.fromPartial(object.signingKeyshare)
        : undefined;
    message.status = object.status ?? "";
    message.network = object.network ?? 0;
    return message;
  },
};

function createBaseFinalizeNodeSignaturesRequest(): FinalizeNodeSignaturesRequest {
  return { intent: 0, nodeSignatures: [] };
}

export const FinalizeNodeSignaturesRequest: MessageFns<FinalizeNodeSignaturesRequest> =
  {
    encode(
      message: FinalizeNodeSignaturesRequest,
      writer: BinaryWriter = new BinaryWriter(),
    ): BinaryWriter {
      if (message.intent !== 0) {
        writer.uint32(8).int32(message.intent);
      }
      for (const v of message.nodeSignatures) {
        NodeSignatures.encode(v!, writer.uint32(18).fork()).join();
      }
      return writer;
    },

    decode(
      input: BinaryReader | Uint8Array,
      length?: number,
    ): FinalizeNodeSignaturesRequest {
      const reader =
        input instanceof BinaryReader ? input : new BinaryReader(input);
      let end = length === undefined ? reader.len : reader.pos + length;
      const message = createBaseFinalizeNodeSignaturesRequest();
      while (reader.pos < end) {
        const tag = reader.uint32();
        switch (tag >>> 3) {
          case 1: {
            if (tag !== 8) {
              break;
            }

            message.intent = reader.int32() as any;
            continue;
          }
          case 2: {
            if (tag !== 18) {
              break;
            }

            message.nodeSignatures.push(
              NodeSignatures.decode(reader, reader.uint32()),
            );
            continue;
          }
        }
        if ((tag & 7) === 4 || tag === 0) {
          break;
        }
        reader.skip(tag & 7);
      }
      return message;
    },

    fromJSON(object: any): FinalizeNodeSignaturesRequest {
      return {
        intent: isSet(object.intent)
          ? signatureIntentFromJSON(object.intent)
          : 0,
        nodeSignatures: globalThis.Array.isArray(object?.nodeSignatures)
          ? object.nodeSignatures.map((e: any) => NodeSignatures.fromJSON(e))
          : [],
      };
    },

    toJSON(message: FinalizeNodeSignaturesRequest): unknown {
      const obj: any = {};
      if (message.intent !== 0) {
        obj.intent = signatureIntentToJSON(message.intent);
      }
      if (message.nodeSignatures?.length) {
        obj.nodeSignatures = message.nodeSignatures.map((e) =>
          NodeSignatures.toJSON(e),
        );
      }
      return obj;
    },

    create(
      base?: DeepPartial<FinalizeNodeSignaturesRequest>,
    ): FinalizeNodeSignaturesRequest {
      return FinalizeNodeSignaturesRequest.fromPartial(base ?? {});
    },
    fromPartial(
      object: DeepPartial<FinalizeNodeSignaturesRequest>,
    ): FinalizeNodeSignaturesRequest {
      const message = createBaseFinalizeNodeSignaturesRequest();
      message.intent = object.intent ?? 0;
      message.nodeSignatures =
        object.nodeSignatures?.map((e) => NodeSignatures.fromPartial(e)) || [];
      return message;
    },
  };

function createBaseFinalizeNodeSignaturesResponse(): FinalizeNodeSignaturesResponse {
  return { nodes: [] };
}

export const FinalizeNodeSignaturesResponse: MessageFns<FinalizeNodeSignaturesResponse> =
  {
    encode(
      message: FinalizeNodeSignaturesResponse,
      writer: BinaryWriter = new BinaryWriter(),
    ): BinaryWriter {
      for (const v of message.nodes) {
        TreeNode.encode(v!, writer.uint32(10).fork()).join();
      }
      return writer;
    },

    decode(
      input: BinaryReader | Uint8Array,
      length?: number,
    ): FinalizeNodeSignaturesResponse {
      const reader =
        input instanceof BinaryReader ? input : new BinaryReader(input);
      let end = length === undefined ? reader.len : reader.pos + length;
      const message = createBaseFinalizeNodeSignaturesResponse();
      while (reader.pos < end) {
        const tag = reader.uint32();
        switch (tag >>> 3) {
          case 1: {
            if (tag !== 10) {
              break;
            }

            message.nodes.push(TreeNode.decode(reader, reader.uint32()));
            continue;
          }
        }
        if ((tag & 7) === 4 || tag === 0) {
          break;
        }
        reader.skip(tag & 7);
      }
      return message;
    },

    fromJSON(object: any): FinalizeNodeSignaturesResponse {
      return {
        nodes: globalThis.Array.isArray(object?.nodes)
          ? object.nodes.map((e: any) => TreeNode.fromJSON(e))
          : [],
      };
    },

    toJSON(message: FinalizeNodeSignaturesResponse): unknown {
      const obj: any = {};
      if (message.nodes?.length) {
        obj.nodes = message.nodes.map((e) => TreeNode.toJSON(e));
      }
      return obj;
    },

    create(
      base?: DeepPartial<FinalizeNodeSignaturesResponse>,
    ): FinalizeNodeSignaturesResponse {
      return FinalizeNodeSignaturesResponse.fromPartial(base ?? {});
    },
    fromPartial(
      object: DeepPartial<FinalizeNodeSignaturesResponse>,
    ): FinalizeNodeSignaturesResponse {
      const message = createBaseFinalizeNodeSignaturesResponse();
      message.nodes = object.nodes?.map((e) => TreeNode.fromPartial(e)) || [];
      return message;
    },
  };

function createBaseSecretShare(): SecretShare {
  return { secretShare: new Uint8Array(0), proofs: [] };
}

export const SecretShare: MessageFns<SecretShare> = {
  encode(
    message: SecretShare,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.secretShare.length !== 0) {
      writer.uint32(10).bytes(message.secretShare);
    }
    for (const v of message.proofs) {
      writer.uint32(18).bytes(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SecretShare {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSecretShare();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.secretShare = reader.bytes();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.proofs.push(reader.bytes());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SecretShare {
    return {
      secretShare: isSet(object.secretShare)
        ? bytesFromBase64(object.secretShare)
        : new Uint8Array(0),
      proofs: globalThis.Array.isArray(object?.proofs)
        ? object.proofs.map((e: any) => bytesFromBase64(e))
        : [],
    };
  },

  toJSON(message: SecretShare): unknown {
    const obj: any = {};
    if (message.secretShare.length !== 0) {
      obj.secretShare = base64FromBytes(message.secretShare);
    }
    if (message.proofs?.length) {
      obj.proofs = message.proofs.map((e) => base64FromBytes(e));
    }
    return obj;
  },

  create(base?: DeepPartial<SecretShare>): SecretShare {
    return SecretShare.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<SecretShare>): SecretShare {
    const message = createBaseSecretShare();
    message.secretShare = object.secretShare ?? new Uint8Array(0);
    message.proofs = object.proofs?.map((e) => e) || [];
    return message;
  },
};

function createBaseSecretProof(): SecretProof {
  return { proofs: [] };
}

export const SecretProof: MessageFns<SecretProof> = {
  encode(
    message: SecretProof,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    for (const v of message.proofs) {
      writer.uint32(10).bytes(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SecretProof {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSecretProof();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.proofs.push(reader.bytes());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SecretProof {
    return {
      proofs: globalThis.Array.isArray(object?.proofs)
        ? object.proofs.map((e: any) => bytesFromBase64(e))
        : [],
    };
  },

  toJSON(message: SecretProof): unknown {
    const obj: any = {};
    if (message.proofs?.length) {
      obj.proofs = message.proofs.map((e) => base64FromBytes(e));
    }
    return obj;
  },

  create(base?: DeepPartial<SecretProof>): SecretProof {
    return SecretProof.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<SecretProof>): SecretProof {
    const message = createBaseSecretProof();
    message.proofs = object.proofs?.map((e) => e) || [];
    return message;
  },
};

function createBaseLeafRefundTxSigningJob(): LeafRefundTxSigningJob {
  return { leafId: "", refundTxSigningJob: undefined };
}

export const LeafRefundTxSigningJob: MessageFns<LeafRefundTxSigningJob> = {
  encode(
    message: LeafRefundTxSigningJob,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.leafId !== "") {
      writer.uint32(10).string(message.leafId);
    }
    if (message.refundTxSigningJob !== undefined) {
      SigningJob.encode(
        message.refundTxSigningJob,
        writer.uint32(18).fork(),
      ).join();
    }
    return writer;
  },

  decode(
    input: BinaryReader | Uint8Array,
    length?: number,
  ): LeafRefundTxSigningJob {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseLeafRefundTxSigningJob();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.leafId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.refundTxSigningJob = SigningJob.decode(
            reader,
            reader.uint32(),
          );
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): LeafRefundTxSigningJob {
    return {
      leafId: isSet(object.leafId) ? globalThis.String(object.leafId) : "",
      refundTxSigningJob: isSet(object.refundTxSigningJob)
        ? SigningJob.fromJSON(object.refundTxSigningJob)
        : undefined,
    };
  },

  toJSON(message: LeafRefundTxSigningJob): unknown {
    const obj: any = {};
    if (message.leafId !== "") {
      obj.leafId = message.leafId;
    }
    if (message.refundTxSigningJob !== undefined) {
      obj.refundTxSigningJob = SigningJob.toJSON(message.refundTxSigningJob);
    }
    return obj;
  },

  create(base?: DeepPartial<LeafRefundTxSigningJob>): LeafRefundTxSigningJob {
    return LeafRefundTxSigningJob.fromPartial(base ?? {});
  },
  fromPartial(
    object: DeepPartial<LeafRefundTxSigningJob>,
  ): LeafRefundTxSigningJob {
    const message = createBaseLeafRefundTxSigningJob();
    message.leafId = object.leafId ?? "";
    message.refundTxSigningJob =
      object.refundTxSigningJob !== undefined &&
      object.refundTxSigningJob !== null
        ? SigningJob.fromPartial(object.refundTxSigningJob)
        : undefined;
    return message;
  },
};

function createBaseUserSignedTxSigningJob(): UserSignedTxSigningJob {
  return {
    leafId: "",
    signingPublicKey: new Uint8Array(0),
    rawTx: new Uint8Array(0),
    signingNonceCommitment: undefined,
    userSignature: new Uint8Array(0),
    signingCommitments: undefined,
  };
}

export const UserSignedTxSigningJob: MessageFns<UserSignedTxSigningJob> = {
  encode(
    message: UserSignedTxSigningJob,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.leafId !== "") {
      writer.uint32(10).string(message.leafId);
    }
    if (message.signingPublicKey.length !== 0) {
      writer.uint32(18).bytes(message.signingPublicKey);
    }
    if (message.rawTx.length !== 0) {
      writer.uint32(26).bytes(message.rawTx);
    }
    if (message.signingNonceCommitment !== undefined) {
      SigningCommitment.encode(
        message.signingNonceCommitment,
        writer.uint32(34).fork(),
      ).join();
    }
    if (message.userSignature.length !== 0) {
      writer.uint32(42).bytes(message.userSignature);
    }
    if (message.signingCommitments !== undefined) {
      SigningCommitments.encode(
        message.signingCommitments,
        writer.uint32(50).fork(),
      ).join();
    }
    return writer;
  },

  decode(
    input: BinaryReader | Uint8Array,
    length?: number,
  ): UserSignedTxSigningJob {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUserSignedTxSigningJob();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.leafId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.signingPublicKey = reader.bytes();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.rawTx = reader.bytes();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.signingNonceCommitment = SigningCommitment.decode(
            reader,
            reader.uint32(),
          );
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.userSignature = reader.bytes();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.signingCommitments = SigningCommitments.decode(
            reader,
            reader.uint32(),
          );
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UserSignedTxSigningJob {
    return {
      leafId: isSet(object.leafId) ? globalThis.String(object.leafId) : "",
      signingPublicKey: isSet(object.signingPublicKey)
        ? bytesFromBase64(object.signingPublicKey)
        : new Uint8Array(0),
      rawTx: isSet(object.rawTx)
        ? bytesFromBase64(object.rawTx)
        : new Uint8Array(0),
      signingNonceCommitment: isSet(object.signingNonceCommitment)
        ? SigningCommitment.fromJSON(object.signingNonceCommitment)
        : undefined,
      userSignature: isSet(object.userSignature)
        ? bytesFromBase64(object.userSignature)
        : new Uint8Array(0),
      signingCommitments: isSet(object.signingCommitments)
        ? SigningCommitments.fromJSON(object.signingCommitments)
        : undefined,
    };
  },

  toJSON(message: UserSignedTxSigningJob): unknown {
    const obj: any = {};
    if (message.leafId !== "") {
      obj.leafId = message.leafId;
    }
    if (message.signingPublicKey.length !== 0) {
      obj.signingPublicKey = base64FromBytes(message.signingPublicKey);
    }
    if (message.rawTx.length !== 0) {
      obj.rawTx = base64FromBytes(message.rawTx);
    }
    if (message.signingNonceCommitment !== undefined) {
      obj.signingNonceCommitment = SigningCommitment.toJSON(
        message.signingNonceCommitment,
      );
    }
    if (message.userSignature.length !== 0) {
      obj.userSignature = base64FromBytes(message.userSignature);
    }
    if (message.signingCommitments !== undefined) {
      obj.signingCommitments = SigningCommitments.toJSON(
        message.signingCommitments,
      );
    }
    return obj;
  },

  create(base?: DeepPartial<UserSignedTxSigningJob>): UserSignedTxSigningJob {
    return UserSignedTxSigningJob.fromPartial(base ?? {});
  },
  fromPartial(
    object: DeepPartial<UserSignedTxSigningJob>,
  ): UserSignedTxSigningJob {
    const message = createBaseUserSignedTxSigningJob();
    message.leafId = object.leafId ?? "";
    message.signingPublicKey = object.signingPublicKey ?? new Uint8Array(0);
    message.rawTx = object.rawTx ?? new Uint8Array(0);
    message.signingNonceCommitment =
      object.signingNonceCommitment !== undefined &&
      object.signingNonceCommitment !== null
        ? SigningCommitment.fromPartial(object.signingNonceCommitment)
        : undefined;
    message.userSignature = object.userSignature ?? new Uint8Array(0);
    message.signingCommitments =
      object.signingCommitments !== undefined &&
      object.signingCommitments !== null
        ? SigningCommitments.fromPartial(object.signingCommitments)
        : undefined;
    return message;
  },
};

function createBaseLeafRefundTxSigningResult(): LeafRefundTxSigningResult {
  return {
    leafId: "",
    refundTxSigningResult: undefined,
    verifyingKey: new Uint8Array(0),
  };
}

export const LeafRefundTxSigningResult: MessageFns<LeafRefundTxSigningResult> =
  {
    encode(
      message: LeafRefundTxSigningResult,
      writer: BinaryWriter = new BinaryWriter(),
    ): BinaryWriter {
      if (message.leafId !== "") {
        writer.uint32(10).string(message.leafId);
      }
      if (message.refundTxSigningResult !== undefined) {
        SigningResult.encode(
          message.refundTxSigningResult,
          writer.uint32(18).fork(),
        ).join();
      }
      if (message.verifyingKey.length !== 0) {
        writer.uint32(26).bytes(message.verifyingKey);
      }
      return writer;
    },

    decode(
      input: BinaryReader | Uint8Array,
      length?: number,
    ): LeafRefundTxSigningResult {
      const reader =
        input instanceof BinaryReader ? input : new BinaryReader(input);
      let end = length === undefined ? reader.len : reader.pos + length;
      const message = createBaseLeafRefundTxSigningResult();
      while (reader.pos < end) {
        const tag = reader.uint32();
        switch (tag >>> 3) {
          case 1: {
            if (tag !== 10) {
              break;
            }

            message.leafId = reader.string();
            continue;
          }
          case 2: {
            if (tag !== 18) {
              break;
            }

            message.refundTxSigningResult = SigningResult.decode(
              reader,
              reader.uint32(),
            );
            continue;
          }
          case 3: {
            if (tag !== 26) {
              break;
            }

            message.verifyingKey = reader.bytes();
            continue;
          }
        }
        if ((tag & 7) === 4 || tag === 0) {
          break;
        }
        reader.skip(tag & 7);
      }
      return message;
    },

    fromJSON(object: any): LeafRefundTxSigningResult {
      return {
        leafId: isSet(object.leafId) ? globalThis.String(object.leafId) : "",
        refundTxSigningResult: isSet(object.refundTxSigningResult)
          ? SigningResult.fromJSON(object.refundTxSigningResult)
          : undefined,
        verifyingKey: isSet(object.verifyingKey)
          ? bytesFromBase64(object.verifyingKey)
          : new Uint8Array(0),
      };
    },

    toJSON(message: LeafRefundTxSigningResult): unknown {
      const obj: any = {};
      if (message.leafId !== "") {
        obj.leafId = message.leafId;
      }
      if (message.refundTxSigningResult !== undefined) {
        obj.refundTxSigningResult = SigningResult.toJSON(
          message.refundTxSigningResult,
        );
      }
      if (message.verifyingKey.length !== 0) {
        obj.verifyingKey = base64FromBytes(message.verifyingKey);
      }
      return obj;
    },

    create(
      base?: DeepPartial<LeafRefundTxSigningResult>,
    ): LeafRefundTxSigningResult {
      return LeafRefundTxSigningResult.fromPartial(base ?? {});
    },
    fromPartial(
      object: DeepPartial<LeafRefundTxSigningResult>,
    ): LeafRefundTxSigningResult {
      const message = createBaseLeafRefundTxSigningResult();
      message.leafId = object.leafId ?? "";
      message.refundTxSigningResult =
        object.refundTxSigningResult !== undefined &&
        object.refundTxSigningResult !== null
          ? SigningResult.fromPartial(object.refundTxSigningResult)
          : undefined;
      message.verifyingKey = object.verifyingKey ?? new Uint8Array(0);
      return message;
    },
  };

function createBaseStartUserSignedTransferRequest(): StartUserSignedTransferRequest {
  return {
    transferId: "",
    ownerIdentityPublicKey: new Uint8Array(0),
    leavesToSend: [],
    receiverIdentityPublicKey: new Uint8Array(0),
    expiryTime: undefined,
  };
}

export const StartUserSignedTransferRequest: MessageFns<StartUserSignedTransferRequest> =
  {
    encode(
      message: StartUserSignedTransferRequest,
      writer: BinaryWriter = new BinaryWriter(),
    ): BinaryWriter {
      if (message.transferId !== "") {
        writer.uint32(10).string(message.transferId);
      }
      if (message.ownerIdentityPublicKey.length !== 0) {
        writer.uint32(18).bytes(message.ownerIdentityPublicKey);
      }
      for (const v of message.leavesToSend) {
        UserSignedTxSigningJob.encode(v!, writer.uint32(26).fork()).join();
      }
      if (message.receiverIdentityPublicKey.length !== 0) {
        writer.uint32(34).bytes(message.receiverIdentityPublicKey);
      }
      if (message.expiryTime !== undefined) {
        Timestamp.encode(
          toTimestamp(message.expiryTime),
          writer.uint32(42).fork(),
        ).join();
      }
      return writer;
    },

    decode(
      input: BinaryReader | Uint8Array,
      length?: number,
    ): StartUserSignedTransferRequest {
      const reader =
        input instanceof BinaryReader ? input : new BinaryReader(input);
      let end = length === undefined ? reader.len : reader.pos + length;
      const message = createBaseStartUserSignedTransferRequest();
      while (reader.pos < end) {
        const tag = reader.uint32();
        switch (tag >>> 3) {
          case 1: {
            if (tag !== 10) {
              break;
            }

            message.transferId = reader.string();
            continue;
          }
          case 2: {
            if (tag !== 18) {
              break;
            }

            message.ownerIdentityPublicKey = reader.bytes();
            continue;
          }
          case 3: {
            if (tag !== 26) {
              break;
            }

            message.leavesToSend.push(
              UserSignedTxSigningJob.decode(reader, reader.uint32()),
            );
            continue;
          }
          case 4: {
            if (tag !== 34) {
              break;
            }

            message.receiverIdentityPublicKey = reader.bytes();
            continue;
          }
          case 5: {
            if (tag !== 42) {
              break;
            }

            message.expiryTime = fromTimestamp(
              Timestamp.decode(reader, reader.uint32()),
            );
            continue;
          }
        }
        if ((tag & 7) === 4 || tag === 0) {
          break;
        }
        reader.skip(tag & 7);
      }
      return message;
    },

    fromJSON(object: any): StartUserSignedTransferRequest {
      return {
        transferId: isSet(object.transferId)
          ? globalThis.String(object.transferId)
          : "",
        ownerIdentityPublicKey: isSet(object.ownerIdentityPublicKey)
          ? bytesFromBase64(object.ownerIdentityPublicKey)
          : new Uint8Array(0),
        leavesToSend: globalThis.Array.isArray(object?.leavesToSend)
          ? object.leavesToSend.map((e: any) =>
              UserSignedTxSigningJob.fromJSON(e),
            )
          : [],
        receiverIdentityPublicKey: isSet(object.receiverIdentityPublicKey)
          ? bytesFromBase64(object.receiverIdentityPublicKey)
          : new Uint8Array(0),
        expiryTime: isSet(object.expiryTime)
          ? fromJsonTimestamp(object.expiryTime)
          : undefined,
      };
    },

    toJSON(message: StartUserSignedTransferRequest): unknown {
      const obj: any = {};
      if (message.transferId !== "") {
        obj.transferId = message.transferId;
      }
      if (message.ownerIdentityPublicKey.length !== 0) {
        obj.ownerIdentityPublicKey = base64FromBytes(
          message.ownerIdentityPublicKey,
        );
      }
      if (message.leavesToSend?.length) {
        obj.leavesToSend = message.leavesToSend.map((e) =>
          UserSignedTxSigningJob.toJSON(e),
        );
      }
      if (message.receiverIdentityPublicKey.length !== 0) {
        obj.receiverIdentityPublicKey = base64FromBytes(
          message.receiverIdentityPublicKey,
        );
      }
      if (message.expiryTime !== undefined) {
        obj.expiryTime = message.expiryTime.toISOString();
      }
      return obj;
    },

    create(
      base?: DeepPartial<StartUserSignedTransferRequest>,
    ): StartUserSignedTransferRequest {
      return StartUserSignedTransferRequest.fromPartial(base ?? {});
    },
    fromPartial(
      object: DeepPartial<StartUserSignedTransferRequest>,
    ): StartUserSignedTransferRequest {
      const message = createBaseStartUserSignedTransferRequest();
      message.transferId = object.transferId ?? "";
      message.ownerIdentityPublicKey =
        object.ownerIdentityPublicKey ?? new Uint8Array(0);
      message.leavesToSend =
        object.leavesToSend?.map((e) =>
          UserSignedTxSigningJob.fromPartial(e),
        ) || [];
      message.receiverIdentityPublicKey =
        object.receiverIdentityPublicKey ?? new Uint8Array(0);
      message.expiryTime = object.expiryTime ?? undefined;
      return message;
    },
  };

function createBaseStartTransferRequest(): StartTransferRequest {
  return {
    transferId: "",
    ownerIdentityPublicKey: new Uint8Array(0),
    leavesToSend: [],
    receiverIdentityPublicKey: new Uint8Array(0),
    expiryTime: undefined,
    keyTweakProofs: {},
  };
}

export const StartTransferRequest: MessageFns<StartTransferRequest> = {
  encode(
    message: StartTransferRequest,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.transferId !== "") {
      writer.uint32(10).string(message.transferId);
    }
    if (message.ownerIdentityPublicKey.length !== 0) {
      writer.uint32(18).bytes(message.ownerIdentityPublicKey);
    }
    for (const v of message.leavesToSend) {
      LeafRefundTxSigningJob.encode(v!, writer.uint32(26).fork()).join();
    }
    if (message.receiverIdentityPublicKey.length !== 0) {
      writer.uint32(34).bytes(message.receiverIdentityPublicKey);
    }
    if (message.expiryTime !== undefined) {
      Timestamp.encode(
        toTimestamp(message.expiryTime),
        writer.uint32(42).fork(),
      ).join();
    }
    Object.entries(message.keyTweakProofs).forEach(([key, value]) => {
      StartTransferRequest_KeyTweakProofsEntry.encode(
        { key: key as any, value },
        writer.uint32(50).fork(),
      ).join();
    });
    return writer;
  },

  decode(
    input: BinaryReader | Uint8Array,
    length?: number,
  ): StartTransferRequest {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseStartTransferRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.transferId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.ownerIdentityPublicKey = reader.bytes();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.leavesToSend.push(
            LeafRefundTxSigningJob.decode(reader, reader.uint32()),
          );
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.receiverIdentityPublicKey = reader.bytes();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.expiryTime = fromTimestamp(
            Timestamp.decode(reader, reader.uint32()),
          );
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          const entry6 = StartTransferRequest_KeyTweakProofsEntry.decode(
            reader,
            reader.uint32(),
          );
          if (entry6.value !== undefined) {
            message.keyTweakProofs[entry6.key] = entry6.value;
          }
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): StartTransferRequest {
    return {
      transferId: isSet(object.transferId)
        ? globalThis.String(object.transferId)
        : "",
      ownerIdentityPublicKey: isSet(object.ownerIdentityPublicKey)
        ? bytesFromBase64(object.ownerIdentityPublicKey)
        : new Uint8Array(0),
      leavesToSend: globalThis.Array.isArray(object?.leavesToSend)
        ? object.leavesToSend.map((e: any) =>
            LeafRefundTxSigningJob.fromJSON(e),
          )
        : [],
      receiverIdentityPublicKey: isSet(object.receiverIdentityPublicKey)
        ? bytesFromBase64(object.receiverIdentityPublicKey)
        : new Uint8Array(0),
      expiryTime: isSet(object.expiryTime)
        ? fromJsonTimestamp(object.expiryTime)
        : undefined,
      keyTweakProofs: isObject(object.keyTweakProofs)
        ? Object.entries(object.keyTweakProofs).reduce<{
            [key: string]: SecretProof;
          }>((acc, [key, value]) => {
            acc[key] = SecretProof.fromJSON(value);
            return acc;
          }, {})
        : {},
    };
  },

  toJSON(message: StartTransferRequest): unknown {
    const obj: any = {};
    if (message.transferId !== "") {
      obj.transferId = message.transferId;
    }
    if (message.ownerIdentityPublicKey.length !== 0) {
      obj.ownerIdentityPublicKey = base64FromBytes(
        message.ownerIdentityPublicKey,
      );
    }
    if (message.leavesToSend?.length) {
      obj.leavesToSend = message.leavesToSend.map((e) =>
        LeafRefundTxSigningJob.toJSON(e),
      );
    }
    if (message.receiverIdentityPublicKey.length !== 0) {
      obj.receiverIdentityPublicKey = base64FromBytes(
        message.receiverIdentityPublicKey,
      );
    }
    if (message.expiryTime !== undefined) {
      obj.expiryTime = message.expiryTime.toISOString();
    }
    if (message.keyTweakProofs) {
      const entries = Object.entries(message.keyTweakProofs);
      if (entries.length > 0) {
        obj.keyTweakProofs = {};
        entries.forEach(([k, v]) => {
          obj.keyTweakProofs[k] = SecretProof.toJSON(v);
        });
      }
    }
    return obj;
  },

  create(base?: DeepPartial<StartTransferRequest>): StartTransferRequest {
    return StartTransferRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<StartTransferRequest>): StartTransferRequest {
    const message = createBaseStartTransferRequest();
    message.transferId = object.transferId ?? "";
    message.ownerIdentityPublicKey =
      object.ownerIdentityPublicKey ?? new Uint8Array(0);
    message.leavesToSend =
      object.leavesToSend?.map((e) => LeafRefundTxSigningJob.fromPartial(e)) ||
      [];
    message.receiverIdentityPublicKey =
      object.receiverIdentityPublicKey ?? new Uint8Array(0);
    message.expiryTime = object.expiryTime ?? undefined;
    message.keyTweakProofs = Object.entries(
      object.keyTweakProofs ?? {},
    ).reduce<{ [key: string]: SecretProof }>((acc, [key, value]) => {
      if (value !== undefined) {
        acc[key] = SecretProof.fromPartial(value);
      }
      return acc;
    }, {});
    return message;
  },
};

function createBaseStartTransferRequest_KeyTweakProofsEntry(): StartTransferRequest_KeyTweakProofsEntry {
  return { key: "", value: undefined };
}

export const StartTransferRequest_KeyTweakProofsEntry: MessageFns<StartTransferRequest_KeyTweakProofsEntry> =
  {
    encode(
      message: StartTransferRequest_KeyTweakProofsEntry,
      writer: BinaryWriter = new BinaryWriter(),
    ): BinaryWriter {
      if (message.key !== "") {
        writer.uint32(10).string(message.key);
      }
      if (message.value !== undefined) {
        SecretProof.encode(message.value, writer.uint32(18).fork()).join();
      }
      return writer;
    },

    decode(
      input: BinaryReader | Uint8Array,
      length?: number,
    ): StartTransferRequest_KeyTweakProofsEntry {
      const reader =
        input instanceof BinaryReader ? input : new BinaryReader(input);
      let end = length === undefined ? reader.len : reader.pos + length;
      const message = createBaseStartTransferRequest_KeyTweakProofsEntry();
      while (reader.pos < end) {
        const tag = reader.uint32();
        switch (tag >>> 3) {
          case 1: {
            if (tag !== 10) {
              break;
            }

            message.key = reader.string();
            continue;
          }
          case 2: {
            if (tag !== 18) {
              break;
            }

            message.value = SecretProof.decode(reader, reader.uint32());
            continue;
          }
        }
        if ((tag & 7) === 4 || tag === 0) {
          break;
        }
        reader.skip(tag & 7);
      }
      return message;
    },

    fromJSON(object: any): StartTransferRequest_KeyTweakProofsEntry {
      return {
        key: isSet(object.key) ? globalThis.String(object.key) : "",
        value: isSet(object.value)
          ? SecretProof.fromJSON(object.value)
          : undefined,
      };
    },

    toJSON(message: StartTransferRequest_KeyTweakProofsEntry): unknown {
      const obj: any = {};
      if (message.key !== "") {
        obj.key = message.key;
      }
      if (message.value !== undefined) {
        obj.value = SecretProof.toJSON(message.value);
      }
      return obj;
    },

    create(
      base?: DeepPartial<StartTransferRequest_KeyTweakProofsEntry>,
    ): StartTransferRequest_KeyTweakProofsEntry {
      return StartTransferRequest_KeyTweakProofsEntry.fromPartial(base ?? {});
    },
    fromPartial(
      object: DeepPartial<StartTransferRequest_KeyTweakProofsEntry>,
    ): StartTransferRequest_KeyTweakProofsEntry {
      const message = createBaseStartTransferRequest_KeyTweakProofsEntry();
      message.key = object.key ?? "";
      message.value =
        object.value !== undefined && object.value !== null
          ? SecretProof.fromPartial(object.value)
          : undefined;
      return message;
    },
  };

function createBaseStartTransferResponse(): StartTransferResponse {
  return { transfer: undefined, signingResults: [] };
}

export const StartTransferResponse: MessageFns<StartTransferResponse> = {
  encode(
    message: StartTransferResponse,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.transfer !== undefined) {
      Transfer.encode(message.transfer, writer.uint32(10).fork()).join();
    }
    for (const v of message.signingResults) {
      LeafRefundTxSigningResult.encode(v!, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(
    input: BinaryReader | Uint8Array,
    length?: number,
  ): StartTransferResponse {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseStartTransferResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.transfer = Transfer.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.signingResults.push(
            LeafRefundTxSigningResult.decode(reader, reader.uint32()),
          );
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): StartTransferResponse {
    return {
      transfer: isSet(object.transfer)
        ? Transfer.fromJSON(object.transfer)
        : undefined,
      signingResults: globalThis.Array.isArray(object?.signingResults)
        ? object.signingResults.map((e: any) =>
            LeafRefundTxSigningResult.fromJSON(e),
          )
        : [],
    };
  },

  toJSON(message: StartTransferResponse): unknown {
    const obj: any = {};
    if (message.transfer !== undefined) {
      obj.transfer = Transfer.toJSON(message.transfer);
    }
    if (message.signingResults?.length) {
      obj.signingResults = message.signingResults.map((e) =>
        LeafRefundTxSigningResult.toJSON(e),
      );
    }
    return obj;
  },

  create(base?: DeepPartial<StartTransferResponse>): StartTransferResponse {
    return StartTransferResponse.fromPartial(base ?? {});
  },
  fromPartial(
    object: DeepPartial<StartTransferResponse>,
  ): StartTransferResponse {
    const message = createBaseStartTransferResponse();
    message.transfer =
      object.transfer !== undefined && object.transfer !== null
        ? Transfer.fromPartial(object.transfer)
        : undefined;
    message.signingResults =
      object.signingResults?.map((e) =>
        LeafRefundTxSigningResult.fromPartial(e),
      ) || [];
    return message;
  },
};

function createBaseSendLeafKeyTweak(): SendLeafKeyTweak {
  return {
    leafId: "",
    secretShareTweak: undefined,
    pubkeySharesTweak: {},
    secretCipher: new Uint8Array(0),
    signature: new Uint8Array(0),
    refundSignature: new Uint8Array(0),
  };
}

export const SendLeafKeyTweak: MessageFns<SendLeafKeyTweak> = {
  encode(
    message: SendLeafKeyTweak,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.leafId !== "") {
      writer.uint32(10).string(message.leafId);
    }
    if (message.secretShareTweak !== undefined) {
      SecretShare.encode(
        message.secretShareTweak,
        writer.uint32(18).fork(),
      ).join();
    }
    Object.entries(message.pubkeySharesTweak).forEach(([key, value]) => {
      SendLeafKeyTweak_PubkeySharesTweakEntry.encode(
        { key: key as any, value },
        writer.uint32(26).fork(),
      ).join();
    });
    if (message.secretCipher.length !== 0) {
      writer.uint32(34).bytes(message.secretCipher);
    }
    if (message.signature.length !== 0) {
      writer.uint32(42).bytes(message.signature);
    }
    if (message.refundSignature.length !== 0) {
      writer.uint32(50).bytes(message.refundSignature);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SendLeafKeyTweak {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSendLeafKeyTweak();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.leafId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.secretShareTweak = SecretShare.decode(
            reader,
            reader.uint32(),
          );
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          const entry3 = SendLeafKeyTweak_PubkeySharesTweakEntry.decode(
            reader,
            reader.uint32(),
          );
          if (entry3.value !== undefined) {
            message.pubkeySharesTweak[entry3.key] = entry3.value;
          }
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.secretCipher = reader.bytes();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.signature = reader.bytes();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.refundSignature = reader.bytes();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SendLeafKeyTweak {
    return {
      leafId: isSet(object.leafId) ? globalThis.String(object.leafId) : "",
      secretShareTweak: isSet(object.secretShareTweak)
        ? SecretShare.fromJSON(object.secretShareTweak)
        : undefined,
      pubkeySharesTweak: isObject(object.pubkeySharesTweak)
        ? Object.entries(object.pubkeySharesTweak).reduce<{
            [key: string]: Uint8Array;
          }>((acc, [key, value]) => {
            acc[key] = bytesFromBase64(value as string);
            return acc;
          }, {})
        : {},
      secretCipher: isSet(object.secretCipher)
        ? bytesFromBase64(object.secretCipher)
        : new Uint8Array(0),
      signature: isSet(object.signature)
        ? bytesFromBase64(object.signature)
        : new Uint8Array(0),
      refundSignature: isSet(object.refundSignature)
        ? bytesFromBase64(object.refundSignature)
        : new Uint8Array(0),
    };
  },

  toJSON(message: SendLeafKeyTweak): unknown {
    const obj: any = {};
    if (message.leafId !== "") {
      obj.leafId = message.leafId;
    }
    if (message.secretShareTweak !== undefined) {
      obj.secretShareTweak = SecretShare.toJSON(message.secretShareTweak);
    }
    if (message.pubkeySharesTweak) {
      const entries = Object.entries(message.pubkeySharesTweak);
      if (entries.length > 0) {
        obj.pubkeySharesTweak = {};
        entries.forEach(([k, v]) => {
          obj.pubkeySharesTweak[k] = base64FromBytes(v);
        });
      }
    }
    if (message.secretCipher.length !== 0) {
      obj.secretCipher = base64FromBytes(message.secretCipher);
    }
    if (message.signature.length !== 0) {
      obj.signature = base64FromBytes(message.signature);
    }
    if (message.refundSignature.length !== 0) {
      obj.refundSignature = base64FromBytes(message.refundSignature);
    }
    return obj;
  },

  create(base?: DeepPartial<SendLeafKeyTweak>): SendLeafKeyTweak {
    return SendLeafKeyTweak.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<SendLeafKeyTweak>): SendLeafKeyTweak {
    const message = createBaseSendLeafKeyTweak();
    message.leafId = object.leafId ?? "";
    message.secretShareTweak =
      object.secretShareTweak !== undefined && object.secretShareTweak !== null
        ? SecretShare.fromPartial(object.secretShareTweak)
        : undefined;
    message.pubkeySharesTweak = Object.entries(
      object.pubkeySharesTweak ?? {},
    ).reduce<{ [key: string]: Uint8Array }>((acc, [key, value]) => {
      if (value !== undefined) {
        acc[key] = value;
      }
      return acc;
    }, {});
    message.secretCipher = object.secretCipher ?? new Uint8Array(0);
    message.signature = object.signature ?? new Uint8Array(0);
    message.refundSignature = object.refundSignature ?? new Uint8Array(0);
    return message;
  },
};

function createBaseSendLeafKeyTweak_PubkeySharesTweakEntry(): SendLeafKeyTweak_PubkeySharesTweakEntry {
  return { key: "", value: new Uint8Array(0) };
}

export const SendLeafKeyTweak_PubkeySharesTweakEntry: MessageFns<SendLeafKeyTweak_PubkeySharesTweakEntry> =
  {
    encode(
      message: SendLeafKeyTweak_PubkeySharesTweakEntry,
      writer: BinaryWriter = new BinaryWriter(),
    ): BinaryWriter {
      if (message.key !== "") {
        writer.uint32(10).string(message.key);
      }
      if (message.value.length !== 0) {
        writer.uint32(18).bytes(message.value);
      }
      return writer;
    },

    decode(
      input: BinaryReader | Uint8Array,
      length?: number,
    ): SendLeafKeyTweak_PubkeySharesTweakEntry {
      const reader =
        input instanceof BinaryReader ? input : new BinaryReader(input);
      let end = length === undefined ? reader.len : reader.pos + length;
      const message = createBaseSendLeafKeyTweak_PubkeySharesTweakEntry();
      while (reader.pos < end) {
        const tag = reader.uint32();
        switch (tag >>> 3) {
          case 1: {
            if (tag !== 10) {
              break;
            }

            message.key = reader.string();
            continue;
          }
          case 2: {
            if (tag !== 18) {
              break;
            }

            message.value = reader.bytes();
            continue;
          }
        }
        if ((tag & 7) === 4 || tag === 0) {
          break;
        }
        reader.skip(tag & 7);
      }
      return message;
    },

    fromJSON(object: any): SendLeafKeyTweak_PubkeySharesTweakEntry {
      return {
        key: isSet(object.key) ? globalThis.String(object.key) : "",
        value: isSet(object.value)
          ? bytesFromBase64(object.value)
          : new Uint8Array(0),
      };
    },

    toJSON(message: SendLeafKeyTweak_PubkeySharesTweakEntry): unknown {
      const obj: any = {};
      if (message.key !== "") {
        obj.key = message.key;
      }
      if (message.value.length !== 0) {
        obj.value = base64FromBytes(message.value);
      }
      return obj;
    },

    create(
      base?: DeepPartial<SendLeafKeyTweak_PubkeySharesTweakEntry>,
    ): SendLeafKeyTweak_PubkeySharesTweakEntry {
      return SendLeafKeyTweak_PubkeySharesTweakEntry.fromPartial(base ?? {});
    },
    fromPartial(
      object: DeepPartial<SendLeafKeyTweak_PubkeySharesTweakEntry>,
    ): SendLeafKeyTweak_PubkeySharesTweakEntry {
      const message = createBaseSendLeafKeyTweak_PubkeySharesTweakEntry();
      message.key = object.key ?? "";
      message.value = object.value ?? new Uint8Array(0);
      return message;
    },
  };

function createBaseFinalizeTransferRequest(): FinalizeTransferRequest {
  return {
    transferId: "",
    ownerIdentityPublicKey: new Uint8Array(0),
    leavesToSend: [],
  };
}

export const FinalizeTransferRequest: MessageFns<FinalizeTransferRequest> = {
  encode(
    message: FinalizeTransferRequest,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.transferId !== "") {
      writer.uint32(10).string(message.transferId);
    }
    if (message.ownerIdentityPublicKey.length !== 0) {
      writer.uint32(18).bytes(message.ownerIdentityPublicKey);
    }
    for (const v of message.leavesToSend) {
      SendLeafKeyTweak.encode(v!, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(
    input: BinaryReader | Uint8Array,
    length?: number,
  ): FinalizeTransferRequest {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseFinalizeTransferRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.transferId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.ownerIdentityPublicKey = reader.bytes();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.leavesToSend.push(
            SendLeafKeyTweak.decode(reader, reader.uint32()),
          );
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): FinalizeTransferRequest {
    return {
      transferId: isSet(object.transferId)
        ? globalThis.String(object.transferId)
        : "",
      ownerIdentityPublicKey: isSet(object.ownerIdentityPublicKey)
        ? bytesFromBase64(object.ownerIdentityPublicKey)
        : new Uint8Array(0),
      leavesToSend: globalThis.Array.isArray(object?.leavesToSend)
        ? object.leavesToSend.map((e: any) => SendLeafKeyTweak.fromJSON(e))
        : [],
    };
  },

  toJSON(message: FinalizeTransferRequest): unknown {
    const obj: any = {};
    if (message.transferId !== "") {
      obj.transferId = message.transferId;
    }
    if (message.ownerIdentityPublicKey.length !== 0) {
      obj.ownerIdentityPublicKey = base64FromBytes(
        message.ownerIdentityPublicKey,
      );
    }
    if (message.leavesToSend?.length) {
      obj.leavesToSend = message.leavesToSend.map((e) =>
        SendLeafKeyTweak.toJSON(e),
      );
    }
    return obj;
  },

  create(base?: DeepPartial<FinalizeTransferRequest>): FinalizeTransferRequest {
    return FinalizeTransferRequest.fromPartial(base ?? {});
  },
  fromPartial(
    object: DeepPartial<FinalizeTransferRequest>,
  ): FinalizeTransferRequest {
    const message = createBaseFinalizeTransferRequest();
    message.transferId = object.transferId ?? "";
    message.ownerIdentityPublicKey =
      object.ownerIdentityPublicKey ?? new Uint8Array(0);
    message.leavesToSend =
      object.leavesToSend?.map((e) => SendLeafKeyTweak.fromPartial(e)) || [];
    return message;
  },
};

function createBaseFinalizeTransferResponse(): FinalizeTransferResponse {
  return { transfer: undefined };
}

export const FinalizeTransferResponse: MessageFns<FinalizeTransferResponse> = {
  encode(
    message: FinalizeTransferResponse,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.transfer !== undefined) {
      Transfer.encode(message.transfer, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(
    input: BinaryReader | Uint8Array,
    length?: number,
  ): FinalizeTransferResponse {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseFinalizeTransferResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.transfer = Transfer.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): FinalizeTransferResponse {
    return {
      transfer: isSet(object.transfer)
        ? Transfer.fromJSON(object.transfer)
        : undefined,
    };
  },

  toJSON(message: FinalizeTransferResponse): unknown {
    const obj: any = {};
    if (message.transfer !== undefined) {
      obj.transfer = Transfer.toJSON(message.transfer);
    }
    return obj;
  },

  create(
    base?: DeepPartial<FinalizeTransferResponse>,
  ): FinalizeTransferResponse {
    return FinalizeTransferResponse.fromPartial(base ?? {});
  },
  fromPartial(
    object: DeepPartial<FinalizeTransferResponse>,
  ): FinalizeTransferResponse {
    const message = createBaseFinalizeTransferResponse();
    message.transfer =
      object.transfer !== undefined && object.transfer !== null
        ? Transfer.fromPartial(object.transfer)
        : undefined;
    return message;
  },
};

function createBaseTransfer(): Transfer {
  return {
    id: "",
    senderIdentityPublicKey: new Uint8Array(0),
    receiverIdentityPublicKey: new Uint8Array(0),
    status: 0,
    totalValue: 0,
    expiryTime: undefined,
    leaves: [],
    createdTime: undefined,
    updatedTime: undefined,
    type: 0,
  };
}

export const Transfer: MessageFns<Transfer> = {
  encode(
    message: Transfer,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.senderIdentityPublicKey.length !== 0) {
      writer.uint32(18).bytes(message.senderIdentityPublicKey);
    }
    if (message.receiverIdentityPublicKey.length !== 0) {
      writer.uint32(26).bytes(message.receiverIdentityPublicKey);
    }
    if (message.status !== 0) {
      writer.uint32(32).int32(message.status);
    }
    if (message.totalValue !== 0) {
      writer.uint32(40).uint64(message.totalValue);
    }
    if (message.expiryTime !== undefined) {
      Timestamp.encode(
        toTimestamp(message.expiryTime),
        writer.uint32(50).fork(),
      ).join();
    }
    for (const v of message.leaves) {
      TransferLeaf.encode(v!, writer.uint32(58).fork()).join();
    }
    if (message.createdTime !== undefined) {
      Timestamp.encode(
        toTimestamp(message.createdTime),
        writer.uint32(66).fork(),
      ).join();
    }
    if (message.updatedTime !== undefined) {
      Timestamp.encode(
        toTimestamp(message.updatedTime),
        writer.uint32(74).fork(),
      ).join();
    }
    if (message.type !== 0) {
      writer.uint32(80).int32(message.type);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Transfer {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTransfer();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.senderIdentityPublicKey = reader.bytes();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.receiverIdentityPublicKey = reader.bytes();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.status = reader.int32() as any;
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.totalValue = longToNumber(reader.uint64());
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.expiryTime = fromTimestamp(
            Timestamp.decode(reader, reader.uint32()),
          );
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.leaves.push(TransferLeaf.decode(reader, reader.uint32()));
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.createdTime = fromTimestamp(
            Timestamp.decode(reader, reader.uint32()),
          );
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.updatedTime = fromTimestamp(
            Timestamp.decode(reader, reader.uint32()),
          );
          continue;
        }
        case 10: {
          if (tag !== 80) {
            break;
          }

          message.type = reader.int32() as any;
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Transfer {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      senderIdentityPublicKey: isSet(object.senderIdentityPublicKey)
        ? bytesFromBase64(object.senderIdentityPublicKey)
        : new Uint8Array(0),
      receiverIdentityPublicKey: isSet(object.receiverIdentityPublicKey)
        ? bytesFromBase64(object.receiverIdentityPublicKey)
        : new Uint8Array(0),
      status: isSet(object.status) ? transferStatusFromJSON(object.status) : 0,
      totalValue: isSet(object.totalValue)
        ? globalThis.Number(object.totalValue)
        : 0,
      expiryTime: isSet(object.expiryTime)
        ? fromJsonTimestamp(object.expiryTime)
        : undefined,
      leaves: globalThis.Array.isArray(object?.leaves)
        ? object.leaves.map((e: any) => TransferLeaf.fromJSON(e))
        : [],
      createdTime: isSet(object.createdTime)
        ? fromJsonTimestamp(object.createdTime)
        : undefined,
      updatedTime: isSet(object.updatedTime)
        ? fromJsonTimestamp(object.updatedTime)
        : undefined,
      type: isSet(object.type) ? transferTypeFromJSON(object.type) : 0,
    };
  },

  toJSON(message: Transfer): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.senderIdentityPublicKey.length !== 0) {
      obj.senderIdentityPublicKey = base64FromBytes(
        message.senderIdentityPublicKey,
      );
    }
    if (message.receiverIdentityPublicKey.length !== 0) {
      obj.receiverIdentityPublicKey = base64FromBytes(
        message.receiverIdentityPublicKey,
      );
    }
    if (message.status !== 0) {
      obj.status = transferStatusToJSON(message.status);
    }
    if (message.totalValue !== 0) {
      obj.totalValue = Math.round(message.totalValue);
    }
    if (message.expiryTime !== undefined) {
      obj.expiryTime = message.expiryTime.toISOString();
    }
    if (message.leaves?.length) {
      obj.leaves = message.leaves.map((e) => TransferLeaf.toJSON(e));
    }
    if (message.createdTime !== undefined) {
      obj.createdTime = message.createdTime.toISOString();
    }
    if (message.updatedTime !== undefined) {
      obj.updatedTime = message.updatedTime.toISOString();
    }
    if (message.type !== 0) {
      obj.type = transferTypeToJSON(message.type);
    }
    return obj;
  },

  create(base?: DeepPartial<Transfer>): Transfer {
    return Transfer.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Transfer>): Transfer {
    const message = createBaseTransfer();
    message.id = object.id ?? "";
    message.senderIdentityPublicKey =
      object.senderIdentityPublicKey ?? new Uint8Array(0);
    message.receiverIdentityPublicKey =
      object.receiverIdentityPublicKey ?? new Uint8Array(0);
    message.status = object.status ?? 0;
    message.totalValue = object.totalValue ?? 0;
    message.expiryTime = object.expiryTime ?? undefined;
    message.leaves =
      object.leaves?.map((e) => TransferLeaf.fromPartial(e)) || [];
    message.createdTime = object.createdTime ?? undefined;
    message.updatedTime = object.updatedTime ?? undefined;
    message.type = object.type ?? 0;
    return message;
  },
};

function createBaseTransferLeaf(): TransferLeaf {
  return {
    leaf: undefined,
    secretCipher: new Uint8Array(0),
    signature: new Uint8Array(0),
    intermediateRefundTx: new Uint8Array(0),
  };
}

export const TransferLeaf: MessageFns<TransferLeaf> = {
  encode(
    message: TransferLeaf,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.leaf !== undefined) {
      TreeNode.encode(message.leaf, writer.uint32(10).fork()).join();
    }
    if (message.secretCipher.length !== 0) {
      writer.uint32(18).bytes(message.secretCipher);
    }
    if (message.signature.length !== 0) {
      writer.uint32(26).bytes(message.signature);
    }
    if (message.intermediateRefundTx.length !== 0) {
      writer.uint32(34).bytes(message.intermediateRefundTx);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TransferLeaf {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTransferLeaf();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.leaf = TreeNode.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.secretCipher = reader.bytes();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.signature = reader.bytes();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.intermediateRefundTx = reader.bytes();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TransferLeaf {
    return {
      leaf: isSet(object.leaf) ? TreeNode.fromJSON(object.leaf) : undefined,
      secretCipher: isSet(object.secretCipher)
        ? bytesFromBase64(object.secretCipher)
        : new Uint8Array(0),
      signature: isSet(object.signature)
        ? bytesFromBase64(object.signature)
        : new Uint8Array(0),
      intermediateRefundTx: isSet(object.intermediateRefundTx)
        ? bytesFromBase64(object.intermediateRefundTx)
        : new Uint8Array(0),
    };
  },

  toJSON(message: TransferLeaf): unknown {
    const obj: any = {};
    if (message.leaf !== undefined) {
      obj.leaf = TreeNode.toJSON(message.leaf);
    }
    if (message.secretCipher.length !== 0) {
      obj.secretCipher = base64FromBytes(message.secretCipher);
    }
    if (message.signature.length !== 0) {
      obj.signature = base64FromBytes(message.signature);
    }
    if (message.intermediateRefundTx.length !== 0) {
      obj.intermediateRefundTx = base64FromBytes(message.intermediateRefundTx);
    }
    return obj;
  },

  create(base?: DeepPartial<TransferLeaf>): TransferLeaf {
    return TransferLeaf.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<TransferLeaf>): TransferLeaf {
    const message = createBaseTransferLeaf();
    message.leaf =
      object.leaf !== undefined && object.leaf !== null
        ? TreeNode.fromPartial(object.leaf)
        : undefined;
    message.secretCipher = object.secretCipher ?? new Uint8Array(0);
    message.signature = object.signature ?? new Uint8Array(0);
    message.intermediateRefundTx =
      object.intermediateRefundTx ?? new Uint8Array(0);
    return message;
  },
};

function createBaseTransferFilter(): TransferFilter {
  return {
    participant: undefined,
    transferIds: [],
    limit: 0,
    offset: 0,
    types: [],
  };
}

export const TransferFilter: MessageFns<TransferFilter> = {
  encode(
    message: TransferFilter,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    switch (message.participant?.$case) {
      case "receiverIdentityPublicKey":
        writer.uint32(10).bytes(message.participant.receiverIdentityPublicKey);
        break;
      case "senderIdentityPublicKey":
        writer.uint32(18).bytes(message.participant.senderIdentityPublicKey);
        break;
      case "senderOrReceiverIdentityPublicKey":
        writer
          .uint32(482)
          .bytes(message.participant.senderOrReceiverIdentityPublicKey);
        break;
    }
    for (const v of message.transferIds) {
      writer.uint32(26).string(v!);
    }
    if (message.limit !== 0) {
      writer.uint32(320).int64(message.limit);
    }
    if (message.offset !== 0) {
      writer.uint32(400).int64(message.offset);
    }
    writer.uint32(562).fork();
    for (const v of message.types) {
      writer.int32(v);
    }
    writer.join();
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TransferFilter {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTransferFilter();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.participant = {
            $case: "receiverIdentityPublicKey",
            receiverIdentityPublicKey: reader.bytes(),
          };
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.participant = {
            $case: "senderIdentityPublicKey",
            senderIdentityPublicKey: reader.bytes(),
          };
          continue;
        }
        case 60: {
          if (tag !== 482) {
            break;
          }

          message.participant = {
            $case: "senderOrReceiverIdentityPublicKey",
            senderOrReceiverIdentityPublicKey: reader.bytes(),
          };
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.transferIds.push(reader.string());
          continue;
        }
        case 40: {
          if (tag !== 320) {
            break;
          }

          message.limit = longToNumber(reader.int64());
          continue;
        }
        case 50: {
          if (tag !== 400) {
            break;
          }

          message.offset = longToNumber(reader.int64());
          continue;
        }
        case 70: {
          if (tag === 560) {
            message.types.push(reader.int32() as any);

            continue;
          }

          if (tag === 562) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.types.push(reader.int32() as any);
            }

            continue;
          }

          break;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TransferFilter {
    return {
      participant: isSet(object.receiverIdentityPublicKey)
        ? {
            $case: "receiverIdentityPublicKey",
            receiverIdentityPublicKey: bytesFromBase64(
              object.receiverIdentityPublicKey,
            ),
          }
        : isSet(object.senderIdentityPublicKey)
          ? {
              $case: "senderIdentityPublicKey",
              senderIdentityPublicKey: bytesFromBase64(
                object.senderIdentityPublicKey,
              ),
            }
          : isSet(object.senderOrReceiverIdentityPublicKey)
            ? {
                $case: "senderOrReceiverIdentityPublicKey",
                senderOrReceiverIdentityPublicKey: bytesFromBase64(
                  object.senderOrReceiverIdentityPublicKey,
                ),
              }
            : undefined,
      transferIds: globalThis.Array.isArray(object?.transferIds)
        ? object.transferIds.map((e: any) => globalThis.String(e))
        : [],
      limit: isSet(object.limit) ? globalThis.Number(object.limit) : 0,
      offset: isSet(object.offset) ? globalThis.Number(object.offset) : 0,
      types: globalThis.Array.isArray(object?.types)
        ? object.types.map((e: any) => transferTypeFromJSON(e))
        : [],
    };
  },

  toJSON(message: TransferFilter): unknown {
    const obj: any = {};
    if (message.participant?.$case === "receiverIdentityPublicKey") {
      obj.receiverIdentityPublicKey = base64FromBytes(
        message.participant.receiverIdentityPublicKey,
      );
    } else if (message.participant?.$case === "senderIdentityPublicKey") {
      obj.senderIdentityPublicKey = base64FromBytes(
        message.participant.senderIdentityPublicKey,
      );
    } else if (
      message.participant?.$case === "senderOrReceiverIdentityPublicKey"
    ) {
      obj.senderOrReceiverIdentityPublicKey = base64FromBytes(
        message.participant.senderOrReceiverIdentityPublicKey,
      );
    }
    if (message.transferIds?.length) {
      obj.transferIds = message.transferIds;
    }
    if (message.limit !== 0) {
      obj.limit = Math.round(message.limit);
    }
    if (message.offset !== 0) {
      obj.offset = Math.round(message.offset);
    }
    if (message.types?.length) {
      obj.types = message.types.map((e) => transferTypeToJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<TransferFilter>): TransferFilter {
    return TransferFilter.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<TransferFilter>): TransferFilter {
    const message = createBaseTransferFilter();
    switch (object.participant?.$case) {
      case "receiverIdentityPublicKey": {
        if (
          object.participant?.receiverIdentityPublicKey !== undefined &&
          object.participant?.receiverIdentityPublicKey !== null
        ) {
          message.participant = {
            $case: "receiverIdentityPublicKey",
            receiverIdentityPublicKey:
              object.participant.receiverIdentityPublicKey,
          };
        }
        break;
      }
      case "senderIdentityPublicKey": {
        if (
          object.participant?.senderIdentityPublicKey !== undefined &&
          object.participant?.senderIdentityPublicKey !== null
        ) {
          message.participant = {
            $case: "senderIdentityPublicKey",
            senderIdentityPublicKey: object.participant.senderIdentityPublicKey,
          };
        }
        break;
      }
      case "senderOrReceiverIdentityPublicKey": {
        if (
          object.participant?.senderOrReceiverIdentityPublicKey !== undefined &&
          object.participant?.senderOrReceiverIdentityPublicKey !== null
        ) {
          message.participant = {
            $case: "senderOrReceiverIdentityPublicKey",
            senderOrReceiverIdentityPublicKey:
              object.participant.senderOrReceiverIdentityPublicKey,
          };
        }
        break;
      }
    }
    message.transferIds = object.transferIds?.map((e) => e) || [];
    message.limit = object.limit ?? 0;
    message.offset = object.offset ?? 0;
    message.types = object.types?.map((e) => e) || [];
    return message;
  },
};

function createBaseQueryTransfersResponse(): QueryTransfersResponse {
  return { transfers: [], offset: 0 };
}

export const QueryTransfersResponse: MessageFns<QueryTransfersResponse> = {
  encode(
    message: QueryTransfersResponse,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    for (const v of message.transfers) {
      Transfer.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.offset !== 0) {
      writer.uint32(16).int64(message.offset);
    }
    return writer;
  },

  decode(
    input: BinaryReader | Uint8Array,
    length?: number,
  ): QueryTransfersResponse {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryTransfersResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.transfers.push(Transfer.decode(reader, reader.uint32()));
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.offset = longToNumber(reader.int64());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): QueryTransfersResponse {
    return {
      transfers: globalThis.Array.isArray(object?.transfers)
        ? object.transfers.map((e: any) => Transfer.fromJSON(e))
        : [],
      offset: isSet(object.offset) ? globalThis.Number(object.offset) : 0,
    };
  },

  toJSON(message: QueryTransfersResponse): unknown {
    const obj: any = {};
    if (message.transfers?.length) {
      obj.transfers = message.transfers.map((e) => Transfer.toJSON(e));
    }
    if (message.offset !== 0) {
      obj.offset = Math.round(message.offset);
    }
    return obj;
  },

  create(base?: DeepPartial<QueryTransfersResponse>): QueryTransfersResponse {
    return QueryTransfersResponse.fromPartial(base ?? {});
  },
  fromPartial(
    object: DeepPartial<QueryTransfersResponse>,
  ): QueryTransfersResponse {
    const message = createBaseQueryTransfersResponse();
    message.transfers =
      object.transfers?.map((e) => Transfer.fromPartial(e)) || [];
    message.offset = object.offset ?? 0;
    return message;
  },
};

function createBaseClaimLeafKeyTweak(): ClaimLeafKeyTweak {
  return { leafId: "", secretShareTweak: undefined, pubkeySharesTweak: {} };
}

export const ClaimLeafKeyTweak: MessageFns<ClaimLeafKeyTweak> = {
  encode(
    message: ClaimLeafKeyTweak,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.leafId !== "") {
      writer.uint32(10).string(message.leafId);
    }
    if (message.secretShareTweak !== undefined) {
      SecretShare.encode(
        message.secretShareTweak,
        writer.uint32(18).fork(),
      ).join();
    }
    Object.entries(message.pubkeySharesTweak).forEach(([key, value]) => {
      ClaimLeafKeyTweak_PubkeySharesTweakEntry.encode(
        { key: key as any, value },
        writer.uint32(26).fork(),
      ).join();
    });
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ClaimLeafKeyTweak {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseClaimLeafKeyTweak();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.leafId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.secretShareTweak = SecretShare.decode(
            reader,
            reader.uint32(),
          );
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          const entry3 = ClaimLeafKeyTweak_PubkeySharesTweakEntry.decode(
            reader,
            reader.uint32(),
          );
          if (entry3.value !== undefined) {
            message.pubkeySharesTweak[entry3.key] = entry3.value;
          }
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ClaimLeafKeyTweak {
    return {
      leafId: isSet(object.leafId) ? globalThis.String(object.leafId) : "",
      secretShareTweak: isSet(object.secretShareTweak)
        ? SecretShare.fromJSON(object.secretShareTweak)
        : undefined,
      pubkeySharesTweak: isObject(object.pubkeySharesTweak)
        ? Object.entries(object.pubkeySharesTweak).reduce<{
            [key: string]: Uint8Array;
          }>((acc, [key, value]) => {
            acc[key] = bytesFromBase64(value as string);
            return acc;
          }, {})
        : {},
    };
  },

  toJSON(message: ClaimLeafKeyTweak): unknown {
    const obj: any = {};
    if (message.leafId !== "") {
      obj.leafId = message.leafId;
    }
    if (message.secretShareTweak !== undefined) {
      obj.secretShareTweak = SecretShare.toJSON(message.secretShareTweak);
    }
    if (message.pubkeySharesTweak) {
      const entries = Object.entries(message.pubkeySharesTweak);
      if (entries.length > 0) {
        obj.pubkeySharesTweak = {};
        entries.forEach(([k, v]) => {
          obj.pubkeySharesTweak[k] = base64FromBytes(v);
        });
      }
    }
    return obj;
  },

  create(base?: DeepPartial<ClaimLeafKeyTweak>): ClaimLeafKeyTweak {
    return ClaimLeafKeyTweak.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ClaimLeafKeyTweak>): ClaimLeafKeyTweak {
    const message = createBaseClaimLeafKeyTweak();
    message.leafId = object.leafId ?? "";
    message.secretShareTweak =
      object.secretShareTweak !== undefined && object.secretShareTweak !== null
        ? SecretShare.fromPartial(object.secretShareTweak)
        : undefined;
    message.pubkeySharesTweak = Object.entries(
      object.pubkeySharesTweak ?? {},
    ).reduce<{ [key: string]: Uint8Array }>((acc, [key, value]) => {
      if (value !== undefined) {
        acc[key] = value;
      }
      return acc;
    }, {});
    return message;
  },
};

function createBaseClaimLeafKeyTweak_PubkeySharesTweakEntry(): ClaimLeafKeyTweak_PubkeySharesTweakEntry {
  return { key: "", value: new Uint8Array(0) };
}

export const ClaimLeafKeyTweak_PubkeySharesTweakEntry: MessageFns<ClaimLeafKeyTweak_PubkeySharesTweakEntry> =
  {
    encode(
      message: ClaimLeafKeyTweak_PubkeySharesTweakEntry,
      writer: BinaryWriter = new BinaryWriter(),
    ): BinaryWriter {
      if (message.key !== "") {
        writer.uint32(10).string(message.key);
      }
      if (message.value.length !== 0) {
        writer.uint32(18).bytes(message.value);
      }
      return writer;
    },

    decode(
      input: BinaryReader | Uint8Array,
      length?: number,
    ): ClaimLeafKeyTweak_PubkeySharesTweakEntry {
      const reader =
        input instanceof BinaryReader ? input : new BinaryReader(input);
      let end = length === undefined ? reader.len : reader.pos + length;
      const message = createBaseClaimLeafKeyTweak_PubkeySharesTweakEntry();
      while (reader.pos < end) {
        const tag = reader.uint32();
        switch (tag >>> 3) {
          case 1: {
            if (tag !== 10) {
              break;
            }

            message.key = reader.string();
            continue;
          }
          case 2: {
            if (tag !== 18) {
              break;
            }

            message.value = reader.bytes();
            continue;
          }
        }
        if ((tag & 7) === 4 || tag === 0) {
          break;
        }
        reader.skip(tag & 7);
      }
      return message;
    },

    fromJSON(object: any): ClaimLeafKeyTweak_PubkeySharesTweakEntry {
      return {
        key: isSet(object.key) ? globalThis.String(object.key) : "",
        value: isSet(object.value)
          ? bytesFromBase64(object.value)
          : new Uint8Array(0),
      };
    },

    toJSON(message: ClaimLeafKeyTweak_PubkeySharesTweakEntry): unknown {
      const obj: any = {};
      if (message.key !== "") {
        obj.key = message.key;
      }
      if (message.value.length !== 0) {
        obj.value = base64FromBytes(message.value);
      }
      return obj;
    },

    create(
      base?: DeepPartial<ClaimLeafKeyTweak_PubkeySharesTweakEntry>,
    ): ClaimLeafKeyTweak_PubkeySharesTweakEntry {
      return ClaimLeafKeyTweak_PubkeySharesTweakEntry.fromPartial(base ?? {});
    },
    fromPartial(
      object: DeepPartial<ClaimLeafKeyTweak_PubkeySharesTweakEntry>,
    ): ClaimLeafKeyTweak_PubkeySharesTweakEntry {
      const message = createBaseClaimLeafKeyTweak_PubkeySharesTweakEntry();
      message.key = object.key ?? "";
      message.value = object.value ?? new Uint8Array(0);
      return message;
    },
  };

function createBaseClaimTransferTweakKeysRequest(): ClaimTransferTweakKeysRequest {
  return {
    transferId: "",
    ownerIdentityPublicKey: new Uint8Array(0),
    leavesToReceive: [],
  };
}

export const ClaimTransferTweakKeysRequest: MessageFns<ClaimTransferTweakKeysRequest> =
  {
    encode(
      message: ClaimTransferTweakKeysRequest,
      writer: BinaryWriter = new BinaryWriter(),
    ): BinaryWriter {
      if (message.transferId !== "") {
        writer.uint32(10).string(message.transferId);
      }
      if (message.ownerIdentityPublicKey.length !== 0) {
        writer.uint32(18).bytes(message.ownerIdentityPublicKey);
      }
      for (const v of message.leavesToReceive) {
        ClaimLeafKeyTweak.encode(v!, writer.uint32(26).fork()).join();
      }
      return writer;
    },

    decode(
      input: BinaryReader | Uint8Array,
      length?: number,
    ): ClaimTransferTweakKeysRequest {
      const reader =
        input instanceof BinaryReader ? input : new BinaryReader(input);
      let end = length === undefined ? reader.len : reader.pos + length;
      const message = createBaseClaimTransferTweakKeysRequest();
      while (reader.pos < end) {
        const tag = reader.uint32();
        switch (tag >>> 3) {
          case 1: {
            if (tag !== 10) {
              break;
            }

            message.transferId = reader.string();
            continue;
          }
          case 2: {
            if (tag !== 18) {
              break;
            }

            message.ownerIdentityPublicKey = reader.bytes();
            continue;
          }
          case 3: {
            if (tag !== 26) {
              break;
            }

            message.leavesToReceive.push(
              ClaimLeafKeyTweak.decode(reader, reader.uint32()),
            );
            continue;
          }
        }
        if ((tag & 7) === 4 || tag === 0) {
          break;
        }
        reader.skip(tag & 7);
      }
      return message;
    },

    fromJSON(object: any): ClaimTransferTweakKeysRequest {
      return {
        transferId: isSet(object.transferId)
          ? globalThis.String(object.transferId)
          : "",
        ownerIdentityPublicKey: isSet(object.ownerIdentityPublicKey)
          ? bytesFromBase64(object.ownerIdentityPublicKey)
          : new Uint8Array(0),
        leavesToReceive: globalThis.Array.isArray(object?.leavesToReceive)
          ? object.leavesToReceive.map((e: any) =>
              ClaimLeafKeyTweak.fromJSON(e),
            )
          : [],
      };
    },

    toJSON(message: ClaimTransferTweakKeysRequest): unknown {
      const obj: any = {};
      if (message.transferId !== "") {
        obj.transferId = message.transferId;
      }
      if (message.ownerIdentityPublicKey.length !== 0) {
        obj.ownerIdentityPublicKey = base64FromBytes(
          message.ownerIdentityPublicKey,
        );
      }
      if (message.leavesToReceive?.length) {
        obj.leavesToReceive = message.leavesToReceive.map((e) =>
          ClaimLeafKeyTweak.toJSON(e),
        );
      }
      return obj;
    },

    create(
      base?: DeepPartial<ClaimTransferTweakKeysRequest>,
    ): ClaimTransferTweakKeysRequest {
      return ClaimTransferTweakKeysRequest.fromPartial(base ?? {});
    },
    fromPartial(
      object: DeepPartial<ClaimTransferTweakKeysRequest>,
    ): ClaimTransferTweakKeysRequest {
      const message = createBaseClaimTransferTweakKeysRequest();
      message.transferId = object.transferId ?? "";
      message.ownerIdentityPublicKey =
        object.ownerIdentityPublicKey ?? new Uint8Array(0);
      message.leavesToReceive =
        object.leavesToReceive?.map((e) => ClaimLeafKeyTweak.fromPartial(e)) ||
        [];
      return message;
    },
  };

function createBaseClaimTransferSignRefundsRequest(): ClaimTransferSignRefundsRequest {
  return {
    transferId: "",
    ownerIdentityPublicKey: new Uint8Array(0),
    signingJobs: [],
    keyTweakProofs: {},
  };
}

export const ClaimTransferSignRefundsRequest: MessageFns<ClaimTransferSignRefundsRequest> =
  {
    encode(
      message: ClaimTransferSignRefundsRequest,
      writer: BinaryWriter = new BinaryWriter(),
    ): BinaryWriter {
      if (message.transferId !== "") {
        writer.uint32(10).string(message.transferId);
      }
      if (message.ownerIdentityPublicKey.length !== 0) {
        writer.uint32(18).bytes(message.ownerIdentityPublicKey);
      }
      for (const v of message.signingJobs) {
        LeafRefundTxSigningJob.encode(v!, writer.uint32(26).fork()).join();
      }
      Object.entries(message.keyTweakProofs).forEach(([key, value]) => {
        ClaimTransferSignRefundsRequest_KeyTweakProofsEntry.encode(
          { key: key as any, value },
          writer.uint32(34).fork(),
        ).join();
      });
      return writer;
    },

    decode(
      input: BinaryReader | Uint8Array,
      length?: number,
    ): ClaimTransferSignRefundsRequest {
      const reader =
        input instanceof BinaryReader ? input : new BinaryReader(input);
      let end = length === undefined ? reader.len : reader.pos + length;
      const message = createBaseClaimTransferSignRefundsRequest();
      while (reader.pos < end) {
        const tag = reader.uint32();
        switch (tag >>> 3) {
          case 1: {
            if (tag !== 10) {
              break;
            }

            message.transferId = reader.string();
            continue;
          }
          case 2: {
            if (tag !== 18) {
              break;
            }

            message.ownerIdentityPublicKey = reader.bytes();
            continue;
          }
          case 3: {
            if (tag !== 26) {
              break;
            }

            message.signingJobs.push(
              LeafRefundTxSigningJob.decode(reader, reader.uint32()),
            );
            continue;
          }
          case 4: {
            if (tag !== 34) {
              break;
            }

            const entry4 =
              ClaimTransferSignRefundsRequest_KeyTweakProofsEntry.decode(
                reader,
                reader.uint32(),
              );
            if (entry4.value !== undefined) {
              message.keyTweakProofs[entry4.key] = entry4.value;
            }
            continue;
          }
        }
        if ((tag & 7) === 4 || tag === 0) {
          break;
        }
        reader.skip(tag & 7);
      }
      return message;
    },

    fromJSON(object: any): ClaimTransferSignRefundsRequest {
      return {
        transferId: isSet(object.transferId)
          ? globalThis.String(object.transferId)
          : "",
        ownerIdentityPublicKey: isSet(object.ownerIdentityPublicKey)
          ? bytesFromBase64(object.ownerIdentityPublicKey)
          : new Uint8Array(0),
        signingJobs: globalThis.Array.isArray(object?.signingJobs)
          ? object.signingJobs.map((e: any) =>
              LeafRefundTxSigningJob.fromJSON(e),
            )
          : [],
        keyTweakProofs: isObject(object.keyTweakProofs)
          ? Object.entries(object.keyTweakProofs).reduce<{
              [key: string]: SecretProof;
            }>((acc, [key, value]) => {
              acc[key] = SecretProof.fromJSON(value);
              return acc;
            }, {})
          : {},
      };
    },

    toJSON(message: ClaimTransferSignRefundsRequest): unknown {
      const obj: any = {};
      if (message.transferId !== "") {
        obj.transferId = message.transferId;
      }
      if (message.ownerIdentityPublicKey.length !== 0) {
        obj.ownerIdentityPublicKey = base64FromBytes(
          message.ownerIdentityPublicKey,
        );
      }
      if (message.signingJobs?.length) {
        obj.signingJobs = message.signingJobs.map((e) =>
          LeafRefundTxSigningJob.toJSON(e),
        );
      }
      if (message.keyTweakProofs) {
        const entries = Object.entries(message.keyTweakProofs);
        if (entries.length > 0) {
          obj.keyTweakProofs = {};
          entries.forEach(([k, v]) => {
            obj.keyTweakProofs[k] = SecretProof.toJSON(v);
          });
        }
      }
      return obj;
    },

    create(
      base?: DeepPartial<ClaimTransferSignRefundsRequest>,
    ): ClaimTransferSignRefundsRequest {
      return ClaimTransferSignRefundsRequest.fromPartial(base ?? {});
    },
    fromPartial(
      object: DeepPartial<ClaimTransferSignRefundsRequest>,
    ): ClaimTransferSignRefundsRequest {
      const message = createBaseClaimTransferSignRefundsRequest();
      message.transferId = object.transferId ?? "";
      message.ownerIdentityPublicKey =
        object.ownerIdentityPublicKey ?? new Uint8Array(0);
      message.signingJobs =
        object.signingJobs?.map((e) => LeafRefundTxSigningJob.fromPartial(e)) ||
        [];
      message.keyTweakProofs = Object.entries(
        object.keyTweakProofs ?? {},
      ).reduce<{ [key: string]: SecretProof }>((acc, [key, value]) => {
        if (value !== undefined) {
          acc[key] = SecretProof.fromPartial(value);
        }
        return acc;
      }, {});
      return message;
    },
  };

function createBaseClaimTransferSignRefundsRequest_KeyTweakProofsEntry(): ClaimTransferSignRefundsRequest_KeyTweakProofsEntry {
  return { key: "", value: undefined };
}

export const ClaimTransferSignRefundsRequest_KeyTweakProofsEntry: MessageFns<ClaimTransferSignRefundsRequest_KeyTweakProofsEntry> =
  {
    encode(
      message: ClaimTransferSignRefundsRequest_KeyTweakProofsEntry,
      writer: BinaryWriter = new BinaryWriter(),
    ): BinaryWriter {
      if (message.key !== "") {
        writer.uint32(10).string(message.key);
      }
      if (message.value !== undefined) {
        SecretProof.encode(message.value, writer.uint32(18).fork()).join();
      }
      return writer;
    },

    decode(
      input: BinaryReader | Uint8Array,
      length?: number,
    ): ClaimTransferSignRefundsRequest_KeyTweakProofsEntry {
      const reader =
        input instanceof BinaryReader ? input : new BinaryReader(input);
      let end = length === undefined ? reader.len : reader.pos + length;
      const message =
        createBaseClaimTransferSignRefundsRequest_KeyTweakProofsEntry();
      while (reader.pos < end) {
        const tag = reader.uint32();
        switch (tag >>> 3) {
          case 1: {
            if (tag !== 10) {
              break;
            }

            message.key = reader.string();
            continue;
          }
          case 2: {
            if (tag !== 18) {
              break;
            }

            message.value = SecretProof.decode(reader, reader.uint32());
            continue;
          }
        }
        if ((tag & 7) === 4 || tag === 0) {
          break;
        }
        reader.skip(tag & 7);
      }
      return message;
    },

    fromJSON(object: any): ClaimTransferSignRefundsRequest_KeyTweakProofsEntry {
      return {
        key: isSet(object.key) ? globalThis.String(object.key) : "",
        value: isSet(object.value)
          ? SecretProof.fromJSON(object.value)
          : undefined,
      };
    },

    toJSON(
      message: ClaimTransferSignRefundsRequest_KeyTweakProofsEntry,
    ): unknown {
      const obj: any = {};
      if (message.key !== "") {
        obj.key = message.key;
      }
      if (message.value !== undefined) {
        obj.value = SecretProof.toJSON(message.value);
      }
      return obj;
    },

    create(
      base?: DeepPartial<ClaimTransferSignRefundsRequest_KeyTweakProofsEntry>,
    ): ClaimTransferSignRefundsRequest_KeyTweakProofsEntry {
      return ClaimTransferSignRefundsRequest_KeyTweakProofsEntry.fromPartial(
        base ?? {},
      );
    },
    fromPartial(
      object: DeepPartial<ClaimTransferSignRefundsRequest_KeyTweakProofsEntry>,
    ): ClaimTransferSignRefundsRequest_KeyTweakProofsEntry {
      const message =
        createBaseClaimTransferSignRefundsRequest_KeyTweakProofsEntry();
      message.key = object.key ?? "";
      message.value =
        object.value !== undefined && object.value !== null
          ? SecretProof.fromPartial(object.value)
          : undefined;
      return message;
    },
  };

function createBaseClaimTransferSignRefundsResponse(): ClaimTransferSignRefundsResponse {
  return { signingResults: [] };
}

export const ClaimTransferSignRefundsResponse: MessageFns<ClaimTransferSignRefundsResponse> =
  {
    encode(
      message: ClaimTransferSignRefundsResponse,
      writer: BinaryWriter = new BinaryWriter(),
    ): BinaryWriter {
      for (const v of message.signingResults) {
        LeafRefundTxSigningResult.encode(v!, writer.uint32(10).fork()).join();
      }
      return writer;
    },

    decode(
      input: BinaryReader | Uint8Array,
      length?: number,
    ): ClaimTransferSignRefundsResponse {
      const reader =
        input instanceof BinaryReader ? input : new BinaryReader(input);
      let end = length === undefined ? reader.len : reader.pos + length;
      const message = createBaseClaimTransferSignRefundsResponse();
      while (reader.pos < end) {
        const tag = reader.uint32();
        switch (tag >>> 3) {
          case 1: {
            if (tag !== 10) {
              break;
            }

            message.signingResults.push(
              LeafRefundTxSigningResult.decode(reader, reader.uint32()),
            );
            continue;
          }
        }
        if ((tag & 7) === 4 || tag === 0) {
          break;
        }
        reader.skip(tag & 7);
      }
      return message;
    },

    fromJSON(object: any): ClaimTransferSignRefundsResponse {
      return {
        signingResults: globalThis.Array.isArray(object?.signingResults)
          ? object.signingResults.map((e: any) =>
              LeafRefundTxSigningResult.fromJSON(e),
            )
          : [],
      };
    },

    toJSON(message: ClaimTransferSignRefundsResponse): unknown {
      const obj: any = {};
      if (message.signingResults?.length) {
        obj.signingResults = message.signingResults.map((e) =>
          LeafRefundTxSigningResult.toJSON(e),
        );
      }
      return obj;
    },

    create(
      base?: DeepPartial<ClaimTransferSignRefundsResponse>,
    ): ClaimTransferSignRefundsResponse {
      return ClaimTransferSignRefundsResponse.fromPartial(base ?? {});
    },
    fromPartial(
      object: DeepPartial<ClaimTransferSignRefundsResponse>,
    ): ClaimTransferSignRefundsResponse {
      const message = createBaseClaimTransferSignRefundsResponse();
      message.signingResults =
        object.signingResults?.map((e) =>
          LeafRefundTxSigningResult.fromPartial(e),
        ) || [];
      return message;
    },
  };

function createBaseAggregateNodesRequest(): AggregateNodesRequest {
  return {
    nodeIds: [],
    signingJob: undefined,
    ownerIdentityPublicKey: new Uint8Array(0),
  };
}

export const AggregateNodesRequest: MessageFns<AggregateNodesRequest> = {
  encode(
    message: AggregateNodesRequest,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    for (const v of message.nodeIds) {
      writer.uint32(10).string(v!);
    }
    if (message.signingJob !== undefined) {
      SigningJob.encode(message.signingJob, writer.uint32(18).fork()).join();
    }
    if (message.ownerIdentityPublicKey.length !== 0) {
      writer.uint32(26).bytes(message.ownerIdentityPublicKey);
    }
    return writer;
  },

  decode(
    input: BinaryReader | Uint8Array,
    length?: number,
  ): AggregateNodesRequest {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAggregateNodesRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.nodeIds.push(reader.string());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.signingJob = SigningJob.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.ownerIdentityPublicKey = reader.bytes();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AggregateNodesRequest {
    return {
      nodeIds: globalThis.Array.isArray(object?.nodeIds)
        ? object.nodeIds.map((e: any) => globalThis.String(e))
        : [],
      signingJob: isSet(object.signingJob)
        ? SigningJob.fromJSON(object.signingJob)
        : undefined,
      ownerIdentityPublicKey: isSet(object.ownerIdentityPublicKey)
        ? bytesFromBase64(object.ownerIdentityPublicKey)
        : new Uint8Array(0),
    };
  },

  toJSON(message: AggregateNodesRequest): unknown {
    const obj: any = {};
    if (message.nodeIds?.length) {
      obj.nodeIds = message.nodeIds;
    }
    if (message.signingJob !== undefined) {
      obj.signingJob = SigningJob.toJSON(message.signingJob);
    }
    if (message.ownerIdentityPublicKey.length !== 0) {
      obj.ownerIdentityPublicKey = base64FromBytes(
        message.ownerIdentityPublicKey,
      );
    }
    return obj;
  },

  create(base?: DeepPartial<AggregateNodesRequest>): AggregateNodesRequest {
    return AggregateNodesRequest.fromPartial(base ?? {});
  },
  fromPartial(
    object: DeepPartial<AggregateNodesRequest>,
  ): AggregateNodesRequest {
    const message = createBaseAggregateNodesRequest();
    message.nodeIds = object.nodeIds?.map((e) => e) || [];
    message.signingJob =
      object.signingJob !== undefined && object.signingJob !== null
        ? SigningJob.fromPartial(object.signingJob)
        : undefined;
    message.ownerIdentityPublicKey =
      object.ownerIdentityPublicKey ?? new Uint8Array(0);
    return message;
  },
};

function createBaseAggregateNodesResponse(): AggregateNodesResponse {
  return {
    aggregateSignature: undefined,
    verifyingKey: new Uint8Array(0),
    parentNodeTx: new Uint8Array(0),
    parentNodeVout: 0,
  };
}

export const AggregateNodesResponse: MessageFns<AggregateNodesResponse> = {
  encode(
    message: AggregateNodesResponse,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.aggregateSignature !== undefined) {
      SigningResult.encode(
        message.aggregateSignature,
        writer.uint32(10).fork(),
      ).join();
    }
    if (message.verifyingKey.length !== 0) {
      writer.uint32(18).bytes(message.verifyingKey);
    }
    if (message.parentNodeTx.length !== 0) {
      writer.uint32(26).bytes(message.parentNodeTx);
    }
    if (message.parentNodeVout !== 0) {
      writer.uint32(32).uint32(message.parentNodeVout);
    }
    return writer;
  },

  decode(
    input: BinaryReader | Uint8Array,
    length?: number,
  ): AggregateNodesResponse {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAggregateNodesResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.aggregateSignature = SigningResult.decode(
            reader,
            reader.uint32(),
          );
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.verifyingKey = reader.bytes();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.parentNodeTx = reader.bytes();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.parentNodeVout = reader.uint32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AggregateNodesResponse {
    return {
      aggregateSignature: isSet(object.aggregateSignature)
        ? SigningResult.fromJSON(object.aggregateSignature)
        : undefined,
      verifyingKey: isSet(object.verifyingKey)
        ? bytesFromBase64(object.verifyingKey)
        : new Uint8Array(0),
      parentNodeTx: isSet(object.parentNodeTx)
        ? bytesFromBase64(object.parentNodeTx)
        : new Uint8Array(0),
      parentNodeVout: isSet(object.parentNodeVout)
        ? globalThis.Number(object.parentNodeVout)
        : 0,
    };
  },

  toJSON(message: AggregateNodesResponse): unknown {
    const obj: any = {};
    if (message.aggregateSignature !== undefined) {
      obj.aggregateSignature = SigningResult.toJSON(message.aggregateSignature);
    }
    if (message.verifyingKey.length !== 0) {
      obj.verifyingKey = base64FromBytes(message.verifyingKey);
    }
    if (message.parentNodeTx.length !== 0) {
      obj.parentNodeTx = base64FromBytes(message.parentNodeTx);
    }
    if (message.parentNodeVout !== 0) {
      obj.parentNodeVout = Math.round(message.parentNodeVout);
    }
    return obj;
  },

  create(base?: DeepPartial<AggregateNodesResponse>): AggregateNodesResponse {
    return AggregateNodesResponse.fromPartial(base ?? {});
  },
  fromPartial(
    object: DeepPartial<AggregateNodesResponse>,
  ): AggregateNodesResponse {
    const message = createBaseAggregateNodesResponse();
    message.aggregateSignature =
      object.aggregateSignature !== undefined &&
      object.aggregateSignature !== null
        ? SigningResult.fromPartial(object.aggregateSignature)
        : undefined;
    message.verifyingKey = object.verifyingKey ?? new Uint8Array(0);
    message.parentNodeTx = object.parentNodeTx ?? new Uint8Array(0);
    message.parentNodeVout = object.parentNodeVout ?? 0;
    return message;
  },
};

function createBaseStorePreimageShareRequest(): StorePreimageShareRequest {
  return {
    paymentHash: new Uint8Array(0),
    preimageShare: undefined,
    threshold: 0,
    invoiceString: "",
    userIdentityPublicKey: new Uint8Array(0),
  };
}

export const StorePreimageShareRequest: MessageFns<StorePreimageShareRequest> =
  {
    encode(
      message: StorePreimageShareRequest,
      writer: BinaryWriter = new BinaryWriter(),
    ): BinaryWriter {
      if (message.paymentHash.length !== 0) {
        writer.uint32(10).bytes(message.paymentHash);
      }
      if (message.preimageShare !== undefined) {
        SecretShare.encode(
          message.preimageShare,
          writer.uint32(18).fork(),
        ).join();
      }
      if (message.threshold !== 0) {
        writer.uint32(24).uint32(message.threshold);
      }
      if (message.invoiceString !== "") {
        writer.uint32(34).string(message.invoiceString);
      }
      if (message.userIdentityPublicKey.length !== 0) {
        writer.uint32(42).bytes(message.userIdentityPublicKey);
      }
      return writer;
    },

    decode(
      input: BinaryReader | Uint8Array,
      length?: number,
    ): StorePreimageShareRequest {
      const reader =
        input instanceof BinaryReader ? input : new BinaryReader(input);
      let end = length === undefined ? reader.len : reader.pos + length;
      const message = createBaseStorePreimageShareRequest();
      while (reader.pos < end) {
        const tag = reader.uint32();
        switch (tag >>> 3) {
          case 1: {
            if (tag !== 10) {
              break;
            }

            message.paymentHash = reader.bytes();
            continue;
          }
          case 2: {
            if (tag !== 18) {
              break;
            }

            message.preimageShare = SecretShare.decode(reader, reader.uint32());
            continue;
          }
          case 3: {
            if (tag !== 24) {
              break;
            }

            message.threshold = reader.uint32();
            continue;
          }
          case 4: {
            if (tag !== 34) {
              break;
            }

            message.invoiceString = reader.string();
            continue;
          }
          case 5: {
            if (tag !== 42) {
              break;
            }

            message.userIdentityPublicKey = reader.bytes();
            continue;
          }
        }
        if ((tag & 7) === 4 || tag === 0) {
          break;
        }
        reader.skip(tag & 7);
      }
      return message;
    },

    fromJSON(object: any): StorePreimageShareRequest {
      return {
        paymentHash: isSet(object.paymentHash)
          ? bytesFromBase64(object.paymentHash)
          : new Uint8Array(0),
        preimageShare: isSet(object.preimageShare)
          ? SecretShare.fromJSON(object.preimageShare)
          : undefined,
        threshold: isSet(object.threshold)
          ? globalThis.Number(object.threshold)
          : 0,
        invoiceString: isSet(object.invoiceString)
          ? globalThis.String(object.invoiceString)
          : "",
        userIdentityPublicKey: isSet(object.userIdentityPublicKey)
          ? bytesFromBase64(object.userIdentityPublicKey)
          : new Uint8Array(0),
      };
    },

    toJSON(message: StorePreimageShareRequest): unknown {
      const obj: any = {};
      if (message.paymentHash.length !== 0) {
        obj.paymentHash = base64FromBytes(message.paymentHash);
      }
      if (message.preimageShare !== undefined) {
        obj.preimageShare = SecretShare.toJSON(message.preimageShare);
      }
      if (message.threshold !== 0) {
        obj.threshold = Math.round(message.threshold);
      }
      if (message.invoiceString !== "") {
        obj.invoiceString = message.invoiceString;
      }
      if (message.userIdentityPublicKey.length !== 0) {
        obj.userIdentityPublicKey = base64FromBytes(
          message.userIdentityPublicKey,
        );
      }
      return obj;
    },

    create(
      base?: DeepPartial<StorePreimageShareRequest>,
    ): StorePreimageShareRequest {
      return StorePreimageShareRequest.fromPartial(base ?? {});
    },
    fromPartial(
      object: DeepPartial<StorePreimageShareRequest>,
    ): StorePreimageShareRequest {
      const message = createBaseStorePreimageShareRequest();
      message.paymentHash = object.paymentHash ?? new Uint8Array(0);
      message.preimageShare =
        object.preimageShare !== undefined && object.preimageShare !== null
          ? SecretShare.fromPartial(object.preimageShare)
          : undefined;
      message.threshold = object.threshold ?? 0;
      message.invoiceString = object.invoiceString ?? "";
      message.userIdentityPublicKey =
        object.userIdentityPublicKey ?? new Uint8Array(0);
      return message;
    },
  };

function createBaseRequestedSigningCommitments(): RequestedSigningCommitments {
  return { signingNonceCommitments: {} };
}

export const RequestedSigningCommitments: MessageFns<RequestedSigningCommitments> =
  {
    encode(
      message: RequestedSigningCommitments,
      writer: BinaryWriter = new BinaryWriter(),
    ): BinaryWriter {
      Object.entries(message.signingNonceCommitments).forEach(
        ([key, value]) => {
          RequestedSigningCommitments_SigningNonceCommitmentsEntry.encode(
            { key: key as any, value },
            writer.uint32(10).fork(),
          ).join();
        },
      );
      return writer;
    },

    decode(
      input: BinaryReader | Uint8Array,
      length?: number,
    ): RequestedSigningCommitments {
      const reader =
        input instanceof BinaryReader ? input : new BinaryReader(input);
      let end = length === undefined ? reader.len : reader.pos + length;
      const message = createBaseRequestedSigningCommitments();
      while (reader.pos < end) {
        const tag = reader.uint32();
        switch (tag >>> 3) {
          case 1: {
            if (tag !== 10) {
              break;
            }

            const entry1 =
              RequestedSigningCommitments_SigningNonceCommitmentsEntry.decode(
                reader,
                reader.uint32(),
              );
            if (entry1.value !== undefined) {
              message.signingNonceCommitments[entry1.key] = entry1.value;
            }
            continue;
          }
        }
        if ((tag & 7) === 4 || tag === 0) {
          break;
        }
        reader.skip(tag & 7);
      }
      return message;
    },

    fromJSON(object: any): RequestedSigningCommitments {
      return {
        signingNonceCommitments: isObject(object.signingNonceCommitments)
          ? Object.entries(object.signingNonceCommitments).reduce<{
              [key: string]: SigningCommitment;
            }>((acc, [key, value]) => {
              acc[key] = SigningCommitment.fromJSON(value);
              return acc;
            }, {})
          : {},
      };
    },

    toJSON(message: RequestedSigningCommitments): unknown {
      const obj: any = {};
      if (message.signingNonceCommitments) {
        const entries = Object.entries(message.signingNonceCommitments);
        if (entries.length > 0) {
          obj.signingNonceCommitments = {};
          entries.forEach(([k, v]) => {
            obj.signingNonceCommitments[k] = SigningCommitment.toJSON(v);
          });
        }
      }
      return obj;
    },

    create(
      base?: DeepPartial<RequestedSigningCommitments>,
    ): RequestedSigningCommitments {
      return RequestedSigningCommitments.fromPartial(base ?? {});
    },
    fromPartial(
      object: DeepPartial<RequestedSigningCommitments>,
    ): RequestedSigningCommitments {
      const message = createBaseRequestedSigningCommitments();
      message.signingNonceCommitments = Object.entries(
        object.signingNonceCommitments ?? {},
      ).reduce<{ [key: string]: SigningCommitment }>((acc, [key, value]) => {
        if (value !== undefined) {
          acc[key] = SigningCommitment.fromPartial(value);
        }
        return acc;
      }, {});
      return message;
    },
  };

function createBaseRequestedSigningCommitments_SigningNonceCommitmentsEntry(): RequestedSigningCommitments_SigningNonceCommitmentsEntry {
  return { key: "", value: undefined };
}

export const RequestedSigningCommitments_SigningNonceCommitmentsEntry: MessageFns<RequestedSigningCommitments_SigningNonceCommitmentsEntry> =
  {
    encode(
      message: RequestedSigningCommitments_SigningNonceCommitmentsEntry,
      writer: BinaryWriter = new BinaryWriter(),
    ): BinaryWriter {
      if (message.key !== "") {
        writer.uint32(10).string(message.key);
      }
      if (message.value !== undefined) {
        SigningCommitment.encode(
          message.value,
          writer.uint32(18).fork(),
        ).join();
      }
      return writer;
    },

    decode(
      input: BinaryReader | Uint8Array,
      length?: number,
    ): RequestedSigningCommitments_SigningNonceCommitmentsEntry {
      const reader =
        input instanceof BinaryReader ? input : new BinaryReader(input);
      let end = length === undefined ? reader.len : reader.pos + length;
      const message =
        createBaseRequestedSigningCommitments_SigningNonceCommitmentsEntry();
      while (reader.pos < end) {
        const tag = reader.uint32();
        switch (tag >>> 3) {
          case 1: {
            if (tag !== 10) {
              break;
            }

            message.key = reader.string();
            continue;
          }
          case 2: {
            if (tag !== 18) {
              break;
            }

            message.value = SigningCommitment.decode(reader, reader.uint32());
            continue;
          }
        }
        if ((tag & 7) === 4 || tag === 0) {
          break;
        }
        reader.skip(tag & 7);
      }
      return message;
    },

    fromJSON(
      object: any,
    ): RequestedSigningCommitments_SigningNonceCommitmentsEntry {
      return {
        key: isSet(object.key) ? globalThis.String(object.key) : "",
        value: isSet(object.value)
          ? SigningCommitment.fromJSON(object.value)
          : undefined,
      };
    },

    toJSON(
      message: RequestedSigningCommitments_SigningNonceCommitmentsEntry,
    ): unknown {
      const obj: any = {};
      if (message.key !== "") {
        obj.key = message.key;
      }
      if (message.value !== undefined) {
        obj.value = SigningCommitment.toJSON(message.value);
      }
      return obj;
    },

    create(
      base?: DeepPartial<RequestedSigningCommitments_SigningNonceCommitmentsEntry>,
    ): RequestedSigningCommitments_SigningNonceCommitmentsEntry {
      return RequestedSigningCommitments_SigningNonceCommitmentsEntry.fromPartial(
        base ?? {},
      );
    },
    fromPartial(
      object: DeepPartial<RequestedSigningCommitments_SigningNonceCommitmentsEntry>,
    ): RequestedSigningCommitments_SigningNonceCommitmentsEntry {
      const message =
        createBaseRequestedSigningCommitments_SigningNonceCommitmentsEntry();
      message.key = object.key ?? "";
      message.value =
        object.value !== undefined && object.value !== null
          ? SigningCommitment.fromPartial(object.value)
          : undefined;
      return message;
    },
  };

function createBaseGetSigningCommitmentsRequest(): GetSigningCommitmentsRequest {
  return { nodeIds: [] };
}

export const GetSigningCommitmentsRequest: MessageFns<GetSigningCommitmentsRequest> =
  {
    encode(
      message: GetSigningCommitmentsRequest,
      writer: BinaryWriter = new BinaryWriter(),
    ): BinaryWriter {
      for (const v of message.nodeIds) {
        writer.uint32(10).string(v!);
      }
      return writer;
    },

    decode(
      input: BinaryReader | Uint8Array,
      length?: number,
    ): GetSigningCommitmentsRequest {
      const reader =
        input instanceof BinaryReader ? input : new BinaryReader(input);
      let end = length === undefined ? reader.len : reader.pos + length;
      const message = createBaseGetSigningCommitmentsRequest();
      while (reader.pos < end) {
        const tag = reader.uint32();
        switch (tag >>> 3) {
          case 1: {
            if (tag !== 10) {
              break;
            }

            message.nodeIds.push(reader.string());
            continue;
          }
        }
        if ((tag & 7) === 4 || tag === 0) {
          break;
        }
        reader.skip(tag & 7);
      }
      return message;
    },

    fromJSON(object: any): GetSigningCommitmentsRequest {
      return {
        nodeIds: globalThis.Array.isArray(object?.nodeIds)
          ? object.nodeIds.map((e: any) => globalThis.String(e))
          : [],
      };
    },

    toJSON(message: GetSigningCommitmentsRequest): unknown {
      const obj: any = {};
      if (message.nodeIds?.length) {
        obj.nodeIds = message.nodeIds;
      }
      return obj;
    },

    create(
      base?: DeepPartial<GetSigningCommitmentsRequest>,
    ): GetSigningCommitmentsRequest {
      return GetSigningCommitmentsRequest.fromPartial(base ?? {});
    },
    fromPartial(
      object: DeepPartial<GetSigningCommitmentsRequest>,
    ): GetSigningCommitmentsRequest {
      const message = createBaseGetSigningCommitmentsRequest();
      message.nodeIds = object.nodeIds?.map((e) => e) || [];
      return message;
    },
  };

function createBaseGetSigningCommitmentsResponse(): GetSigningCommitmentsResponse {
  return { signingCommitments: [] };
}

export const GetSigningCommitmentsResponse: MessageFns<GetSigningCommitmentsResponse> =
  {
    encode(
      message: GetSigningCommitmentsResponse,
      writer: BinaryWriter = new BinaryWriter(),
    ): BinaryWriter {
      for (const v of message.signingCommitments) {
        RequestedSigningCommitments.encode(v!, writer.uint32(10).fork()).join();
      }
      return writer;
    },

    decode(
      input: BinaryReader | Uint8Array,
      length?: number,
    ): GetSigningCommitmentsResponse {
      const reader =
        input instanceof BinaryReader ? input : new BinaryReader(input);
      let end = length === undefined ? reader.len : reader.pos + length;
      const message = createBaseGetSigningCommitmentsResponse();
      while (reader.pos < end) {
        const tag = reader.uint32();
        switch (tag >>> 3) {
          case 1: {
            if (tag !== 10) {
              break;
            }

            message.signingCommitments.push(
              RequestedSigningCommitments.decode(reader, reader.uint32()),
            );
            continue;
          }
        }
        if ((tag & 7) === 4 || tag === 0) {
          break;
        }
        reader.skip(tag & 7);
      }
      return message;
    },

    fromJSON(object: any): GetSigningCommitmentsResponse {
      return {
        signingCommitments: globalThis.Array.isArray(object?.signingCommitments)
          ? object.signingCommitments.map((e: any) =>
              RequestedSigningCommitments.fromJSON(e),
            )
          : [],
      };
    },

    toJSON(message: GetSigningCommitmentsResponse): unknown {
      const obj: any = {};
      if (message.signingCommitments?.length) {
        obj.signingCommitments = message.signingCommitments.map((e) =>
          RequestedSigningCommitments.toJSON(e),
        );
      }
      return obj;
    },

    create(
      base?: DeepPartial<GetSigningCommitmentsResponse>,
    ): GetSigningCommitmentsResponse {
      return GetSigningCommitmentsResponse.fromPartial(base ?? {});
    },
    fromPartial(
      object: DeepPartial<GetSigningCommitmentsResponse>,
    ): GetSigningCommitmentsResponse {
      const message = createBaseGetSigningCommitmentsResponse();
      message.signingCommitments =
        object.signingCommitments?.map((e) =>
          RequestedSigningCommitments.fromPartial(e),
        ) || [];
      return message;
    },
  };

function createBaseSigningCommitments(): SigningCommitments {
  return { signingCommitments: {} };
}

export const SigningCommitments: MessageFns<SigningCommitments> = {
  encode(
    message: SigningCommitments,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    Object.entries(message.signingCommitments).forEach(([key, value]) => {
      SigningCommitments_SigningCommitmentsEntry.encode(
        { key: key as any, value },
        writer.uint32(10).fork(),
      ).join();
    });
    return writer;
  },

  decode(
    input: BinaryReader | Uint8Array,
    length?: number,
  ): SigningCommitments {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSigningCommitments();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          const entry1 = SigningCommitments_SigningCommitmentsEntry.decode(
            reader,
            reader.uint32(),
          );
          if (entry1.value !== undefined) {
            message.signingCommitments[entry1.key] = entry1.value;
          }
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SigningCommitments {
    return {
      signingCommitments: isObject(object.signingCommitments)
        ? Object.entries(object.signingCommitments).reduce<{
            [key: string]: SigningCommitment;
          }>((acc, [key, value]) => {
            acc[key] = SigningCommitment.fromJSON(value);
            return acc;
          }, {})
        : {},
    };
  },

  toJSON(message: SigningCommitments): unknown {
    const obj: any = {};
    if (message.signingCommitments) {
      const entries = Object.entries(message.signingCommitments);
      if (entries.length > 0) {
        obj.signingCommitments = {};
        entries.forEach(([k, v]) => {
          obj.signingCommitments[k] = SigningCommitment.toJSON(v);
        });
      }
    }
    return obj;
  },

  create(base?: DeepPartial<SigningCommitments>): SigningCommitments {
    return SigningCommitments.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<SigningCommitments>): SigningCommitments {
    const message = createBaseSigningCommitments();
    message.signingCommitments = Object.entries(
      object.signingCommitments ?? {},
    ).reduce<{ [key: string]: SigningCommitment }>((acc, [key, value]) => {
      if (value !== undefined) {
        acc[key] = SigningCommitment.fromPartial(value);
      }
      return acc;
    }, {});
    return message;
  },
};

function createBaseSigningCommitments_SigningCommitmentsEntry(): SigningCommitments_SigningCommitmentsEntry {
  return { key: "", value: undefined };
}

export const SigningCommitments_SigningCommitmentsEntry: MessageFns<SigningCommitments_SigningCommitmentsEntry> =
  {
    encode(
      message: SigningCommitments_SigningCommitmentsEntry,
      writer: BinaryWriter = new BinaryWriter(),
    ): BinaryWriter {
      if (message.key !== "") {
        writer.uint32(10).string(message.key);
      }
      if (message.value !== undefined) {
        SigningCommitment.encode(
          message.value,
          writer.uint32(18).fork(),
        ).join();
      }
      return writer;
    },

    decode(
      input: BinaryReader | Uint8Array,
      length?: number,
    ): SigningCommitments_SigningCommitmentsEntry {
      const reader =
        input instanceof BinaryReader ? input : new BinaryReader(input);
      let end = length === undefined ? reader.len : reader.pos + length;
      const message = createBaseSigningCommitments_SigningCommitmentsEntry();
      while (reader.pos < end) {
        const tag = reader.uint32();
        switch (tag >>> 3) {
          case 1: {
            if (tag !== 10) {
              break;
            }

            message.key = reader.string();
            continue;
          }
          case 2: {
            if (tag !== 18) {
              break;
            }

            message.value = SigningCommitment.decode(reader, reader.uint32());
            continue;
          }
        }
        if ((tag & 7) === 4 || tag === 0) {
          break;
        }
        reader.skip(tag & 7);
      }
      return message;
    },

    fromJSON(object: any): SigningCommitments_SigningCommitmentsEntry {
      return {
        key: isSet(object.key) ? globalThis.String(object.key) : "",
        value: isSet(object.value)
          ? SigningCommitment.fromJSON(object.value)
          : undefined,
      };
    },

    toJSON(message: SigningCommitments_SigningCommitmentsEntry): unknown {
      const obj: any = {};
      if (message.key !== "") {
        obj.key = message.key;
      }
      if (message.value !== undefined) {
        obj.value = SigningCommitment.toJSON(message.value);
      }
      return obj;
    },

    create(
      base?: DeepPartial<SigningCommitments_SigningCommitmentsEntry>,
    ): SigningCommitments_SigningCommitmentsEntry {
      return SigningCommitments_SigningCommitmentsEntry.fromPartial(base ?? {});
    },
    fromPartial(
      object: DeepPartial<SigningCommitments_SigningCommitmentsEntry>,
    ): SigningCommitments_SigningCommitmentsEntry {
      const message = createBaseSigningCommitments_SigningCommitmentsEntry();
      message.key = object.key ?? "";
      message.value =
        object.value !== undefined && object.value !== null
          ? SigningCommitment.fromPartial(object.value)
          : undefined;
      return message;
    },
  };

function createBaseUserSignedRefund(): UserSignedRefund {
  return {
    nodeId: "",
    refundTx: new Uint8Array(0),
    userSignature: new Uint8Array(0),
    signingCommitments: undefined,
    userSignatureCommitment: undefined,
    network: 0,
  };
}

export const UserSignedRefund: MessageFns<UserSignedRefund> = {
  encode(
    message: UserSignedRefund,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.nodeId !== "") {
      writer.uint32(10).string(message.nodeId);
    }
    if (message.refundTx.length !== 0) {
      writer.uint32(18).bytes(message.refundTx);
    }
    if (message.userSignature.length !== 0) {
      writer.uint32(26).bytes(message.userSignature);
    }
    if (message.signingCommitments !== undefined) {
      SigningCommitments.encode(
        message.signingCommitments,
        writer.uint32(34).fork(),
      ).join();
    }
    if (message.userSignatureCommitment !== undefined) {
      SigningCommitment.encode(
        message.userSignatureCommitment,
        writer.uint32(42).fork(),
      ).join();
    }
    if (message.network !== 0) {
      writer.uint32(48).int32(message.network);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UserSignedRefund {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUserSignedRefund();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.nodeId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.refundTx = reader.bytes();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.userSignature = reader.bytes();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.signingCommitments = SigningCommitments.decode(
            reader,
            reader.uint32(),
          );
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.userSignatureCommitment = SigningCommitment.decode(
            reader,
            reader.uint32(),
          );
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.network = reader.int32() as any;
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UserSignedRefund {
    return {
      nodeId: isSet(object.nodeId) ? globalThis.String(object.nodeId) : "",
      refundTx: isSet(object.refundTx)
        ? bytesFromBase64(object.refundTx)
        : new Uint8Array(0),
      userSignature: isSet(object.userSignature)
        ? bytesFromBase64(object.userSignature)
        : new Uint8Array(0),
      signingCommitments: isSet(object.signingCommitments)
        ? SigningCommitments.fromJSON(object.signingCommitments)
        : undefined,
      userSignatureCommitment: isSet(object.userSignatureCommitment)
        ? SigningCommitment.fromJSON(object.userSignatureCommitment)
        : undefined,
      network: isSet(object.network) ? networkFromJSON(object.network) : 0,
    };
  },

  toJSON(message: UserSignedRefund): unknown {
    const obj: any = {};
    if (message.nodeId !== "") {
      obj.nodeId = message.nodeId;
    }
    if (message.refundTx.length !== 0) {
      obj.refundTx = base64FromBytes(message.refundTx);
    }
    if (message.userSignature.length !== 0) {
      obj.userSignature = base64FromBytes(message.userSignature);
    }
    if (message.signingCommitments !== undefined) {
      obj.signingCommitments = SigningCommitments.toJSON(
        message.signingCommitments,
      );
    }
    if (message.userSignatureCommitment !== undefined) {
      obj.userSignatureCommitment = SigningCommitment.toJSON(
        message.userSignatureCommitment,
      );
    }
    if (message.network !== 0) {
      obj.network = networkToJSON(message.network);
    }
    return obj;
  },

  create(base?: DeepPartial<UserSignedRefund>): UserSignedRefund {
    return UserSignedRefund.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<UserSignedRefund>): UserSignedRefund {
    const message = createBaseUserSignedRefund();
    message.nodeId = object.nodeId ?? "";
    message.refundTx = object.refundTx ?? new Uint8Array(0);
    message.userSignature = object.userSignature ?? new Uint8Array(0);
    message.signingCommitments =
      object.signingCommitments !== undefined &&
      object.signingCommitments !== null
        ? SigningCommitments.fromPartial(object.signingCommitments)
        : undefined;
    message.userSignatureCommitment =
      object.userSignatureCommitment !== undefined &&
      object.userSignatureCommitment !== null
        ? SigningCommitment.fromPartial(object.userSignatureCommitment)
        : undefined;
    message.network = object.network ?? 0;
    return message;
  },
};

function createBaseInvoiceAmountProof(): InvoiceAmountProof {
  return { bolt11Invoice: "" };
}

export const InvoiceAmountProof: MessageFns<InvoiceAmountProof> = {
  encode(
    message: InvoiceAmountProof,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.bolt11Invoice !== "") {
      writer.uint32(10).string(message.bolt11Invoice);
    }
    return writer;
  },

  decode(
    input: BinaryReader | Uint8Array,
    length?: number,
  ): InvoiceAmountProof {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseInvoiceAmountProof();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.bolt11Invoice = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): InvoiceAmountProof {
    return {
      bolt11Invoice: isSet(object.bolt11Invoice)
        ? globalThis.String(object.bolt11Invoice)
        : "",
    };
  },

  toJSON(message: InvoiceAmountProof): unknown {
    const obj: any = {};
    if (message.bolt11Invoice !== "") {
      obj.bolt11Invoice = message.bolt11Invoice;
    }
    return obj;
  },

  create(base?: DeepPartial<InvoiceAmountProof>): InvoiceAmountProof {
    return InvoiceAmountProof.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<InvoiceAmountProof>): InvoiceAmountProof {
    const message = createBaseInvoiceAmountProof();
    message.bolt11Invoice = object.bolt11Invoice ?? "";
    return message;
  },
};

function createBaseInvoiceAmount(): InvoiceAmount {
  return { valueSats: 0, invoiceAmountProof: undefined };
}

export const InvoiceAmount: MessageFns<InvoiceAmount> = {
  encode(
    message: InvoiceAmount,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.valueSats !== 0) {
      writer.uint32(8).uint64(message.valueSats);
    }
    if (message.invoiceAmountProof !== undefined) {
      InvoiceAmountProof.encode(
        message.invoiceAmountProof,
        writer.uint32(18).fork(),
      ).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): InvoiceAmount {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseInvoiceAmount();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.valueSats = longToNumber(reader.uint64());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.invoiceAmountProof = InvoiceAmountProof.decode(
            reader,
            reader.uint32(),
          );
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): InvoiceAmount {
    return {
      valueSats: isSet(object.valueSats)
        ? globalThis.Number(object.valueSats)
        : 0,
      invoiceAmountProof: isSet(object.invoiceAmountProof)
        ? InvoiceAmountProof.fromJSON(object.invoiceAmountProof)
        : undefined,
    };
  },

  toJSON(message: InvoiceAmount): unknown {
    const obj: any = {};
    if (message.valueSats !== 0) {
      obj.valueSats = Math.round(message.valueSats);
    }
    if (message.invoiceAmountProof !== undefined) {
      obj.invoiceAmountProof = InvoiceAmountProof.toJSON(
        message.invoiceAmountProof,
      );
    }
    return obj;
  },

  create(base?: DeepPartial<InvoiceAmount>): InvoiceAmount {
    return InvoiceAmount.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<InvoiceAmount>): InvoiceAmount {
    const message = createBaseInvoiceAmount();
    message.valueSats = object.valueSats ?? 0;
    message.invoiceAmountProof =
      object.invoiceAmountProof !== undefined &&
      object.invoiceAmountProof !== null
        ? InvoiceAmountProof.fromPartial(object.invoiceAmountProof)
        : undefined;
    return message;
  },
};

function createBaseInitiatePreimageSwapRequest(): InitiatePreimageSwapRequest {
  return {
    paymentHash: new Uint8Array(0),
    invoiceAmount: undefined,
    reason: 0,
    transfer: undefined,
    receiverIdentityPublicKey: new Uint8Array(0),
    feeSats: 0,
  };
}

export const InitiatePreimageSwapRequest: MessageFns<InitiatePreimageSwapRequest> =
  {
    encode(
      message: InitiatePreimageSwapRequest,
      writer: BinaryWriter = new BinaryWriter(),
    ): BinaryWriter {
      if (message.paymentHash.length !== 0) {
        writer.uint32(10).bytes(message.paymentHash);
      }
      if (message.invoiceAmount !== undefined) {
        InvoiceAmount.encode(
          message.invoiceAmount,
          writer.uint32(18).fork(),
        ).join();
      }
      if (message.reason !== 0) {
        writer.uint32(24).int32(message.reason);
      }
      if (message.transfer !== undefined) {
        StartUserSignedTransferRequest.encode(
          message.transfer,
          writer.uint32(34).fork(),
        ).join();
      }
      if (message.receiverIdentityPublicKey.length !== 0) {
        writer.uint32(42).bytes(message.receiverIdentityPublicKey);
      }
      if (message.feeSats !== 0) {
        writer.uint32(48).uint64(message.feeSats);
      }
      return writer;
    },

    decode(
      input: BinaryReader | Uint8Array,
      length?: number,
    ): InitiatePreimageSwapRequest {
      const reader =
        input instanceof BinaryReader ? input : new BinaryReader(input);
      let end = length === undefined ? reader.len : reader.pos + length;
      const message = createBaseInitiatePreimageSwapRequest();
      while (reader.pos < end) {
        const tag = reader.uint32();
        switch (tag >>> 3) {
          case 1: {
            if (tag !== 10) {
              break;
            }

            message.paymentHash = reader.bytes();
            continue;
          }
          case 2: {
            if (tag !== 18) {
              break;
            }

            message.invoiceAmount = InvoiceAmount.decode(
              reader,
              reader.uint32(),
            );
            continue;
          }
          case 3: {
            if (tag !== 24) {
              break;
            }

            message.reason = reader.int32() as any;
            continue;
          }
          case 4: {
            if (tag !== 34) {
              break;
            }

            message.transfer = StartUserSignedTransferRequest.decode(
              reader,
              reader.uint32(),
            );
            continue;
          }
          case 5: {
            if (tag !== 42) {
              break;
            }

            message.receiverIdentityPublicKey = reader.bytes();
            continue;
          }
          case 6: {
            if (tag !== 48) {
              break;
            }

            message.feeSats = longToNumber(reader.uint64());
            continue;
          }
        }
        if ((tag & 7) === 4 || tag === 0) {
          break;
        }
        reader.skip(tag & 7);
      }
      return message;
    },

    fromJSON(object: any): InitiatePreimageSwapRequest {
      return {
        paymentHash: isSet(object.paymentHash)
          ? bytesFromBase64(object.paymentHash)
          : new Uint8Array(0),
        invoiceAmount: isSet(object.invoiceAmount)
          ? InvoiceAmount.fromJSON(object.invoiceAmount)
          : undefined,
        reason: isSet(object.reason)
          ? initiatePreimageSwapRequest_ReasonFromJSON(object.reason)
          : 0,
        transfer: isSet(object.transfer)
          ? StartUserSignedTransferRequest.fromJSON(object.transfer)
          : undefined,
        receiverIdentityPublicKey: isSet(object.receiverIdentityPublicKey)
          ? bytesFromBase64(object.receiverIdentityPublicKey)
          : new Uint8Array(0),
        feeSats: isSet(object.feeSats) ? globalThis.Number(object.feeSats) : 0,
      };
    },

    toJSON(message: InitiatePreimageSwapRequest): unknown {
      const obj: any = {};
      if (message.paymentHash.length !== 0) {
        obj.paymentHash = base64FromBytes(message.paymentHash);
      }
      if (message.invoiceAmount !== undefined) {
        obj.invoiceAmount = InvoiceAmount.toJSON(message.invoiceAmount);
      }
      if (message.reason !== 0) {
        obj.reason = initiatePreimageSwapRequest_ReasonToJSON(message.reason);
      }
      if (message.transfer !== undefined) {
        obj.transfer = StartUserSignedTransferRequest.toJSON(message.transfer);
      }
      if (message.receiverIdentityPublicKey.length !== 0) {
        obj.receiverIdentityPublicKey = base64FromBytes(
          message.receiverIdentityPublicKey,
        );
      }
      if (message.feeSats !== 0) {
        obj.feeSats = Math.round(message.feeSats);
      }
      return obj;
    },

    create(
      base?: DeepPartial<InitiatePreimageSwapRequest>,
    ): InitiatePreimageSwapRequest {
      return InitiatePreimageSwapRequest.fromPartial(base ?? {});
    },
    fromPartial(
      object: DeepPartial<InitiatePreimageSwapRequest>,
    ): InitiatePreimageSwapRequest {
      const message = createBaseInitiatePreimageSwapRequest();
      message.paymentHash = object.paymentHash ?? new Uint8Array(0);
      message.invoiceAmount =
        object.invoiceAmount !== undefined && object.invoiceAmount !== null
          ? InvoiceAmount.fromPartial(object.invoiceAmount)
          : undefined;
      message.reason = object.reason ?? 0;
      message.transfer =
        object.transfer !== undefined && object.transfer !== null
          ? StartUserSignedTransferRequest.fromPartial(object.transfer)
          : undefined;
      message.receiverIdentityPublicKey =
        object.receiverIdentityPublicKey ?? new Uint8Array(0);
      message.feeSats = object.feeSats ?? 0;
      return message;
    },
  };

function createBaseInitiatePreimageSwapResponse(): InitiatePreimageSwapResponse {
  return { preimage: new Uint8Array(0), transfer: undefined };
}

export const InitiatePreimageSwapResponse: MessageFns<InitiatePreimageSwapResponse> =
  {
    encode(
      message: InitiatePreimageSwapResponse,
      writer: BinaryWriter = new BinaryWriter(),
    ): BinaryWriter {
      if (message.preimage.length !== 0) {
        writer.uint32(10).bytes(message.preimage);
      }
      if (message.transfer !== undefined) {
        Transfer.encode(message.transfer, writer.uint32(18).fork()).join();
      }
      return writer;
    },

    decode(
      input: BinaryReader | Uint8Array,
      length?: number,
    ): InitiatePreimageSwapResponse {
      const reader =
        input instanceof BinaryReader ? input : new BinaryReader(input);
      let end = length === undefined ? reader.len : reader.pos + length;
      const message = createBaseInitiatePreimageSwapResponse();
      while (reader.pos < end) {
        const tag = reader.uint32();
        switch (tag >>> 3) {
          case 1: {
            if (tag !== 10) {
              break;
            }

            message.preimage = reader.bytes();
            continue;
          }
          case 2: {
            if (tag !== 18) {
              break;
            }

            message.transfer = Transfer.decode(reader, reader.uint32());
            continue;
          }
        }
        if ((tag & 7) === 4 || tag === 0) {
          break;
        }
        reader.skip(tag & 7);
      }
      return message;
    },

    fromJSON(object: any): InitiatePreimageSwapResponse {
      return {
        preimage: isSet(object.preimage)
          ? bytesFromBase64(object.preimage)
          : new Uint8Array(0),
        transfer: isSet(object.transfer)
          ? Transfer.fromJSON(object.transfer)
          : undefined,
      };
    },

    toJSON(message: InitiatePreimageSwapResponse): unknown {
      const obj: any = {};
      if (message.preimage.length !== 0) {
        obj.preimage = base64FromBytes(message.preimage);
      }
      if (message.transfer !== undefined) {
        obj.transfer = Transfer.toJSON(message.transfer);
      }
      return obj;
    },

    create(
      base?: DeepPartial<InitiatePreimageSwapResponse>,
    ): InitiatePreimageSwapResponse {
      return InitiatePreimageSwapResponse.fromPartial(base ?? {});
    },
    fromPartial(
      object: DeepPartial<InitiatePreimageSwapResponse>,
    ): InitiatePreimageSwapResponse {
      const message = createBaseInitiatePreimageSwapResponse();
      message.preimage = object.preimage ?? new Uint8Array(0);
      message.transfer =
        object.transfer !== undefined && object.transfer !== null
          ? Transfer.fromPartial(object.transfer)
          : undefined;
      return message;
    },
  };

function createBaseOutPoint(): OutPoint {
  return { txid: new Uint8Array(0), vout: 0 };
}

export const OutPoint: MessageFns<OutPoint> = {
  encode(
    message: OutPoint,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.txid.length !== 0) {
      writer.uint32(10).bytes(message.txid);
    }
    if (message.vout !== 0) {
      writer.uint32(16).uint32(message.vout);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): OutPoint {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseOutPoint();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.txid = reader.bytes();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.vout = reader.uint32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): OutPoint {
    return {
      txid: isSet(object.txid)
        ? bytesFromBase64(object.txid)
        : new Uint8Array(0),
      vout: isSet(object.vout) ? globalThis.Number(object.vout) : 0,
    };
  },

  toJSON(message: OutPoint): unknown {
    const obj: any = {};
    if (message.txid.length !== 0) {
      obj.txid = base64FromBytes(message.txid);
    }
    if (message.vout !== 0) {
      obj.vout = Math.round(message.vout);
    }
    return obj;
  },

  create(base?: DeepPartial<OutPoint>): OutPoint {
    return OutPoint.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<OutPoint>): OutPoint {
    const message = createBaseOutPoint();
    message.txid = object.txid ?? new Uint8Array(0);
    message.vout = object.vout ?? 0;
    return message;
  },
};

function createBaseCooperativeExitRequest(): CooperativeExitRequest {
  return { transfer: undefined, exitId: "", exitTxid: new Uint8Array(0) };
}

export const CooperativeExitRequest: MessageFns<CooperativeExitRequest> = {
  encode(
    message: CooperativeExitRequest,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.transfer !== undefined) {
      StartTransferRequest.encode(
        message.transfer,
        writer.uint32(10).fork(),
      ).join();
    }
    if (message.exitId !== "") {
      writer.uint32(18).string(message.exitId);
    }
    if (message.exitTxid.length !== 0) {
      writer.uint32(26).bytes(message.exitTxid);
    }
    return writer;
  },

  decode(
    input: BinaryReader | Uint8Array,
    length?: number,
  ): CooperativeExitRequest {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCooperativeExitRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.transfer = StartTransferRequest.decode(
            reader,
            reader.uint32(),
          );
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.exitId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.exitTxid = reader.bytes();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CooperativeExitRequest {
    return {
      transfer: isSet(object.transfer)
        ? StartTransferRequest.fromJSON(object.transfer)
        : undefined,
      exitId: isSet(object.exitId) ? globalThis.String(object.exitId) : "",
      exitTxid: isSet(object.exitTxid)
        ? bytesFromBase64(object.exitTxid)
        : new Uint8Array(0),
    };
  },

  toJSON(message: CooperativeExitRequest): unknown {
    const obj: any = {};
    if (message.transfer !== undefined) {
      obj.transfer = StartTransferRequest.toJSON(message.transfer);
    }
    if (message.exitId !== "") {
      obj.exitId = message.exitId;
    }
    if (message.exitTxid.length !== 0) {
      obj.exitTxid = base64FromBytes(message.exitTxid);
    }
    return obj;
  },

  create(base?: DeepPartial<CooperativeExitRequest>): CooperativeExitRequest {
    return CooperativeExitRequest.fromPartial(base ?? {});
  },
  fromPartial(
    object: DeepPartial<CooperativeExitRequest>,
  ): CooperativeExitRequest {
    const message = createBaseCooperativeExitRequest();
    message.transfer =
      object.transfer !== undefined && object.transfer !== null
        ? StartTransferRequest.fromPartial(object.transfer)
        : undefined;
    message.exitId = object.exitId ?? "";
    message.exitTxid = object.exitTxid ?? new Uint8Array(0);
    return message;
  },
};

function createBaseCooperativeExitResponse(): CooperativeExitResponse {
  return { transfer: undefined, signingResults: [] };
}

export const CooperativeExitResponse: MessageFns<CooperativeExitResponse> = {
  encode(
    message: CooperativeExitResponse,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.transfer !== undefined) {
      Transfer.encode(message.transfer, writer.uint32(10).fork()).join();
    }
    for (const v of message.signingResults) {
      LeafRefundTxSigningResult.encode(v!, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(
    input: BinaryReader | Uint8Array,
    length?: number,
  ): CooperativeExitResponse {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCooperativeExitResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.transfer = Transfer.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.signingResults.push(
            LeafRefundTxSigningResult.decode(reader, reader.uint32()),
          );
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CooperativeExitResponse {
    return {
      transfer: isSet(object.transfer)
        ? Transfer.fromJSON(object.transfer)
        : undefined,
      signingResults: globalThis.Array.isArray(object?.signingResults)
        ? object.signingResults.map((e: any) =>
            LeafRefundTxSigningResult.fromJSON(e),
          )
        : [],
    };
  },

  toJSON(message: CooperativeExitResponse): unknown {
    const obj: any = {};
    if (message.transfer !== undefined) {
      obj.transfer = Transfer.toJSON(message.transfer);
    }
    if (message.signingResults?.length) {
      obj.signingResults = message.signingResults.map((e) =>
        LeafRefundTxSigningResult.toJSON(e),
      );
    }
    return obj;
  },

  create(base?: DeepPartial<CooperativeExitResponse>): CooperativeExitResponse {
    return CooperativeExitResponse.fromPartial(base ?? {});
  },
  fromPartial(
    object: DeepPartial<CooperativeExitResponse>,
  ): CooperativeExitResponse {
    const message = createBaseCooperativeExitResponse();
    message.transfer =
      object.transfer !== undefined && object.transfer !== null
        ? Transfer.fromPartial(object.transfer)
        : undefined;
    message.signingResults =
      object.signingResults?.map((e) =>
        LeafRefundTxSigningResult.fromPartial(e),
      ) || [];
    return message;
  },
};

function createBaseCounterLeafSwapRequest(): CounterLeafSwapRequest {
  return {
    transfer: undefined,
    swapId: "",
    adaptorPublicKey: new Uint8Array(0),
  };
}

export const CounterLeafSwapRequest: MessageFns<CounterLeafSwapRequest> = {
  encode(
    message: CounterLeafSwapRequest,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.transfer !== undefined) {
      StartTransferRequest.encode(
        message.transfer,
        writer.uint32(10).fork(),
      ).join();
    }
    if (message.swapId !== "") {
      writer.uint32(18).string(message.swapId);
    }
    if (message.adaptorPublicKey.length !== 0) {
      writer.uint32(26).bytes(message.adaptorPublicKey);
    }
    return writer;
  },

  decode(
    input: BinaryReader | Uint8Array,
    length?: number,
  ): CounterLeafSwapRequest {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCounterLeafSwapRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.transfer = StartTransferRequest.decode(
            reader,
            reader.uint32(),
          );
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.swapId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.adaptorPublicKey = reader.bytes();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CounterLeafSwapRequest {
    return {
      transfer: isSet(object.transfer)
        ? StartTransferRequest.fromJSON(object.transfer)
        : undefined,
      swapId: isSet(object.swapId) ? globalThis.String(object.swapId) : "",
      adaptorPublicKey: isSet(object.adaptorPublicKey)
        ? bytesFromBase64(object.adaptorPublicKey)
        : new Uint8Array(0),
    };
  },

  toJSON(message: CounterLeafSwapRequest): unknown {
    const obj: any = {};
    if (message.transfer !== undefined) {
      obj.transfer = StartTransferRequest.toJSON(message.transfer);
    }
    if (message.swapId !== "") {
      obj.swapId = message.swapId;
    }
    if (message.adaptorPublicKey.length !== 0) {
      obj.adaptorPublicKey = base64FromBytes(message.adaptorPublicKey);
    }
    return obj;
  },

  create(base?: DeepPartial<CounterLeafSwapRequest>): CounterLeafSwapRequest {
    return CounterLeafSwapRequest.fromPartial(base ?? {});
  },
  fromPartial(
    object: DeepPartial<CounterLeafSwapRequest>,
  ): CounterLeafSwapRequest {
    const message = createBaseCounterLeafSwapRequest();
    message.transfer =
      object.transfer !== undefined && object.transfer !== null
        ? StartTransferRequest.fromPartial(object.transfer)
        : undefined;
    message.swapId = object.swapId ?? "";
    message.adaptorPublicKey = object.adaptorPublicKey ?? new Uint8Array(0);
    return message;
  },
};

function createBaseCounterLeafSwapResponse(): CounterLeafSwapResponse {
  return { transfer: undefined, signingResults: [] };
}

export const CounterLeafSwapResponse: MessageFns<CounterLeafSwapResponse> = {
  encode(
    message: CounterLeafSwapResponse,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.transfer !== undefined) {
      Transfer.encode(message.transfer, writer.uint32(10).fork()).join();
    }
    for (const v of message.signingResults) {
      LeafRefundTxSigningResult.encode(v!, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(
    input: BinaryReader | Uint8Array,
    length?: number,
  ): CounterLeafSwapResponse {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCounterLeafSwapResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.transfer = Transfer.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.signingResults.push(
            LeafRefundTxSigningResult.decode(reader, reader.uint32()),
          );
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CounterLeafSwapResponse {
    return {
      transfer: isSet(object.transfer)
        ? Transfer.fromJSON(object.transfer)
        : undefined,
      signingResults: globalThis.Array.isArray(object?.signingResults)
        ? object.signingResults.map((e: any) =>
            LeafRefundTxSigningResult.fromJSON(e),
          )
        : [],
    };
  },

  toJSON(message: CounterLeafSwapResponse): unknown {
    const obj: any = {};
    if (message.transfer !== undefined) {
      obj.transfer = Transfer.toJSON(message.transfer);
    }
    if (message.signingResults?.length) {
      obj.signingResults = message.signingResults.map((e) =>
        LeafRefundTxSigningResult.toJSON(e),
      );
    }
    return obj;
  },

  create(base?: DeepPartial<CounterLeafSwapResponse>): CounterLeafSwapResponse {
    return CounterLeafSwapResponse.fromPartial(base ?? {});
  },
  fromPartial(
    object: DeepPartial<CounterLeafSwapResponse>,
  ): CounterLeafSwapResponse {
    const message = createBaseCounterLeafSwapResponse();
    message.transfer =
      object.transfer !== undefined && object.transfer !== null
        ? Transfer.fromPartial(object.transfer)
        : undefined;
    message.signingResults =
      object.signingResults?.map((e) =>
        LeafRefundTxSigningResult.fromPartial(e),
      ) || [];
    return message;
  },
};

function createBaseRefreshTimelockRequest(): RefreshTimelockRequest {
  return {
    leafId: "",
    ownerIdentityPublicKey: new Uint8Array(0),
    signingJobs: [],
  };
}

export const RefreshTimelockRequest: MessageFns<RefreshTimelockRequest> = {
  encode(
    message: RefreshTimelockRequest,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.leafId !== "") {
      writer.uint32(10).string(message.leafId);
    }
    if (message.ownerIdentityPublicKey.length !== 0) {
      writer.uint32(18).bytes(message.ownerIdentityPublicKey);
    }
    for (const v of message.signingJobs) {
      SigningJob.encode(v!, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(
    input: BinaryReader | Uint8Array,
    length?: number,
  ): RefreshTimelockRequest {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRefreshTimelockRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.leafId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.ownerIdentityPublicKey = reader.bytes();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.signingJobs.push(SigningJob.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RefreshTimelockRequest {
    return {
      leafId: isSet(object.leafId) ? globalThis.String(object.leafId) : "",
      ownerIdentityPublicKey: isSet(object.ownerIdentityPublicKey)
        ? bytesFromBase64(object.ownerIdentityPublicKey)
        : new Uint8Array(0),
      signingJobs: globalThis.Array.isArray(object?.signingJobs)
        ? object.signingJobs.map((e: any) => SigningJob.fromJSON(e))
        : [],
    };
  },

  toJSON(message: RefreshTimelockRequest): unknown {
    const obj: any = {};
    if (message.leafId !== "") {
      obj.leafId = message.leafId;
    }
    if (message.ownerIdentityPublicKey.length !== 0) {
      obj.ownerIdentityPublicKey = base64FromBytes(
        message.ownerIdentityPublicKey,
      );
    }
    if (message.signingJobs?.length) {
      obj.signingJobs = message.signingJobs.map((e) => SigningJob.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<RefreshTimelockRequest>): RefreshTimelockRequest {
    return RefreshTimelockRequest.fromPartial(base ?? {});
  },
  fromPartial(
    object: DeepPartial<RefreshTimelockRequest>,
  ): RefreshTimelockRequest {
    const message = createBaseRefreshTimelockRequest();
    message.leafId = object.leafId ?? "";
    message.ownerIdentityPublicKey =
      object.ownerIdentityPublicKey ?? new Uint8Array(0);
    message.signingJobs =
      object.signingJobs?.map((e) => SigningJob.fromPartial(e)) || [];
    return message;
  },
};

function createBaseRefreshTimelockSigningResult(): RefreshTimelockSigningResult {
  return { signingResult: undefined, verifyingKey: new Uint8Array(0) };
}

export const RefreshTimelockSigningResult: MessageFns<RefreshTimelockSigningResult> =
  {
    encode(
      message: RefreshTimelockSigningResult,
      writer: BinaryWriter = new BinaryWriter(),
    ): BinaryWriter {
      if (message.signingResult !== undefined) {
        SigningResult.encode(
          message.signingResult,
          writer.uint32(10).fork(),
        ).join();
      }
      if (message.verifyingKey.length !== 0) {
        writer.uint32(18).bytes(message.verifyingKey);
      }
      return writer;
    },

    decode(
      input: BinaryReader | Uint8Array,
      length?: number,
    ): RefreshTimelockSigningResult {
      const reader =
        input instanceof BinaryReader ? input : new BinaryReader(input);
      let end = length === undefined ? reader.len : reader.pos + length;
      const message = createBaseRefreshTimelockSigningResult();
      while (reader.pos < end) {
        const tag = reader.uint32();
        switch (tag >>> 3) {
          case 1: {
            if (tag !== 10) {
              break;
            }

            message.signingResult = SigningResult.decode(
              reader,
              reader.uint32(),
            );
            continue;
          }
          case 2: {
            if (tag !== 18) {
              break;
            }

            message.verifyingKey = reader.bytes();
            continue;
          }
        }
        if ((tag & 7) === 4 || tag === 0) {
          break;
        }
        reader.skip(tag & 7);
      }
      return message;
    },

    fromJSON(object: any): RefreshTimelockSigningResult {
      return {
        signingResult: isSet(object.signingResult)
          ? SigningResult.fromJSON(object.signingResult)
          : undefined,
        verifyingKey: isSet(object.verifyingKey)
          ? bytesFromBase64(object.verifyingKey)
          : new Uint8Array(0),
      };
    },

    toJSON(message: RefreshTimelockSigningResult): unknown {
      const obj: any = {};
      if (message.signingResult !== undefined) {
        obj.signingResult = SigningResult.toJSON(message.signingResult);
      }
      if (message.verifyingKey.length !== 0) {
        obj.verifyingKey = base64FromBytes(message.verifyingKey);
      }
      return obj;
    },

    create(
      base?: DeepPartial<RefreshTimelockSigningResult>,
    ): RefreshTimelockSigningResult {
      return RefreshTimelockSigningResult.fromPartial(base ?? {});
    },
    fromPartial(
      object: DeepPartial<RefreshTimelockSigningResult>,
    ): RefreshTimelockSigningResult {
      const message = createBaseRefreshTimelockSigningResult();
      message.signingResult =
        object.signingResult !== undefined && object.signingResult !== null
          ? SigningResult.fromPartial(object.signingResult)
          : undefined;
      message.verifyingKey = object.verifyingKey ?? new Uint8Array(0);
      return message;
    },
  };

function createBaseRefreshTimelockResponse(): RefreshTimelockResponse {
  return { signingResults: [] };
}

export const RefreshTimelockResponse: MessageFns<RefreshTimelockResponse> = {
  encode(
    message: RefreshTimelockResponse,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    for (const v of message.signingResults) {
      RefreshTimelockSigningResult.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(
    input: BinaryReader | Uint8Array,
    length?: number,
  ): RefreshTimelockResponse {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRefreshTimelockResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.signingResults.push(
            RefreshTimelockSigningResult.decode(reader, reader.uint32()),
          );
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RefreshTimelockResponse {
    return {
      signingResults: globalThis.Array.isArray(object?.signingResults)
        ? object.signingResults.map((e: any) =>
            RefreshTimelockSigningResult.fromJSON(e),
          )
        : [],
    };
  },

  toJSON(message: RefreshTimelockResponse): unknown {
    const obj: any = {};
    if (message.signingResults?.length) {
      obj.signingResults = message.signingResults.map((e) =>
        RefreshTimelockSigningResult.toJSON(e),
      );
    }
    return obj;
  },

  create(base?: DeepPartial<RefreshTimelockResponse>): RefreshTimelockResponse {
    return RefreshTimelockResponse.fromPartial(base ?? {});
  },
  fromPartial(
    object: DeepPartial<RefreshTimelockResponse>,
  ): RefreshTimelockResponse {
    const message = createBaseRefreshTimelockResponse();
    message.signingResults =
      object.signingResults?.map((e) =>
        RefreshTimelockSigningResult.fromPartial(e),
      ) || [];
    return message;
  },
};

function createBaseExtendLeafRequest(): ExtendLeafRequest {
  return {
    leafId: "",
    ownerIdentityPublicKey: new Uint8Array(0),
    nodeTxSigningJob: undefined,
    refundTxSigningJob: undefined,
  };
}

export const ExtendLeafRequest: MessageFns<ExtendLeafRequest> = {
  encode(
    message: ExtendLeafRequest,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.leafId !== "") {
      writer.uint32(10).string(message.leafId);
    }
    if (message.ownerIdentityPublicKey.length !== 0) {
      writer.uint32(18).bytes(message.ownerIdentityPublicKey);
    }
    if (message.nodeTxSigningJob !== undefined) {
      SigningJob.encode(
        message.nodeTxSigningJob,
        writer.uint32(26).fork(),
      ).join();
    }
    if (message.refundTxSigningJob !== undefined) {
      SigningJob.encode(
        message.refundTxSigningJob,
        writer.uint32(34).fork(),
      ).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ExtendLeafRequest {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseExtendLeafRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.leafId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.ownerIdentityPublicKey = reader.bytes();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.nodeTxSigningJob = SigningJob.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.refundTxSigningJob = SigningJob.decode(
            reader,
            reader.uint32(),
          );
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ExtendLeafRequest {
    return {
      leafId: isSet(object.leafId) ? globalThis.String(object.leafId) : "",
      ownerIdentityPublicKey: isSet(object.ownerIdentityPublicKey)
        ? bytesFromBase64(object.ownerIdentityPublicKey)
        : new Uint8Array(0),
      nodeTxSigningJob: isSet(object.nodeTxSigningJob)
        ? SigningJob.fromJSON(object.nodeTxSigningJob)
        : undefined,
      refundTxSigningJob: isSet(object.refundTxSigningJob)
        ? SigningJob.fromJSON(object.refundTxSigningJob)
        : undefined,
    };
  },

  toJSON(message: ExtendLeafRequest): unknown {
    const obj: any = {};
    if (message.leafId !== "") {
      obj.leafId = message.leafId;
    }
    if (message.ownerIdentityPublicKey.length !== 0) {
      obj.ownerIdentityPublicKey = base64FromBytes(
        message.ownerIdentityPublicKey,
      );
    }
    if (message.nodeTxSigningJob !== undefined) {
      obj.nodeTxSigningJob = SigningJob.toJSON(message.nodeTxSigningJob);
    }
    if (message.refundTxSigningJob !== undefined) {
      obj.refundTxSigningJob = SigningJob.toJSON(message.refundTxSigningJob);
    }
    return obj;
  },

  create(base?: DeepPartial<ExtendLeafRequest>): ExtendLeafRequest {
    return ExtendLeafRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ExtendLeafRequest>): ExtendLeafRequest {
    const message = createBaseExtendLeafRequest();
    message.leafId = object.leafId ?? "";
    message.ownerIdentityPublicKey =
      object.ownerIdentityPublicKey ?? new Uint8Array(0);
    message.nodeTxSigningJob =
      object.nodeTxSigningJob !== undefined && object.nodeTxSigningJob !== null
        ? SigningJob.fromPartial(object.nodeTxSigningJob)
        : undefined;
    message.refundTxSigningJob =
      object.refundTxSigningJob !== undefined &&
      object.refundTxSigningJob !== null
        ? SigningJob.fromPartial(object.refundTxSigningJob)
        : undefined;
    return message;
  },
};

function createBaseExtendLeafSigningResult(): ExtendLeafSigningResult {
  return { signingResult: undefined, verifyingKey: new Uint8Array(0) };
}

export const ExtendLeafSigningResult: MessageFns<ExtendLeafSigningResult> = {
  encode(
    message: ExtendLeafSigningResult,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.signingResult !== undefined) {
      SigningResult.encode(
        message.signingResult,
        writer.uint32(10).fork(),
      ).join();
    }
    if (message.verifyingKey.length !== 0) {
      writer.uint32(18).bytes(message.verifyingKey);
    }
    return writer;
  },

  decode(
    input: BinaryReader | Uint8Array,
    length?: number,
  ): ExtendLeafSigningResult {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseExtendLeafSigningResult();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.signingResult = SigningResult.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.verifyingKey = reader.bytes();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ExtendLeafSigningResult {
    return {
      signingResult: isSet(object.signingResult)
        ? SigningResult.fromJSON(object.signingResult)
        : undefined,
      verifyingKey: isSet(object.verifyingKey)
        ? bytesFromBase64(object.verifyingKey)
        : new Uint8Array(0),
    };
  },

  toJSON(message: ExtendLeafSigningResult): unknown {
    const obj: any = {};
    if (message.signingResult !== undefined) {
      obj.signingResult = SigningResult.toJSON(message.signingResult);
    }
    if (message.verifyingKey.length !== 0) {
      obj.verifyingKey = base64FromBytes(message.verifyingKey);
    }
    return obj;
  },

  create(base?: DeepPartial<ExtendLeafSigningResult>): ExtendLeafSigningResult {
    return ExtendLeafSigningResult.fromPartial(base ?? {});
  },
  fromPartial(
    object: DeepPartial<ExtendLeafSigningResult>,
  ): ExtendLeafSigningResult {
    const message = createBaseExtendLeafSigningResult();
    message.signingResult =
      object.signingResult !== undefined && object.signingResult !== null
        ? SigningResult.fromPartial(object.signingResult)
        : undefined;
    message.verifyingKey = object.verifyingKey ?? new Uint8Array(0);
    return message;
  },
};

function createBaseExtendLeafResponse(): ExtendLeafResponse {
  return {
    leafId: "",
    nodeTxSigningResult: undefined,
    refundTxSigningResult: undefined,
  };
}

export const ExtendLeafResponse: MessageFns<ExtendLeafResponse> = {
  encode(
    message: ExtendLeafResponse,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.leafId !== "") {
      writer.uint32(10).string(message.leafId);
    }
    if (message.nodeTxSigningResult !== undefined) {
      ExtendLeafSigningResult.encode(
        message.nodeTxSigningResult,
        writer.uint32(18).fork(),
      ).join();
    }
    if (message.refundTxSigningResult !== undefined) {
      ExtendLeafSigningResult.encode(
        message.refundTxSigningResult,
        writer.uint32(26).fork(),
      ).join();
    }
    return writer;
  },

  decode(
    input: BinaryReader | Uint8Array,
    length?: number,
  ): ExtendLeafResponse {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseExtendLeafResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.leafId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.nodeTxSigningResult = ExtendLeafSigningResult.decode(
            reader,
            reader.uint32(),
          );
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.refundTxSigningResult = ExtendLeafSigningResult.decode(
            reader,
            reader.uint32(),
          );
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ExtendLeafResponse {
    return {
      leafId: isSet(object.leafId) ? globalThis.String(object.leafId) : "",
      nodeTxSigningResult: isSet(object.nodeTxSigningResult)
        ? ExtendLeafSigningResult.fromJSON(object.nodeTxSigningResult)
        : undefined,
      refundTxSigningResult: isSet(object.refundTxSigningResult)
        ? ExtendLeafSigningResult.fromJSON(object.refundTxSigningResult)
        : undefined,
    };
  },

  toJSON(message: ExtendLeafResponse): unknown {
    const obj: any = {};
    if (message.leafId !== "") {
      obj.leafId = message.leafId;
    }
    if (message.nodeTxSigningResult !== undefined) {
      obj.nodeTxSigningResult = ExtendLeafSigningResult.toJSON(
        message.nodeTxSigningResult,
      );
    }
    if (message.refundTxSigningResult !== undefined) {
      obj.refundTxSigningResult = ExtendLeafSigningResult.toJSON(
        message.refundTxSigningResult,
      );
    }
    return obj;
  },

  create(base?: DeepPartial<ExtendLeafResponse>): ExtendLeafResponse {
    return ExtendLeafResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ExtendLeafResponse>): ExtendLeafResponse {
    const message = createBaseExtendLeafResponse();
    message.leafId = object.leafId ?? "";
    message.nodeTxSigningResult =
      object.nodeTxSigningResult !== undefined &&
      object.nodeTxSigningResult !== null
        ? ExtendLeafSigningResult.fromPartial(object.nodeTxSigningResult)
        : undefined;
    message.refundTxSigningResult =
      object.refundTxSigningResult !== undefined &&
      object.refundTxSigningResult !== null
        ? ExtendLeafSigningResult.fromPartial(object.refundTxSigningResult)
        : undefined;
    return message;
  },
};

function createBaseAddressRequestNode(): AddressRequestNode {
  return { userPublicKey: new Uint8Array(0), children: [] };
}

export const AddressRequestNode: MessageFns<AddressRequestNode> = {
  encode(
    message: AddressRequestNode,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.userPublicKey.length !== 0) {
      writer.uint32(10).bytes(message.userPublicKey);
    }
    for (const v of message.children) {
      AddressRequestNode.encode(v!, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(
    input: BinaryReader | Uint8Array,
    length?: number,
  ): AddressRequestNode {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAddressRequestNode();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.userPublicKey = reader.bytes();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.children.push(
            AddressRequestNode.decode(reader, reader.uint32()),
          );
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AddressRequestNode {
    return {
      userPublicKey: isSet(object.userPublicKey)
        ? bytesFromBase64(object.userPublicKey)
        : new Uint8Array(0),
      children: globalThis.Array.isArray(object?.children)
        ? object.children.map((e: any) => AddressRequestNode.fromJSON(e))
        : [],
    };
  },

  toJSON(message: AddressRequestNode): unknown {
    const obj: any = {};
    if (message.userPublicKey.length !== 0) {
      obj.userPublicKey = base64FromBytes(message.userPublicKey);
    }
    if (message.children?.length) {
      obj.children = message.children.map((e) => AddressRequestNode.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<AddressRequestNode>): AddressRequestNode {
    return AddressRequestNode.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<AddressRequestNode>): AddressRequestNode {
    const message = createBaseAddressRequestNode();
    message.userPublicKey = object.userPublicKey ?? new Uint8Array(0);
    message.children =
      object.children?.map((e) => AddressRequestNode.fromPartial(e)) || [];
    return message;
  },
};

function createBasePrepareTreeAddressRequest(): PrepareTreeAddressRequest {
  return {
    source: undefined,
    node: undefined,
    userIdentityPublicKey: new Uint8Array(0),
  };
}

export const PrepareTreeAddressRequest: MessageFns<PrepareTreeAddressRequest> =
  {
    encode(
      message: PrepareTreeAddressRequest,
      writer: BinaryWriter = new BinaryWriter(),
    ): BinaryWriter {
      switch (message.source?.$case) {
        case "parentNodeOutput":
          NodeOutput.encode(
            message.source.parentNodeOutput,
            writer.uint32(10).fork(),
          ).join();
          break;
        case "onChainUtxo":
          UTXO.encode(
            message.source.onChainUtxo,
            writer.uint32(18).fork(),
          ).join();
          break;
      }
      if (message.node !== undefined) {
        AddressRequestNode.encode(
          message.node,
          writer.uint32(26).fork(),
        ).join();
      }
      if (message.userIdentityPublicKey.length !== 0) {
        writer.uint32(34).bytes(message.userIdentityPublicKey);
      }
      return writer;
    },

    decode(
      input: BinaryReader | Uint8Array,
      length?: number,
    ): PrepareTreeAddressRequest {
      const reader =
        input instanceof BinaryReader ? input : new BinaryReader(input);
      let end = length === undefined ? reader.len : reader.pos + length;
      const message = createBasePrepareTreeAddressRequest();
      while (reader.pos < end) {
        const tag = reader.uint32();
        switch (tag >>> 3) {
          case 1: {
            if (tag !== 10) {
              break;
            }

            message.source = {
              $case: "parentNodeOutput",
              parentNodeOutput: NodeOutput.decode(reader, reader.uint32()),
            };
            continue;
          }
          case 2: {
            if (tag !== 18) {
              break;
            }

            message.source = {
              $case: "onChainUtxo",
              onChainUtxo: UTXO.decode(reader, reader.uint32()),
            };
            continue;
          }
          case 3: {
            if (tag !== 26) {
              break;
            }

            message.node = AddressRequestNode.decode(reader, reader.uint32());
            continue;
          }
          case 4: {
            if (tag !== 34) {
              break;
            }

            message.userIdentityPublicKey = reader.bytes();
            continue;
          }
        }
        if ((tag & 7) === 4 || tag === 0) {
          break;
        }
        reader.skip(tag & 7);
      }
      return message;
    },

    fromJSON(object: any): PrepareTreeAddressRequest {
      return {
        source: isSet(object.parentNodeOutput)
          ? {
              $case: "parentNodeOutput",
              parentNodeOutput: NodeOutput.fromJSON(object.parentNodeOutput),
            }
          : isSet(object.onChainUtxo)
            ? {
                $case: "onChainUtxo",
                onChainUtxo: UTXO.fromJSON(object.onChainUtxo),
              }
            : undefined,
        node: isSet(object.node)
          ? AddressRequestNode.fromJSON(object.node)
          : undefined,
        userIdentityPublicKey: isSet(object.userIdentityPublicKey)
          ? bytesFromBase64(object.userIdentityPublicKey)
          : new Uint8Array(0),
      };
    },

    toJSON(message: PrepareTreeAddressRequest): unknown {
      const obj: any = {};
      if (message.source?.$case === "parentNodeOutput") {
        obj.parentNodeOutput = NodeOutput.toJSON(
          message.source.parentNodeOutput,
        );
      } else if (message.source?.$case === "onChainUtxo") {
        obj.onChainUtxo = UTXO.toJSON(message.source.onChainUtxo);
      }
      if (message.node !== undefined) {
        obj.node = AddressRequestNode.toJSON(message.node);
      }
      if (message.userIdentityPublicKey.length !== 0) {
        obj.userIdentityPublicKey = base64FromBytes(
          message.userIdentityPublicKey,
        );
      }
      return obj;
    },

    create(
      base?: DeepPartial<PrepareTreeAddressRequest>,
    ): PrepareTreeAddressRequest {
      return PrepareTreeAddressRequest.fromPartial(base ?? {});
    },
    fromPartial(
      object: DeepPartial<PrepareTreeAddressRequest>,
    ): PrepareTreeAddressRequest {
      const message = createBasePrepareTreeAddressRequest();
      switch (object.source?.$case) {
        case "parentNodeOutput": {
          if (
            object.source?.parentNodeOutput !== undefined &&
            object.source?.parentNodeOutput !== null
          ) {
            message.source = {
              $case: "parentNodeOutput",
              parentNodeOutput: NodeOutput.fromPartial(
                object.source.parentNodeOutput,
              ),
            };
          }
          break;
        }
        case "onChainUtxo": {
          if (
            object.source?.onChainUtxo !== undefined &&
            object.source?.onChainUtxo !== null
          ) {
            message.source = {
              $case: "onChainUtxo",
              onChainUtxo: UTXO.fromPartial(object.source.onChainUtxo),
            };
          }
          break;
        }
      }
      message.node =
        object.node !== undefined && object.node !== null
          ? AddressRequestNode.fromPartial(object.node)
          : undefined;
      message.userIdentityPublicKey =
        object.userIdentityPublicKey ?? new Uint8Array(0);
      return message;
    },
  };

function createBaseAddressNode(): AddressNode {
  return { address: undefined, children: [] };
}

export const AddressNode: MessageFns<AddressNode> = {
  encode(
    message: AddressNode,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.address !== undefined) {
      Address.encode(message.address, writer.uint32(10).fork()).join();
    }
    for (const v of message.children) {
      AddressNode.encode(v!, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AddressNode {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAddressNode();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.address = Address.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.children.push(AddressNode.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AddressNode {
    return {
      address: isSet(object.address)
        ? Address.fromJSON(object.address)
        : undefined,
      children: globalThis.Array.isArray(object?.children)
        ? object.children.map((e: any) => AddressNode.fromJSON(e))
        : [],
    };
  },

  toJSON(message: AddressNode): unknown {
    const obj: any = {};
    if (message.address !== undefined) {
      obj.address = Address.toJSON(message.address);
    }
    if (message.children?.length) {
      obj.children = message.children.map((e) => AddressNode.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<AddressNode>): AddressNode {
    return AddressNode.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<AddressNode>): AddressNode {
    const message = createBaseAddressNode();
    message.address =
      object.address !== undefined && object.address !== null
        ? Address.fromPartial(object.address)
        : undefined;
    message.children =
      object.children?.map((e) => AddressNode.fromPartial(e)) || [];
    return message;
  },
};

function createBasePrepareTreeAddressResponse(): PrepareTreeAddressResponse {
  return { node: undefined };
}

export const PrepareTreeAddressResponse: MessageFns<PrepareTreeAddressResponse> =
  {
    encode(
      message: PrepareTreeAddressResponse,
      writer: BinaryWriter = new BinaryWriter(),
    ): BinaryWriter {
      if (message.node !== undefined) {
        AddressNode.encode(message.node, writer.uint32(10).fork()).join();
      }
      return writer;
    },

    decode(
      input: BinaryReader | Uint8Array,
      length?: number,
    ): PrepareTreeAddressResponse {
      const reader =
        input instanceof BinaryReader ? input : new BinaryReader(input);
      let end = length === undefined ? reader.len : reader.pos + length;
      const message = createBasePrepareTreeAddressResponse();
      while (reader.pos < end) {
        const tag = reader.uint32();
        switch (tag >>> 3) {
          case 1: {
            if (tag !== 10) {
              break;
            }

            message.node = AddressNode.decode(reader, reader.uint32());
            continue;
          }
        }
        if ((tag & 7) === 4 || tag === 0) {
          break;
        }
        reader.skip(tag & 7);
      }
      return message;
    },

    fromJSON(object: any): PrepareTreeAddressResponse {
      return {
        node: isSet(object.node)
          ? AddressNode.fromJSON(object.node)
          : undefined,
      };
    },

    toJSON(message: PrepareTreeAddressResponse): unknown {
      const obj: any = {};
      if (message.node !== undefined) {
        obj.node = AddressNode.toJSON(message.node);
      }
      return obj;
    },

    create(
      base?: DeepPartial<PrepareTreeAddressResponse>,
    ): PrepareTreeAddressResponse {
      return PrepareTreeAddressResponse.fromPartial(base ?? {});
    },
    fromPartial(
      object: DeepPartial<PrepareTreeAddressResponse>,
    ): PrepareTreeAddressResponse {
      const message = createBasePrepareTreeAddressResponse();
      message.node =
        object.node !== undefined && object.node !== null
          ? AddressNode.fromPartial(object.node)
          : undefined;
      return message;
    },
  };

function createBaseCreationNode(): CreationNode {
  return {
    nodeTxSigningJob: undefined,
    refundTxSigningJob: undefined,
    children: [],
  };
}

export const CreationNode: MessageFns<CreationNode> = {
  encode(
    message: CreationNode,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.nodeTxSigningJob !== undefined) {
      SigningJob.encode(
        message.nodeTxSigningJob,
        writer.uint32(10).fork(),
      ).join();
    }
    if (message.refundTxSigningJob !== undefined) {
      SigningJob.encode(
        message.refundTxSigningJob,
        writer.uint32(18).fork(),
      ).join();
    }
    for (const v of message.children) {
      CreationNode.encode(v!, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CreationNode {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreationNode();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.nodeTxSigningJob = SigningJob.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.refundTxSigningJob = SigningJob.decode(
            reader,
            reader.uint32(),
          );
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.children.push(CreationNode.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreationNode {
    return {
      nodeTxSigningJob: isSet(object.nodeTxSigningJob)
        ? SigningJob.fromJSON(object.nodeTxSigningJob)
        : undefined,
      refundTxSigningJob: isSet(object.refundTxSigningJob)
        ? SigningJob.fromJSON(object.refundTxSigningJob)
        : undefined,
      children: globalThis.Array.isArray(object?.children)
        ? object.children.map((e: any) => CreationNode.fromJSON(e))
        : [],
    };
  },

  toJSON(message: CreationNode): unknown {
    const obj: any = {};
    if (message.nodeTxSigningJob !== undefined) {
      obj.nodeTxSigningJob = SigningJob.toJSON(message.nodeTxSigningJob);
    }
    if (message.refundTxSigningJob !== undefined) {
      obj.refundTxSigningJob = SigningJob.toJSON(message.refundTxSigningJob);
    }
    if (message.children?.length) {
      obj.children = message.children.map((e) => CreationNode.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<CreationNode>): CreationNode {
    return CreationNode.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CreationNode>): CreationNode {
    const message = createBaseCreationNode();
    message.nodeTxSigningJob =
      object.nodeTxSigningJob !== undefined && object.nodeTxSigningJob !== null
        ? SigningJob.fromPartial(object.nodeTxSigningJob)
        : undefined;
    message.refundTxSigningJob =
      object.refundTxSigningJob !== undefined &&
      object.refundTxSigningJob !== null
        ? SigningJob.fromPartial(object.refundTxSigningJob)
        : undefined;
    message.children =
      object.children?.map((e) => CreationNode.fromPartial(e)) || [];
    return message;
  },
};

function createBaseCreateTreeRequest(): CreateTreeRequest {
  return {
    source: undefined,
    node: undefined,
    userIdentityPublicKey: new Uint8Array(0),
  };
}

export const CreateTreeRequest: MessageFns<CreateTreeRequest> = {
  encode(
    message: CreateTreeRequest,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    switch (message.source?.$case) {
      case "parentNodeOutput":
        NodeOutput.encode(
          message.source.parentNodeOutput,
          writer.uint32(10).fork(),
        ).join();
        break;
      case "onChainUtxo":
        UTXO.encode(
          message.source.onChainUtxo,
          writer.uint32(18).fork(),
        ).join();
        break;
    }
    if (message.node !== undefined) {
      CreationNode.encode(message.node, writer.uint32(26).fork()).join();
    }
    if (message.userIdentityPublicKey.length !== 0) {
      writer.uint32(34).bytes(message.userIdentityPublicKey);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CreateTreeRequest {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateTreeRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.source = {
            $case: "parentNodeOutput",
            parentNodeOutput: NodeOutput.decode(reader, reader.uint32()),
          };
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.source = {
            $case: "onChainUtxo",
            onChainUtxo: UTXO.decode(reader, reader.uint32()),
          };
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.node = CreationNode.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.userIdentityPublicKey = reader.bytes();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreateTreeRequest {
    return {
      source: isSet(object.parentNodeOutput)
        ? {
            $case: "parentNodeOutput",
            parentNodeOutput: NodeOutput.fromJSON(object.parentNodeOutput),
          }
        : isSet(object.onChainUtxo)
          ? {
              $case: "onChainUtxo",
              onChainUtxo: UTXO.fromJSON(object.onChainUtxo),
            }
          : undefined,
      node: isSet(object.node) ? CreationNode.fromJSON(object.node) : undefined,
      userIdentityPublicKey: isSet(object.userIdentityPublicKey)
        ? bytesFromBase64(object.userIdentityPublicKey)
        : new Uint8Array(0),
    };
  },

  toJSON(message: CreateTreeRequest): unknown {
    const obj: any = {};
    if (message.source?.$case === "parentNodeOutput") {
      obj.parentNodeOutput = NodeOutput.toJSON(message.source.parentNodeOutput);
    } else if (message.source?.$case === "onChainUtxo") {
      obj.onChainUtxo = UTXO.toJSON(message.source.onChainUtxo);
    }
    if (message.node !== undefined) {
      obj.node = CreationNode.toJSON(message.node);
    }
    if (message.userIdentityPublicKey.length !== 0) {
      obj.userIdentityPublicKey = base64FromBytes(
        message.userIdentityPublicKey,
      );
    }
    return obj;
  },

  create(base?: DeepPartial<CreateTreeRequest>): CreateTreeRequest {
    return CreateTreeRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CreateTreeRequest>): CreateTreeRequest {
    const message = createBaseCreateTreeRequest();
    switch (object.source?.$case) {
      case "parentNodeOutput": {
        if (
          object.source?.parentNodeOutput !== undefined &&
          object.source?.parentNodeOutput !== null
        ) {
          message.source = {
            $case: "parentNodeOutput",
            parentNodeOutput: NodeOutput.fromPartial(
              object.source.parentNodeOutput,
            ),
          };
        }
        break;
      }
      case "onChainUtxo": {
        if (
          object.source?.onChainUtxo !== undefined &&
          object.source?.onChainUtxo !== null
        ) {
          message.source = {
            $case: "onChainUtxo",
            onChainUtxo: UTXO.fromPartial(object.source.onChainUtxo),
          };
        }
        break;
      }
    }
    message.node =
      object.node !== undefined && object.node !== null
        ? CreationNode.fromPartial(object.node)
        : undefined;
    message.userIdentityPublicKey =
      object.userIdentityPublicKey ?? new Uint8Array(0);
    return message;
  },
};

function createBaseCreationResponseNode(): CreationResponseNode {
  return {
    nodeId: "",
    nodeTxSigningResult: undefined,
    refundTxSigningResult: undefined,
    children: [],
  };
}

export const CreationResponseNode: MessageFns<CreationResponseNode> = {
  encode(
    message: CreationResponseNode,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.nodeId !== "") {
      writer.uint32(10).string(message.nodeId);
    }
    if (message.nodeTxSigningResult !== undefined) {
      SigningResult.encode(
        message.nodeTxSigningResult,
        writer.uint32(18).fork(),
      ).join();
    }
    if (message.refundTxSigningResult !== undefined) {
      SigningResult.encode(
        message.refundTxSigningResult,
        writer.uint32(26).fork(),
      ).join();
    }
    for (const v of message.children) {
      CreationResponseNode.encode(v!, writer.uint32(34).fork()).join();
    }
    return writer;
  },

  decode(
    input: BinaryReader | Uint8Array,
    length?: number,
  ): CreationResponseNode {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreationResponseNode();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.nodeId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.nodeTxSigningResult = SigningResult.decode(
            reader,
            reader.uint32(),
          );
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.refundTxSigningResult = SigningResult.decode(
            reader,
            reader.uint32(),
          );
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.children.push(
            CreationResponseNode.decode(reader, reader.uint32()),
          );
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreationResponseNode {
    return {
      nodeId: isSet(object.nodeId) ? globalThis.String(object.nodeId) : "",
      nodeTxSigningResult: isSet(object.nodeTxSigningResult)
        ? SigningResult.fromJSON(object.nodeTxSigningResult)
        : undefined,
      refundTxSigningResult: isSet(object.refundTxSigningResult)
        ? SigningResult.fromJSON(object.refundTxSigningResult)
        : undefined,
      children: globalThis.Array.isArray(object?.children)
        ? object.children.map((e: any) => CreationResponseNode.fromJSON(e))
        : [],
    };
  },

  toJSON(message: CreationResponseNode): unknown {
    const obj: any = {};
    if (message.nodeId !== "") {
      obj.nodeId = message.nodeId;
    }
    if (message.nodeTxSigningResult !== undefined) {
      obj.nodeTxSigningResult = SigningResult.toJSON(
        message.nodeTxSigningResult,
      );
    }
    if (message.refundTxSigningResult !== undefined) {
      obj.refundTxSigningResult = SigningResult.toJSON(
        message.refundTxSigningResult,
      );
    }
    if (message.children?.length) {
      obj.children = message.children.map((e) =>
        CreationResponseNode.toJSON(e),
      );
    }
    return obj;
  },

  create(base?: DeepPartial<CreationResponseNode>): CreationResponseNode {
    return CreationResponseNode.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CreationResponseNode>): CreationResponseNode {
    const message = createBaseCreationResponseNode();
    message.nodeId = object.nodeId ?? "";
    message.nodeTxSigningResult =
      object.nodeTxSigningResult !== undefined &&
      object.nodeTxSigningResult !== null
        ? SigningResult.fromPartial(object.nodeTxSigningResult)
        : undefined;
    message.refundTxSigningResult =
      object.refundTxSigningResult !== undefined &&
      object.refundTxSigningResult !== null
        ? SigningResult.fromPartial(object.refundTxSigningResult)
        : undefined;
    message.children =
      object.children?.map((e) => CreationResponseNode.fromPartial(e)) || [];
    return message;
  },
};

function createBaseCreateTreeResponse(): CreateTreeResponse {
  return { node: undefined };
}

export const CreateTreeResponse: MessageFns<CreateTreeResponse> = {
  encode(
    message: CreateTreeResponse,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.node !== undefined) {
      CreationResponseNode.encode(
        message.node,
        writer.uint32(10).fork(),
      ).join();
    }
    return writer;
  },

  decode(
    input: BinaryReader | Uint8Array,
    length?: number,
  ): CreateTreeResponse {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateTreeResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.node = CreationResponseNode.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreateTreeResponse {
    return {
      node: isSet(object.node)
        ? CreationResponseNode.fromJSON(object.node)
        : undefined,
    };
  },

  toJSON(message: CreateTreeResponse): unknown {
    const obj: any = {};
    if (message.node !== undefined) {
      obj.node = CreationResponseNode.toJSON(message.node);
    }
    return obj;
  },

  create(base?: DeepPartial<CreateTreeResponse>): CreateTreeResponse {
    return CreateTreeResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CreateTreeResponse>): CreateTreeResponse {
    const message = createBaseCreateTreeResponse();
    message.node =
      object.node !== undefined && object.node !== null
        ? CreationResponseNode.fromPartial(object.node)
        : undefined;
    return message;
  },
};

function createBaseSigningOperatorInfo(): SigningOperatorInfo {
  return {
    index: 0,
    identifier: "",
    publicKey: new Uint8Array(0),
    address: "",
  };
}

export const SigningOperatorInfo: MessageFns<SigningOperatorInfo> = {
  encode(
    message: SigningOperatorInfo,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.index !== 0) {
      writer.uint32(8).uint64(message.index);
    }
    if (message.identifier !== "") {
      writer.uint32(18).string(message.identifier);
    }
    if (message.publicKey.length !== 0) {
      writer.uint32(26).bytes(message.publicKey);
    }
    if (message.address !== "") {
      writer.uint32(34).string(message.address);
    }
    return writer;
  },

  decode(
    input: BinaryReader | Uint8Array,
    length?: number,
  ): SigningOperatorInfo {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSigningOperatorInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.index = longToNumber(reader.uint64());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.identifier = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.publicKey = reader.bytes();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.address = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SigningOperatorInfo {
    return {
      index: isSet(object.index) ? globalThis.Number(object.index) : 0,
      identifier: isSet(object.identifier)
        ? globalThis.String(object.identifier)
        : "",
      publicKey: isSet(object.publicKey)
        ? bytesFromBase64(object.publicKey)
        : new Uint8Array(0),
      address: isSet(object.address) ? globalThis.String(object.address) : "",
    };
  },

  toJSON(message: SigningOperatorInfo): unknown {
    const obj: any = {};
    if (message.index !== 0) {
      obj.index = Math.round(message.index);
    }
    if (message.identifier !== "") {
      obj.identifier = message.identifier;
    }
    if (message.publicKey.length !== 0) {
      obj.publicKey = base64FromBytes(message.publicKey);
    }
    if (message.address !== "") {
      obj.address = message.address;
    }
    return obj;
  },

  create(base?: DeepPartial<SigningOperatorInfo>): SigningOperatorInfo {
    return SigningOperatorInfo.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<SigningOperatorInfo>): SigningOperatorInfo {
    const message = createBaseSigningOperatorInfo();
    message.index = object.index ?? 0;
    message.identifier = object.identifier ?? "";
    message.publicKey = object.publicKey ?? new Uint8Array(0);
    message.address = object.address ?? "";
    return message;
  },
};

function createBaseGetSigningOperatorListResponse(): GetSigningOperatorListResponse {
  return { signingOperators: {} };
}

export const GetSigningOperatorListResponse: MessageFns<GetSigningOperatorListResponse> =
  {
    encode(
      message: GetSigningOperatorListResponse,
      writer: BinaryWriter = new BinaryWriter(),
    ): BinaryWriter {
      Object.entries(message.signingOperators).forEach(([key, value]) => {
        GetSigningOperatorListResponse_SigningOperatorsEntry.encode(
          { key: key as any, value },
          writer.uint32(10).fork(),
        ).join();
      });
      return writer;
    },

    decode(
      input: BinaryReader | Uint8Array,
      length?: number,
    ): GetSigningOperatorListResponse {
      const reader =
        input instanceof BinaryReader ? input : new BinaryReader(input);
      let end = length === undefined ? reader.len : reader.pos + length;
      const message = createBaseGetSigningOperatorListResponse();
      while (reader.pos < end) {
        const tag = reader.uint32();
        switch (tag >>> 3) {
          case 1: {
            if (tag !== 10) {
              break;
            }

            const entry1 =
              GetSigningOperatorListResponse_SigningOperatorsEntry.decode(
                reader,
                reader.uint32(),
              );
            if (entry1.value !== undefined) {
              message.signingOperators[entry1.key] = entry1.value;
            }
            continue;
          }
        }
        if ((tag & 7) === 4 || tag === 0) {
          break;
        }
        reader.skip(tag & 7);
      }
      return message;
    },

    fromJSON(object: any): GetSigningOperatorListResponse {
      return {
        signingOperators: isObject(object.signingOperators)
          ? Object.entries(object.signingOperators).reduce<{
              [key: string]: SigningOperatorInfo;
            }>((acc, [key, value]) => {
              acc[key] = SigningOperatorInfo.fromJSON(value);
              return acc;
            }, {})
          : {},
      };
    },

    toJSON(message: GetSigningOperatorListResponse): unknown {
      const obj: any = {};
      if (message.signingOperators) {
        const entries = Object.entries(message.signingOperators);
        if (entries.length > 0) {
          obj.signingOperators = {};
          entries.forEach(([k, v]) => {
            obj.signingOperators[k] = SigningOperatorInfo.toJSON(v);
          });
        }
      }
      return obj;
    },

    create(
      base?: DeepPartial<GetSigningOperatorListResponse>,
    ): GetSigningOperatorListResponse {
      return GetSigningOperatorListResponse.fromPartial(base ?? {});
    },
    fromPartial(
      object: DeepPartial<GetSigningOperatorListResponse>,
    ): GetSigningOperatorListResponse {
      const message = createBaseGetSigningOperatorListResponse();
      message.signingOperators = Object.entries(
        object.signingOperators ?? {},
      ).reduce<{ [key: string]: SigningOperatorInfo }>((acc, [key, value]) => {
        if (value !== undefined) {
          acc[key] = SigningOperatorInfo.fromPartial(value);
        }
        return acc;
      }, {});
      return message;
    },
  };

function createBaseGetSigningOperatorListResponse_SigningOperatorsEntry(): GetSigningOperatorListResponse_SigningOperatorsEntry {
  return { key: "", value: undefined };
}

export const GetSigningOperatorListResponse_SigningOperatorsEntry: MessageFns<GetSigningOperatorListResponse_SigningOperatorsEntry> =
  {
    encode(
      message: GetSigningOperatorListResponse_SigningOperatorsEntry,
      writer: BinaryWriter = new BinaryWriter(),
    ): BinaryWriter {
      if (message.key !== "") {
        writer.uint32(10).string(message.key);
      }
      if (message.value !== undefined) {
        SigningOperatorInfo.encode(
          message.value,
          writer.uint32(18).fork(),
        ).join();
      }
      return writer;
    },

    decode(
      input: BinaryReader | Uint8Array,
      length?: number,
    ): GetSigningOperatorListResponse_SigningOperatorsEntry {
      const reader =
        input instanceof BinaryReader ? input : new BinaryReader(input);
      let end = length === undefined ? reader.len : reader.pos + length;
      const message =
        createBaseGetSigningOperatorListResponse_SigningOperatorsEntry();
      while (reader.pos < end) {
        const tag = reader.uint32();
        switch (tag >>> 3) {
          case 1: {
            if (tag !== 10) {
              break;
            }

            message.key = reader.string();
            continue;
          }
          case 2: {
            if (tag !== 18) {
              break;
            }

            message.value = SigningOperatorInfo.decode(reader, reader.uint32());
            continue;
          }
        }
        if ((tag & 7) === 4 || tag === 0) {
          break;
        }
        reader.skip(tag & 7);
      }
      return message;
    },

    fromJSON(
      object: any,
    ): GetSigningOperatorListResponse_SigningOperatorsEntry {
      return {
        key: isSet(object.key) ? globalThis.String(object.key) : "",
        value: isSet(object.value)
          ? SigningOperatorInfo.fromJSON(object.value)
          : undefined,
      };
    },

    toJSON(
      message: GetSigningOperatorListResponse_SigningOperatorsEntry,
    ): unknown {
      const obj: any = {};
      if (message.key !== "") {
        obj.key = message.key;
      }
      if (message.value !== undefined) {
        obj.value = SigningOperatorInfo.toJSON(message.value);
      }
      return obj;
    },

    create(
      base?: DeepPartial<GetSigningOperatorListResponse_SigningOperatorsEntry>,
    ): GetSigningOperatorListResponse_SigningOperatorsEntry {
      return GetSigningOperatorListResponse_SigningOperatorsEntry.fromPartial(
        base ?? {},
      );
    },
    fromPartial(
      object: DeepPartial<GetSigningOperatorListResponse_SigningOperatorsEntry>,
    ): GetSigningOperatorListResponse_SigningOperatorsEntry {
      const message =
        createBaseGetSigningOperatorListResponse_SigningOperatorsEntry();
      message.key = object.key ?? "";
      message.value =
        object.value !== undefined && object.value !== null
          ? SigningOperatorInfo.fromPartial(object.value)
          : undefined;
      return message;
    },
  };

function createBaseQueryUserSignedRefundsRequest(): QueryUserSignedRefundsRequest {
  return {
    paymentHash: new Uint8Array(0),
    identityPublicKey: new Uint8Array(0),
  };
}

export const QueryUserSignedRefundsRequest: MessageFns<QueryUserSignedRefundsRequest> =
  {
    encode(
      message: QueryUserSignedRefundsRequest,
      writer: BinaryWriter = new BinaryWriter(),
    ): BinaryWriter {
      if (message.paymentHash.length !== 0) {
        writer.uint32(10).bytes(message.paymentHash);
      }
      if (message.identityPublicKey.length !== 0) {
        writer.uint32(18).bytes(message.identityPublicKey);
      }
      return writer;
    },

    decode(
      input: BinaryReader | Uint8Array,
      length?: number,
    ): QueryUserSignedRefundsRequest {
      const reader =
        input instanceof BinaryReader ? input : new BinaryReader(input);
      let end = length === undefined ? reader.len : reader.pos + length;
      const message = createBaseQueryUserSignedRefundsRequest();
      while (reader.pos < end) {
        const tag = reader.uint32();
        switch (tag >>> 3) {
          case 1: {
            if (tag !== 10) {
              break;
            }

            message.paymentHash = reader.bytes();
            continue;
          }
          case 2: {
            if (tag !== 18) {
              break;
            }

            message.identityPublicKey = reader.bytes();
            continue;
          }
        }
        if ((tag & 7) === 4 || tag === 0) {
          break;
        }
        reader.skip(tag & 7);
      }
      return message;
    },

    fromJSON(object: any): QueryUserSignedRefundsRequest {
      return {
        paymentHash: isSet(object.paymentHash)
          ? bytesFromBase64(object.paymentHash)
          : new Uint8Array(0),
        identityPublicKey: isSet(object.identityPublicKey)
          ? bytesFromBase64(object.identityPublicKey)
          : new Uint8Array(0),
      };
    },

    toJSON(message: QueryUserSignedRefundsRequest): unknown {
      const obj: any = {};
      if (message.paymentHash.length !== 0) {
        obj.paymentHash = base64FromBytes(message.paymentHash);
      }
      if (message.identityPublicKey.length !== 0) {
        obj.identityPublicKey = base64FromBytes(message.identityPublicKey);
      }
      return obj;
    },

    create(
      base?: DeepPartial<QueryUserSignedRefundsRequest>,
    ): QueryUserSignedRefundsRequest {
      return QueryUserSignedRefundsRequest.fromPartial(base ?? {});
    },
    fromPartial(
      object: DeepPartial<QueryUserSignedRefundsRequest>,
    ): QueryUserSignedRefundsRequest {
      const message = createBaseQueryUserSignedRefundsRequest();
      message.paymentHash = object.paymentHash ?? new Uint8Array(0);
      message.identityPublicKey = object.identityPublicKey ?? new Uint8Array(0);
      return message;
    },
  };

function createBaseQueryUserSignedRefundsResponse(): QueryUserSignedRefundsResponse {
  return { userSignedRefunds: [] };
}

export const QueryUserSignedRefundsResponse: MessageFns<QueryUserSignedRefundsResponse> =
  {
    encode(
      message: QueryUserSignedRefundsResponse,
      writer: BinaryWriter = new BinaryWriter(),
    ): BinaryWriter {
      for (const v of message.userSignedRefunds) {
        UserSignedRefund.encode(v!, writer.uint32(10).fork()).join();
      }
      return writer;
    },

    decode(
      input: BinaryReader | Uint8Array,
      length?: number,
    ): QueryUserSignedRefundsResponse {
      const reader =
        input instanceof BinaryReader ? input : new BinaryReader(input);
      let end = length === undefined ? reader.len : reader.pos + length;
      const message = createBaseQueryUserSignedRefundsResponse();
      while (reader.pos < end) {
        const tag = reader.uint32();
        switch (tag >>> 3) {
          case 1: {
            if (tag !== 10) {
              break;
            }

            message.userSignedRefunds.push(
              UserSignedRefund.decode(reader, reader.uint32()),
            );
            continue;
          }
        }
        if ((tag & 7) === 4 || tag === 0) {
          break;
        }
        reader.skip(tag & 7);
      }
      return message;
    },

    fromJSON(object: any): QueryUserSignedRefundsResponse {
      return {
        userSignedRefunds: globalThis.Array.isArray(object?.userSignedRefunds)
          ? object.userSignedRefunds.map((e: any) =>
              UserSignedRefund.fromJSON(e),
            )
          : [],
      };
    },

    toJSON(message: QueryUserSignedRefundsResponse): unknown {
      const obj: any = {};
      if (message.userSignedRefunds?.length) {
        obj.userSignedRefunds = message.userSignedRefunds.map((e) =>
          UserSignedRefund.toJSON(e),
        );
      }
      return obj;
    },

    create(
      base?: DeepPartial<QueryUserSignedRefundsResponse>,
    ): QueryUserSignedRefundsResponse {
      return QueryUserSignedRefundsResponse.fromPartial(base ?? {});
    },
    fromPartial(
      object: DeepPartial<QueryUserSignedRefundsResponse>,
    ): QueryUserSignedRefundsResponse {
      const message = createBaseQueryUserSignedRefundsResponse();
      message.userSignedRefunds =
        object.userSignedRefunds?.map((e) => UserSignedRefund.fromPartial(e)) ||
        [];
      return message;
    },
  };

function createBaseProvidePreimageRequest(): ProvidePreimageRequest {
  return {
    paymentHash: new Uint8Array(0),
    preimage: new Uint8Array(0),
    identityPublicKey: new Uint8Array(0),
  };
}

export const ProvidePreimageRequest: MessageFns<ProvidePreimageRequest> = {
  encode(
    message: ProvidePreimageRequest,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.paymentHash.length !== 0) {
      writer.uint32(10).bytes(message.paymentHash);
    }
    if (message.preimage.length !== 0) {
      writer.uint32(18).bytes(message.preimage);
    }
    if (message.identityPublicKey.length !== 0) {
      writer.uint32(26).bytes(message.identityPublicKey);
    }
    return writer;
  },

  decode(
    input: BinaryReader | Uint8Array,
    length?: number,
  ): ProvidePreimageRequest {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseProvidePreimageRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.paymentHash = reader.bytes();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.preimage = reader.bytes();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.identityPublicKey = reader.bytes();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ProvidePreimageRequest {
    return {
      paymentHash: isSet(object.paymentHash)
        ? bytesFromBase64(object.paymentHash)
        : new Uint8Array(0),
      preimage: isSet(object.preimage)
        ? bytesFromBase64(object.preimage)
        : new Uint8Array(0),
      identityPublicKey: isSet(object.identityPublicKey)
        ? bytesFromBase64(object.identityPublicKey)
        : new Uint8Array(0),
    };
  },

  toJSON(message: ProvidePreimageRequest): unknown {
    const obj: any = {};
    if (message.paymentHash.length !== 0) {
      obj.paymentHash = base64FromBytes(message.paymentHash);
    }
    if (message.preimage.length !== 0) {
      obj.preimage = base64FromBytes(message.preimage);
    }
    if (message.identityPublicKey.length !== 0) {
      obj.identityPublicKey = base64FromBytes(message.identityPublicKey);
    }
    return obj;
  },

  create(base?: DeepPartial<ProvidePreimageRequest>): ProvidePreimageRequest {
    return ProvidePreimageRequest.fromPartial(base ?? {});
  },
  fromPartial(
    object: DeepPartial<ProvidePreimageRequest>,
  ): ProvidePreimageRequest {
    const message = createBaseProvidePreimageRequest();
    message.paymentHash = object.paymentHash ?? new Uint8Array(0);
    message.preimage = object.preimage ?? new Uint8Array(0);
    message.identityPublicKey = object.identityPublicKey ?? new Uint8Array(0);
    return message;
  },
};

function createBaseProvidePreimageResponse(): ProvidePreimageResponse {
  return { transfer: undefined };
}

export const ProvidePreimageResponse: MessageFns<ProvidePreimageResponse> = {
  encode(
    message: ProvidePreimageResponse,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.transfer !== undefined) {
      Transfer.encode(message.transfer, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(
    input: BinaryReader | Uint8Array,
    length?: number,
  ): ProvidePreimageResponse {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseProvidePreimageResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.transfer = Transfer.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ProvidePreimageResponse {
    return {
      transfer: isSet(object.transfer)
        ? Transfer.fromJSON(object.transfer)
        : undefined,
    };
  },

  toJSON(message: ProvidePreimageResponse): unknown {
    const obj: any = {};
    if (message.transfer !== undefined) {
      obj.transfer = Transfer.toJSON(message.transfer);
    }
    return obj;
  },

  create(base?: DeepPartial<ProvidePreimageResponse>): ProvidePreimageResponse {
    return ProvidePreimageResponse.fromPartial(base ?? {});
  },
  fromPartial(
    object: DeepPartial<ProvidePreimageResponse>,
  ): ProvidePreimageResponse {
    const message = createBaseProvidePreimageResponse();
    message.transfer =
      object.transfer !== undefined && object.transfer !== null
        ? Transfer.fromPartial(object.transfer)
        : undefined;
    return message;
  },
};

function createBaseReturnLightningPaymentRequest(): ReturnLightningPaymentRequest {
  return {
    paymentHash: new Uint8Array(0),
    userIdentityPublicKey: new Uint8Array(0),
  };
}

export const ReturnLightningPaymentRequest: MessageFns<ReturnLightningPaymentRequest> =
  {
    encode(
      message: ReturnLightningPaymentRequest,
      writer: BinaryWriter = new BinaryWriter(),
    ): BinaryWriter {
      if (message.paymentHash.length !== 0) {
        writer.uint32(10).bytes(message.paymentHash);
      }
      if (message.userIdentityPublicKey.length !== 0) {
        writer.uint32(18).bytes(message.userIdentityPublicKey);
      }
      return writer;
    },

    decode(
      input: BinaryReader | Uint8Array,
      length?: number,
    ): ReturnLightningPaymentRequest {
      const reader =
        input instanceof BinaryReader ? input : new BinaryReader(input);
      let end = length === undefined ? reader.len : reader.pos + length;
      const message = createBaseReturnLightningPaymentRequest();
      while (reader.pos < end) {
        const tag = reader.uint32();
        switch (tag >>> 3) {
          case 1: {
            if (tag !== 10) {
              break;
            }

            message.paymentHash = reader.bytes();
            continue;
          }
          case 2: {
            if (tag !== 18) {
              break;
            }

            message.userIdentityPublicKey = reader.bytes();
            continue;
          }
        }
        if ((tag & 7) === 4 || tag === 0) {
          break;
        }
        reader.skip(tag & 7);
      }
      return message;
    },

    fromJSON(object: any): ReturnLightningPaymentRequest {
      return {
        paymentHash: isSet(object.paymentHash)
          ? bytesFromBase64(object.paymentHash)
          : new Uint8Array(0),
        userIdentityPublicKey: isSet(object.userIdentityPublicKey)
          ? bytesFromBase64(object.userIdentityPublicKey)
          : new Uint8Array(0),
      };
    },

    toJSON(message: ReturnLightningPaymentRequest): unknown {
      const obj: any = {};
      if (message.paymentHash.length !== 0) {
        obj.paymentHash = base64FromBytes(message.paymentHash);
      }
      if (message.userIdentityPublicKey.length !== 0) {
        obj.userIdentityPublicKey = base64FromBytes(
          message.userIdentityPublicKey,
        );
      }
      return obj;
    },

    create(
      base?: DeepPartial<ReturnLightningPaymentRequest>,
    ): ReturnLightningPaymentRequest {
      return ReturnLightningPaymentRequest.fromPartial(base ?? {});
    },
    fromPartial(
      object: DeepPartial<ReturnLightningPaymentRequest>,
    ): ReturnLightningPaymentRequest {
      const message = createBaseReturnLightningPaymentRequest();
      message.paymentHash = object.paymentHash ?? new Uint8Array(0);
      message.userIdentityPublicKey =
        object.userIdentityPublicKey ?? new Uint8Array(0);
      return message;
    },
  };

function createBaseTreeNodeIds(): TreeNodeIds {
  return { nodeIds: [] };
}

export const TreeNodeIds: MessageFns<TreeNodeIds> = {
  encode(
    message: TreeNodeIds,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    for (const v of message.nodeIds) {
      writer.uint32(10).string(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TreeNodeIds {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTreeNodeIds();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.nodeIds.push(reader.string());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TreeNodeIds {
    return {
      nodeIds: globalThis.Array.isArray(object?.nodeIds)
        ? object.nodeIds.map((e: any) => globalThis.String(e))
        : [],
    };
  },

  toJSON(message: TreeNodeIds): unknown {
    const obj: any = {};
    if (message.nodeIds?.length) {
      obj.nodeIds = message.nodeIds;
    }
    return obj;
  },

  create(base?: DeepPartial<TreeNodeIds>): TreeNodeIds {
    return TreeNodeIds.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<TreeNodeIds>): TreeNodeIds {
    const message = createBaseTreeNodeIds();
    message.nodeIds = object.nodeIds?.map((e) => e) || [];
    return message;
  },
};

function createBaseQueryNodesRequest(): QueryNodesRequest {
  return { source: undefined, includeParents: false };
}

export const QueryNodesRequest: MessageFns<QueryNodesRequest> = {
  encode(
    message: QueryNodesRequest,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    switch (message.source?.$case) {
      case "ownerIdentityPubkey":
        writer.uint32(10).bytes(message.source.ownerIdentityPubkey);
        break;
      case "nodeIds":
        TreeNodeIds.encode(
          message.source.nodeIds,
          writer.uint32(18).fork(),
        ).join();
        break;
    }
    if (message.includeParents !== false) {
      writer.uint32(24).bool(message.includeParents);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): QueryNodesRequest {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryNodesRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.source = {
            $case: "ownerIdentityPubkey",
            ownerIdentityPubkey: reader.bytes(),
          };
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.source = {
            $case: "nodeIds",
            nodeIds: TreeNodeIds.decode(reader, reader.uint32()),
          };
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.includeParents = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): QueryNodesRequest {
    return {
      source: isSet(object.ownerIdentityPubkey)
        ? {
            $case: "ownerIdentityPubkey",
            ownerIdentityPubkey: bytesFromBase64(object.ownerIdentityPubkey),
          }
        : isSet(object.nodeIds)
          ? { $case: "nodeIds", nodeIds: TreeNodeIds.fromJSON(object.nodeIds) }
          : undefined,
      includeParents: isSet(object.includeParents)
        ? globalThis.Boolean(object.includeParents)
        : false,
    };
  },

  toJSON(message: QueryNodesRequest): unknown {
    const obj: any = {};
    if (message.source?.$case === "ownerIdentityPubkey") {
      obj.ownerIdentityPubkey = base64FromBytes(
        message.source.ownerIdentityPubkey,
      );
    } else if (message.source?.$case === "nodeIds") {
      obj.nodeIds = TreeNodeIds.toJSON(message.source.nodeIds);
    }
    if (message.includeParents !== false) {
      obj.includeParents = message.includeParents;
    }
    return obj;
  },

  create(base?: DeepPartial<QueryNodesRequest>): QueryNodesRequest {
    return QueryNodesRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<QueryNodesRequest>): QueryNodesRequest {
    const message = createBaseQueryNodesRequest();
    switch (object.source?.$case) {
      case "ownerIdentityPubkey": {
        if (
          object.source?.ownerIdentityPubkey !== undefined &&
          object.source?.ownerIdentityPubkey !== null
        ) {
          message.source = {
            $case: "ownerIdentityPubkey",
            ownerIdentityPubkey: object.source.ownerIdentityPubkey,
          };
        }
        break;
      }
      case "nodeIds": {
        if (
          object.source?.nodeIds !== undefined &&
          object.source?.nodeIds !== null
        ) {
          message.source = {
            $case: "nodeIds",
            nodeIds: TreeNodeIds.fromPartial(object.source.nodeIds),
          };
        }
        break;
      }
    }
    message.includeParents = object.includeParents ?? false;
    return message;
  },
};

function createBaseQueryNodesResponse(): QueryNodesResponse {
  return { nodes: {} };
}

export const QueryNodesResponse: MessageFns<QueryNodesResponse> = {
  encode(
    message: QueryNodesResponse,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    Object.entries(message.nodes).forEach(([key, value]) => {
      QueryNodesResponse_NodesEntry.encode(
        { key: key as any, value },
        writer.uint32(10).fork(),
      ).join();
    });
    return writer;
  },

  decode(
    input: BinaryReader | Uint8Array,
    length?: number,
  ): QueryNodesResponse {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryNodesResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          const entry1 = QueryNodesResponse_NodesEntry.decode(
            reader,
            reader.uint32(),
          );
          if (entry1.value !== undefined) {
            message.nodes[entry1.key] = entry1.value;
          }
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): QueryNodesResponse {
    return {
      nodes: isObject(object.nodes)
        ? Object.entries(object.nodes).reduce<{ [key: string]: TreeNode }>(
            (acc, [key, value]) => {
              acc[key] = TreeNode.fromJSON(value);
              return acc;
            },
            {},
          )
        : {},
    };
  },

  toJSON(message: QueryNodesResponse): unknown {
    const obj: any = {};
    if (message.nodes) {
      const entries = Object.entries(message.nodes);
      if (entries.length > 0) {
        obj.nodes = {};
        entries.forEach(([k, v]) => {
          obj.nodes[k] = TreeNode.toJSON(v);
        });
      }
    }
    return obj;
  },

  create(base?: DeepPartial<QueryNodesResponse>): QueryNodesResponse {
    return QueryNodesResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<QueryNodesResponse>): QueryNodesResponse {
    const message = createBaseQueryNodesResponse();
    message.nodes = Object.entries(object.nodes ?? {}).reduce<{
      [key: string]: TreeNode;
    }>((acc, [key, value]) => {
      if (value !== undefined) {
        acc[key] = TreeNode.fromPartial(value);
      }
      return acc;
    }, {});
    return message;
  },
};

function createBaseQueryNodesResponse_NodesEntry(): QueryNodesResponse_NodesEntry {
  return { key: "", value: undefined };
}

export const QueryNodesResponse_NodesEntry: MessageFns<QueryNodesResponse_NodesEntry> =
  {
    encode(
      message: QueryNodesResponse_NodesEntry,
      writer: BinaryWriter = new BinaryWriter(),
    ): BinaryWriter {
      if (message.key !== "") {
        writer.uint32(10).string(message.key);
      }
      if (message.value !== undefined) {
        TreeNode.encode(message.value, writer.uint32(18).fork()).join();
      }
      return writer;
    },

    decode(
      input: BinaryReader | Uint8Array,
      length?: number,
    ): QueryNodesResponse_NodesEntry {
      const reader =
        input instanceof BinaryReader ? input : new BinaryReader(input);
      let end = length === undefined ? reader.len : reader.pos + length;
      const message = createBaseQueryNodesResponse_NodesEntry();
      while (reader.pos < end) {
        const tag = reader.uint32();
        switch (tag >>> 3) {
          case 1: {
            if (tag !== 10) {
              break;
            }

            message.key = reader.string();
            continue;
          }
          case 2: {
            if (tag !== 18) {
              break;
            }

            message.value = TreeNode.decode(reader, reader.uint32());
            continue;
          }
        }
        if ((tag & 7) === 4 || tag === 0) {
          break;
        }
        reader.skip(tag & 7);
      }
      return message;
    },

    fromJSON(object: any): QueryNodesResponse_NodesEntry {
      return {
        key: isSet(object.key) ? globalThis.String(object.key) : "",
        value: isSet(object.value)
          ? TreeNode.fromJSON(object.value)
          : undefined,
      };
    },

    toJSON(message: QueryNodesResponse_NodesEntry): unknown {
      const obj: any = {};
      if (message.key !== "") {
        obj.key = message.key;
      }
      if (message.value !== undefined) {
        obj.value = TreeNode.toJSON(message.value);
      }
      return obj;
    },

    create(
      base?: DeepPartial<QueryNodesResponse_NodesEntry>,
    ): QueryNodesResponse_NodesEntry {
      return QueryNodesResponse_NodesEntry.fromPartial(base ?? {});
    },
    fromPartial(
      object: DeepPartial<QueryNodesResponse_NodesEntry>,
    ): QueryNodesResponse_NodesEntry {
      const message = createBaseQueryNodesResponse_NodesEntry();
      message.key = object.key ?? "";
      message.value =
        object.value !== undefined && object.value !== null
          ? TreeNode.fromPartial(object.value)
          : undefined;
      return message;
    },
  };

function createBaseCancelTransferRequest(): CancelTransferRequest {
  return { transferId: "", senderIdentityPublicKey: new Uint8Array(0) };
}

export const CancelTransferRequest: MessageFns<CancelTransferRequest> = {
  encode(
    message: CancelTransferRequest,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.transferId !== "") {
      writer.uint32(10).string(message.transferId);
    }
    if (message.senderIdentityPublicKey.length !== 0) {
      writer.uint32(18).bytes(message.senderIdentityPublicKey);
    }
    return writer;
  },

  decode(
    input: BinaryReader | Uint8Array,
    length?: number,
  ): CancelTransferRequest {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCancelTransferRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.transferId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.senderIdentityPublicKey = reader.bytes();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CancelTransferRequest {
    return {
      transferId: isSet(object.transferId)
        ? globalThis.String(object.transferId)
        : "",
      senderIdentityPublicKey: isSet(object.senderIdentityPublicKey)
        ? bytesFromBase64(object.senderIdentityPublicKey)
        : new Uint8Array(0),
    };
  },

  toJSON(message: CancelTransferRequest): unknown {
    const obj: any = {};
    if (message.transferId !== "") {
      obj.transferId = message.transferId;
    }
    if (message.senderIdentityPublicKey.length !== 0) {
      obj.senderIdentityPublicKey = base64FromBytes(
        message.senderIdentityPublicKey,
      );
    }
    return obj;
  },

  create(base?: DeepPartial<CancelTransferRequest>): CancelTransferRequest {
    return CancelTransferRequest.fromPartial(base ?? {});
  },
  fromPartial(
    object: DeepPartial<CancelTransferRequest>,
  ): CancelTransferRequest {
    const message = createBaseCancelTransferRequest();
    message.transferId = object.transferId ?? "";
    message.senderIdentityPublicKey =
      object.senderIdentityPublicKey ?? new Uint8Array(0);
    return message;
  },
};

function createBaseCancelTransferResponse(): CancelTransferResponse {
  return { transfer: undefined };
}

export const CancelTransferResponse: MessageFns<CancelTransferResponse> = {
  encode(
    message: CancelTransferResponse,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.transfer !== undefined) {
      Transfer.encode(message.transfer, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(
    input: BinaryReader | Uint8Array,
    length?: number,
  ): CancelTransferResponse {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCancelTransferResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.transfer = Transfer.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CancelTransferResponse {
    return {
      transfer: isSet(object.transfer)
        ? Transfer.fromJSON(object.transfer)
        : undefined,
    };
  },

  toJSON(message: CancelTransferResponse): unknown {
    const obj: any = {};
    if (message.transfer !== undefined) {
      obj.transfer = Transfer.toJSON(message.transfer);
    }
    return obj;
  },

  create(base?: DeepPartial<CancelTransferResponse>): CancelTransferResponse {
    return CancelTransferResponse.fromPartial(base ?? {});
  },
  fromPartial(
    object: DeepPartial<CancelTransferResponse>,
  ): CancelTransferResponse {
    const message = createBaseCancelTransferResponse();
    message.transfer =
      object.transfer !== undefined && object.transfer !== null
        ? Transfer.fromPartial(object.transfer)
        : undefined;
    return message;
  },
};

function createBaseQueryUnusedDepositAddressesRequest(): QueryUnusedDepositAddressesRequest {
  return { identityPublicKey: new Uint8Array(0) };
}

export const QueryUnusedDepositAddressesRequest: MessageFns<QueryUnusedDepositAddressesRequest> =
  {
    encode(
      message: QueryUnusedDepositAddressesRequest,
      writer: BinaryWriter = new BinaryWriter(),
    ): BinaryWriter {
      if (message.identityPublicKey.length !== 0) {
        writer.uint32(10).bytes(message.identityPublicKey);
      }
      return writer;
    },

    decode(
      input: BinaryReader | Uint8Array,
      length?: number,
    ): QueryUnusedDepositAddressesRequest {
      const reader =
        input instanceof BinaryReader ? input : new BinaryReader(input);
      let end = length === undefined ? reader.len : reader.pos + length;
      const message = createBaseQueryUnusedDepositAddressesRequest();
      while (reader.pos < end) {
        const tag = reader.uint32();
        switch (tag >>> 3) {
          case 1: {
            if (tag !== 10) {
              break;
            }

            message.identityPublicKey = reader.bytes();
            continue;
          }
        }
        if ((tag & 7) === 4 || tag === 0) {
          break;
        }
        reader.skip(tag & 7);
      }
      return message;
    },

    fromJSON(object: any): QueryUnusedDepositAddressesRequest {
      return {
        identityPublicKey: isSet(object.identityPublicKey)
          ? bytesFromBase64(object.identityPublicKey)
          : new Uint8Array(0),
      };
    },

    toJSON(message: QueryUnusedDepositAddressesRequest): unknown {
      const obj: any = {};
      if (message.identityPublicKey.length !== 0) {
        obj.identityPublicKey = base64FromBytes(message.identityPublicKey);
      }
      return obj;
    },

    create(
      base?: DeepPartial<QueryUnusedDepositAddressesRequest>,
    ): QueryUnusedDepositAddressesRequest {
      return QueryUnusedDepositAddressesRequest.fromPartial(base ?? {});
    },
    fromPartial(
      object: DeepPartial<QueryUnusedDepositAddressesRequest>,
    ): QueryUnusedDepositAddressesRequest {
      const message = createBaseQueryUnusedDepositAddressesRequest();
      message.identityPublicKey = object.identityPublicKey ?? new Uint8Array(0);
      return message;
    },
  };

function createBaseDepositAddressQueryResult(): DepositAddressQueryResult {
  return {
    depositAddress: "",
    userSigningPublicKey: new Uint8Array(0),
    verifyingPublicKey: new Uint8Array(0),
    leafId: undefined,
  };
}

export const DepositAddressQueryResult: MessageFns<DepositAddressQueryResult> =
  {
    encode(
      message: DepositAddressQueryResult,
      writer: BinaryWriter = new BinaryWriter(),
    ): BinaryWriter {
      if (message.depositAddress !== "") {
        writer.uint32(10).string(message.depositAddress);
      }
      if (message.userSigningPublicKey.length !== 0) {
        writer.uint32(18).bytes(message.userSigningPublicKey);
      }
      if (message.verifyingPublicKey.length !== 0) {
        writer.uint32(26).bytes(message.verifyingPublicKey);
      }
      if (message.leafId !== undefined) {
        writer.uint32(34).string(message.leafId);
      }
      return writer;
    },

    decode(
      input: BinaryReader | Uint8Array,
      length?: number,
    ): DepositAddressQueryResult {
      const reader =
        input instanceof BinaryReader ? input : new BinaryReader(input);
      let end = length === undefined ? reader.len : reader.pos + length;
      const message = createBaseDepositAddressQueryResult();
      while (reader.pos < end) {
        const tag = reader.uint32();
        switch (tag >>> 3) {
          case 1: {
            if (tag !== 10) {
              break;
            }

            message.depositAddress = reader.string();
            continue;
          }
          case 2: {
            if (tag !== 18) {
              break;
            }

            message.userSigningPublicKey = reader.bytes();
            continue;
          }
          case 3: {
            if (tag !== 26) {
              break;
            }

            message.verifyingPublicKey = reader.bytes();
            continue;
          }
          case 4: {
            if (tag !== 34) {
              break;
            }

            message.leafId = reader.string();
            continue;
          }
        }
        if ((tag & 7) === 4 || tag === 0) {
          break;
        }
        reader.skip(tag & 7);
      }
      return message;
    },

    fromJSON(object: any): DepositAddressQueryResult {
      return {
        depositAddress: isSet(object.depositAddress)
          ? globalThis.String(object.depositAddress)
          : "",
        userSigningPublicKey: isSet(object.userSigningPublicKey)
          ? bytesFromBase64(object.userSigningPublicKey)
          : new Uint8Array(0),
        verifyingPublicKey: isSet(object.verifyingPublicKey)
          ? bytesFromBase64(object.verifyingPublicKey)
          : new Uint8Array(0),
        leafId: isSet(object.leafId)
          ? globalThis.String(object.leafId)
          : undefined,
      };
    },

    toJSON(message: DepositAddressQueryResult): unknown {
      const obj: any = {};
      if (message.depositAddress !== "") {
        obj.depositAddress = message.depositAddress;
      }
      if (message.userSigningPublicKey.length !== 0) {
        obj.userSigningPublicKey = base64FromBytes(
          message.userSigningPublicKey,
        );
      }
      if (message.verifyingPublicKey.length !== 0) {
        obj.verifyingPublicKey = base64FromBytes(message.verifyingPublicKey);
      }
      if (message.leafId !== undefined) {
        obj.leafId = message.leafId;
      }
      return obj;
    },

    create(
      base?: DeepPartial<DepositAddressQueryResult>,
    ): DepositAddressQueryResult {
      return DepositAddressQueryResult.fromPartial(base ?? {});
    },
    fromPartial(
      object: DeepPartial<DepositAddressQueryResult>,
    ): DepositAddressQueryResult {
      const message = createBaseDepositAddressQueryResult();
      message.depositAddress = object.depositAddress ?? "";
      message.userSigningPublicKey =
        object.userSigningPublicKey ?? new Uint8Array(0);
      message.verifyingPublicKey =
        object.verifyingPublicKey ?? new Uint8Array(0);
      message.leafId = object.leafId ?? undefined;
      return message;
    },
  };

function createBaseQueryUnusedDepositAddressesResponse(): QueryUnusedDepositAddressesResponse {
  return { depositAddresses: [] };
}

export const QueryUnusedDepositAddressesResponse: MessageFns<QueryUnusedDepositAddressesResponse> =
  {
    encode(
      message: QueryUnusedDepositAddressesResponse,
      writer: BinaryWriter = new BinaryWriter(),
    ): BinaryWriter {
      for (const v of message.depositAddresses) {
        DepositAddressQueryResult.encode(v!, writer.uint32(10).fork()).join();
      }
      return writer;
    },

    decode(
      input: BinaryReader | Uint8Array,
      length?: number,
    ): QueryUnusedDepositAddressesResponse {
      const reader =
        input instanceof BinaryReader ? input : new BinaryReader(input);
      let end = length === undefined ? reader.len : reader.pos + length;
      const message = createBaseQueryUnusedDepositAddressesResponse();
      while (reader.pos < end) {
        const tag = reader.uint32();
        switch (tag >>> 3) {
          case 1: {
            if (tag !== 10) {
              break;
            }

            message.depositAddresses.push(
              DepositAddressQueryResult.decode(reader, reader.uint32()),
            );
            continue;
          }
        }
        if ((tag & 7) === 4 || tag === 0) {
          break;
        }
        reader.skip(tag & 7);
      }
      return message;
    },

    fromJSON(object: any): QueryUnusedDepositAddressesResponse {
      return {
        depositAddresses: globalThis.Array.isArray(object?.depositAddresses)
          ? object.depositAddresses.map((e: any) =>
              DepositAddressQueryResult.fromJSON(e),
            )
          : [],
      };
    },

    toJSON(message: QueryUnusedDepositAddressesResponse): unknown {
      const obj: any = {};
      if (message.depositAddresses?.length) {
        obj.depositAddresses = message.depositAddresses.map((e) =>
          DepositAddressQueryResult.toJSON(e),
        );
      }
      return obj;
    },

    create(
      base?: DeepPartial<QueryUnusedDepositAddressesResponse>,
    ): QueryUnusedDepositAddressesResponse {
      return QueryUnusedDepositAddressesResponse.fromPartial(base ?? {});
    },
    fromPartial(
      object: DeepPartial<QueryUnusedDepositAddressesResponse>,
    ): QueryUnusedDepositAddressesResponse {
      const message = createBaseQueryUnusedDepositAddressesResponse();
      message.depositAddresses =
        object.depositAddresses?.map((e) =>
          DepositAddressQueryResult.fromPartial(e),
        ) || [];
      return message;
    },
  };

function createBaseQueryBalanceRequest(): QueryBalanceRequest {
  return { identityPublicKey: new Uint8Array(0) };
}

export const QueryBalanceRequest: MessageFns<QueryBalanceRequest> = {
  encode(
    message: QueryBalanceRequest,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.identityPublicKey.length !== 0) {
      writer.uint32(10).bytes(message.identityPublicKey);
    }
    return writer;
  },

  decode(
    input: BinaryReader | Uint8Array,
    length?: number,
  ): QueryBalanceRequest {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryBalanceRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.identityPublicKey = reader.bytes();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): QueryBalanceRequest {
    return {
      identityPublicKey: isSet(object.identityPublicKey)
        ? bytesFromBase64(object.identityPublicKey)
        : new Uint8Array(0),
    };
  },

  toJSON(message: QueryBalanceRequest): unknown {
    const obj: any = {};
    if (message.identityPublicKey.length !== 0) {
      obj.identityPublicKey = base64FromBytes(message.identityPublicKey);
    }
    return obj;
  },

  create(base?: DeepPartial<QueryBalanceRequest>): QueryBalanceRequest {
    return QueryBalanceRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<QueryBalanceRequest>): QueryBalanceRequest {
    const message = createBaseQueryBalanceRequest();
    message.identityPublicKey = object.identityPublicKey ?? new Uint8Array(0);
    return message;
  },
};

function createBaseQueryBalanceResponse(): QueryBalanceResponse {
  return { balance: 0, nodeBalances: {} };
}

export const QueryBalanceResponse: MessageFns<QueryBalanceResponse> = {
  encode(
    message: QueryBalanceResponse,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.balance !== 0) {
      writer.uint32(8).uint64(message.balance);
    }
    Object.entries(message.nodeBalances).forEach(([key, value]) => {
      QueryBalanceResponse_NodeBalancesEntry.encode(
        { key: key as any, value },
        writer.uint32(18).fork(),
      ).join();
    });
    return writer;
  },

  decode(
    input: BinaryReader | Uint8Array,
    length?: number,
  ): QueryBalanceResponse {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryBalanceResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.balance = longToNumber(reader.uint64());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          const entry2 = QueryBalanceResponse_NodeBalancesEntry.decode(
            reader,
            reader.uint32(),
          );
          if (entry2.value !== undefined) {
            message.nodeBalances[entry2.key] = entry2.value;
          }
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): QueryBalanceResponse {
    return {
      balance: isSet(object.balance) ? globalThis.Number(object.balance) : 0,
      nodeBalances: isObject(object.nodeBalances)
        ? Object.entries(object.nodeBalances).reduce<{ [key: string]: number }>(
            (acc, [key, value]) => {
              acc[key] = Number(value);
              return acc;
            },
            {},
          )
        : {},
    };
  },

  toJSON(message: QueryBalanceResponse): unknown {
    const obj: any = {};
    if (message.balance !== 0) {
      obj.balance = Math.round(message.balance);
    }
    if (message.nodeBalances) {
      const entries = Object.entries(message.nodeBalances);
      if (entries.length > 0) {
        obj.nodeBalances = {};
        entries.forEach(([k, v]) => {
          obj.nodeBalances[k] = Math.round(v);
        });
      }
    }
    return obj;
  },

  create(base?: DeepPartial<QueryBalanceResponse>): QueryBalanceResponse {
    return QueryBalanceResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<QueryBalanceResponse>): QueryBalanceResponse {
    const message = createBaseQueryBalanceResponse();
    message.balance = object.balance ?? 0;
    message.nodeBalances = Object.entries(object.nodeBalances ?? {}).reduce<{
      [key: string]: number;
    }>((acc, [key, value]) => {
      if (value !== undefined) {
        acc[key] = globalThis.Number(value);
      }
      return acc;
    }, {});
    return message;
  },
};

function createBaseQueryBalanceResponse_NodeBalancesEntry(): QueryBalanceResponse_NodeBalancesEntry {
  return { key: "", value: 0 };
}

export const QueryBalanceResponse_NodeBalancesEntry: MessageFns<QueryBalanceResponse_NodeBalancesEntry> =
  {
    encode(
      message: QueryBalanceResponse_NodeBalancesEntry,
      writer: BinaryWriter = new BinaryWriter(),
    ): BinaryWriter {
      if (message.key !== "") {
        writer.uint32(10).string(message.key);
      }
      if (message.value !== 0) {
        writer.uint32(16).uint64(message.value);
      }
      return writer;
    },

    decode(
      input: BinaryReader | Uint8Array,
      length?: number,
    ): QueryBalanceResponse_NodeBalancesEntry {
      const reader =
        input instanceof BinaryReader ? input : new BinaryReader(input);
      let end = length === undefined ? reader.len : reader.pos + length;
      const message = createBaseQueryBalanceResponse_NodeBalancesEntry();
      while (reader.pos < end) {
        const tag = reader.uint32();
        switch (tag >>> 3) {
          case 1: {
            if (tag !== 10) {
              break;
            }

            message.key = reader.string();
            continue;
          }
          case 2: {
            if (tag !== 16) {
              break;
            }

            message.value = longToNumber(reader.uint64());
            continue;
          }
        }
        if ((tag & 7) === 4 || tag === 0) {
          break;
        }
        reader.skip(tag & 7);
      }
      return message;
    },

    fromJSON(object: any): QueryBalanceResponse_NodeBalancesEntry {
      return {
        key: isSet(object.key) ? globalThis.String(object.key) : "",
        value: isSet(object.value) ? globalThis.Number(object.value) : 0,
      };
    },

    toJSON(message: QueryBalanceResponse_NodeBalancesEntry): unknown {
      const obj: any = {};
      if (message.key !== "") {
        obj.key = message.key;
      }
      if (message.value !== 0) {
        obj.value = Math.round(message.value);
      }
      return obj;
    },

    create(
      base?: DeepPartial<QueryBalanceResponse_NodeBalancesEntry>,
    ): QueryBalanceResponse_NodeBalancesEntry {
      return QueryBalanceResponse_NodeBalancesEntry.fromPartial(base ?? {});
    },
    fromPartial(
      object: DeepPartial<QueryBalanceResponse_NodeBalancesEntry>,
    ): QueryBalanceResponse_NodeBalancesEntry {
      const message = createBaseQueryBalanceResponse_NodeBalancesEntry();
      message.key = object.key ?? "";
      message.value = object.value ?? 0;
      return message;
    },
  };

function createBaseSparkAddress(): SparkAddress {
  return { identityPublicKey: new Uint8Array(0) };
}

export const SparkAddress: MessageFns<SparkAddress> = {
  encode(
    message: SparkAddress,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.identityPublicKey.length !== 0) {
      writer.uint32(10).bytes(message.identityPublicKey);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SparkAddress {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSparkAddress();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.identityPublicKey = reader.bytes();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SparkAddress {
    return {
      identityPublicKey: isSet(object.identityPublicKey)
        ? bytesFromBase64(object.identityPublicKey)
        : new Uint8Array(0),
    };
  },

  toJSON(message: SparkAddress): unknown {
    const obj: any = {};
    if (message.identityPublicKey.length !== 0) {
      obj.identityPublicKey = base64FromBytes(message.identityPublicKey);
    }
    return obj;
  },

  create(base?: DeepPartial<SparkAddress>): SparkAddress {
    return SparkAddress.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<SparkAddress>): SparkAddress {
    const message = createBaseSparkAddress();
    message.identityPublicKey = object.identityPublicKey ?? new Uint8Array(0);
    return message;
  },
};

export type SparkServiceDefinition = typeof SparkServiceDefinition;
export const SparkServiceDefinition = {
  name: "SparkService",
  fullName: "spark.SparkService",
  methods: {
    generate_deposit_address: {
      name: "generate_deposit_address",
      requestType: GenerateDepositAddressRequest,
      requestStream: false,
      responseType: GenerateDepositAddressResponse,
      responseStream: false,
      options: {},
    },
    start_deposit_tree_creation: {
      name: "start_deposit_tree_creation",
      requestType: StartDepositTreeCreationRequest,
      requestStream: false,
      responseType: StartDepositTreeCreationResponse,
      responseStream: false,
      options: {},
    },
    /**
     * This is deprecated, please use start_deposit_tree_creation instead.
     *
     * @deprecated
     */
    start_tree_creation: {
      name: "start_tree_creation",
      requestType: StartTreeCreationRequest,
      requestStream: false,
      responseType: StartTreeCreationResponse,
      responseStream: false,
      options: {},
    },
    finalize_node_signatures: {
      name: "finalize_node_signatures",
      requestType: FinalizeNodeSignaturesRequest,
      requestStream: false,
      responseType: FinalizeNodeSignaturesResponse,
      responseStream: false,
      options: {},
    },
    start_transfer: {
      name: "start_transfer",
      requestType: StartTransferRequest,
      requestStream: false,
      responseType: StartTransferResponse,
      responseStream: false,
      options: {},
    },
    finalize_transfer: {
      name: "finalize_transfer",
      requestType: FinalizeTransferRequest,
      requestStream: false,
      responseType: FinalizeTransferResponse,
      responseStream: false,
      options: {},
    },
    cancel_transfer: {
      name: "cancel_transfer",
      requestType: CancelTransferRequest,
      requestStream: false,
      responseType: CancelTransferResponse,
      responseStream: false,
      options: {},
    },
    query_pending_transfers: {
      name: "query_pending_transfers",
      requestType: TransferFilter,
      requestStream: false,
      responseType: QueryTransfersResponse,
      responseStream: false,
      options: {},
    },
    query_all_transfers: {
      name: "query_all_transfers",
      requestType: TransferFilter,
      requestStream: false,
      responseType: QueryTransfersResponse,
      responseStream: false,
      options: {},
    },
    claim_transfer_tweak_keys: {
      name: "claim_transfer_tweak_keys",
      requestType: ClaimTransferTweakKeysRequest,
      requestStream: false,
      responseType: Empty,
      responseStream: false,
      options: {},
    },
    claim_transfer_sign_refunds: {
      name: "claim_transfer_sign_refunds",
      requestType: ClaimTransferSignRefundsRequest,
      requestStream: false,
      responseType: ClaimTransferSignRefundsResponse,
      responseStream: false,
      options: {},
    },
    aggregate_nodes: {
      name: "aggregate_nodes",
      requestType: AggregateNodesRequest,
      requestStream: false,
      responseType: AggregateNodesResponse,
      responseStream: false,
      options: {},
    },
    store_preimage_share: {
      name: "store_preimage_share",
      requestType: StorePreimageShareRequest,
      requestStream: false,
      responseType: Empty,
      responseStream: false,
      options: {},
    },
    get_signing_commitments: {
      name: "get_signing_commitments",
      requestType: GetSigningCommitmentsRequest,
      requestStream: false,
      responseType: GetSigningCommitmentsResponse,
      responseStream: false,
      options: {},
    },
    cooperative_exit: {
      name: "cooperative_exit",
      requestType: CooperativeExitRequest,
      requestStream: false,
      responseType: CooperativeExitResponse,
      responseStream: false,
      options: {},
    },
    initiate_preimage_swap: {
      name: "initiate_preimage_swap",
      requestType: InitiatePreimageSwapRequest,
      requestStream: false,
      responseType: InitiatePreimageSwapResponse,
      responseStream: false,
      options: {},
    },
    provide_preimage: {
      name: "provide_preimage",
      requestType: ProvidePreimageRequest,
      requestStream: false,
      responseType: ProvidePreimageResponse,
      responseStream: false,
      options: {},
    },
    /**
     * This is the exact same as start_transfer, but expresses to the SO
     * this transfer is specifically for a leaf swap.
     */
    start_leaf_swap: {
      name: "start_leaf_swap",
      requestType: StartTransferRequest,
      requestStream: false,
      responseType: StartTransferResponse,
      responseStream: false,
      options: {},
    },
    /**
     * This is deprecated, please use counter_leaf_swap instead.
     *
     * @deprecated
     */
    leaf_swap: {
      name: "leaf_swap",
      requestType: CounterLeafSwapRequest,
      requestStream: false,
      responseType: CounterLeafSwapResponse,
      responseStream: false,
      options: {},
    },
    /**
     * This is the exact same as start_leaf_swap, but signs with
     * an adaptor public key after a counterparty has begun the swap via start_leaf_swap.
     */
    counter_leaf_swap: {
      name: "counter_leaf_swap",
      requestType: CounterLeafSwapRequest,
      requestStream: false,
      responseType: CounterLeafSwapResponse,
      responseStream: false,
      options: {},
    },
    refresh_timelock: {
      name: "refresh_timelock",
      requestType: RefreshTimelockRequest,
      requestStream: false,
      responseType: RefreshTimelockResponse,
      responseStream: false,
      options: {},
    },
    extend_leaf: {
      name: "extend_leaf",
      requestType: ExtendLeafRequest,
      requestStream: false,
      responseType: ExtendLeafResponse,
      responseStream: false,
      options: {},
    },
    prepare_tree_address: {
      name: "prepare_tree_address",
      requestType: PrepareTreeAddressRequest,
      requestStream: false,
      responseType: PrepareTreeAddressResponse,
      responseStream: false,
      options: {},
    },
    create_tree: {
      name: "create_tree",
      requestType: CreateTreeRequest,
      requestStream: false,
      responseType: CreateTreeResponse,
      responseStream: false,
      options: {},
    },
    get_signing_operator_list: {
      name: "get_signing_operator_list",
      requestType: Empty,
      requestStream: false,
      responseType: GetSigningOperatorListResponse,
      responseStream: false,
      options: {},
    },
    query_nodes: {
      name: "query_nodes",
      requestType: QueryNodesRequest,
      requestStream: false,
      responseType: QueryNodesResponse,
      responseStream: false,
      options: {},
    },
    query_balance: {
      name: "query_balance",
      requestType: QueryBalanceRequest,
      requestStream: false,
      responseType: QueryBalanceResponse,
      responseStream: false,
      options: {},
    },
    query_user_signed_refunds: {
      name: "query_user_signed_refunds",
      requestType: QueryUserSignedRefundsRequest,
      requestStream: false,
      responseType: QueryUserSignedRefundsResponse,
      responseStream: false,
      options: {},
    },
    /** Token RPCs */
    start_token_transaction: {
      name: "start_token_transaction",
      requestType: StartTokenTransactionRequest,
      requestStream: false,
      responseType: StartTokenTransactionResponse,
      responseStream: false,
      options: {},
    },
    sign_token_transaction: {
      name: "sign_token_transaction",
      requestType: SignTokenTransactionRequest,
      requestStream: false,
      responseType: SignTokenTransactionResponse,
      responseStream: false,
      options: {},
    },
    finalize_token_transaction: {
      name: "finalize_token_transaction",
      requestType: FinalizeTokenTransactionRequest,
      requestStream: false,
      responseType: Empty,
      responseStream: false,
      options: {},
    },
    freeze_tokens: {
      name: "freeze_tokens",
      requestType: FreezeTokensRequest,
      requestStream: false,
      responseType: FreezeTokensResponse,
      responseStream: false,
      options: {},
    },
    query_token_outputs: {
      name: "query_token_outputs",
      requestType: QueryTokenOutputsRequest,
      requestStream: false,
      responseType: QueryTokenOutputsResponse,
      responseStream: false,
      options: {},
    },
    query_token_transactions: {
      name: "query_token_transactions",
      requestType: QueryTokenTransactionsRequest,
      requestStream: false,
      responseType: QueryTokenTransactionsResponse,
      responseStream: false,
      options: {},
    },
    cancel_signed_token_transaction: {
      name: "cancel_signed_token_transaction",
      requestType: CancelSignedTokenTransactionRequest,
      requestStream: false,
      responseType: Empty,
      responseStream: false,
      options: {},
    },
    return_lightning_payment: {
      name: "return_lightning_payment",
      requestType: ReturnLightningPaymentRequest,
      requestStream: false,
      responseType: Empty,
      responseStream: false,
      options: {},
    },
    query_unused_deposit_addresses: {
      name: "query_unused_deposit_addresses",
      requestType: QueryUnusedDepositAddressesRequest,
      requestStream: false,
      responseType: QueryUnusedDepositAddressesResponse,
      responseStream: false,
      options: {},
    },
    subscribe_to_events: {
      name: "subscribe_to_events",
      requestType: SubscribeToEventsRequest,
      requestStream: false,
      responseType: SubscribeToEventsResponse,
      responseStream: true,
      options: {},
    },
  },
} as const;

export interface SparkServiceImplementation<CallContextExt = {}> {
  generate_deposit_address(
    request: GenerateDepositAddressRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<GenerateDepositAddressResponse>>;
  start_deposit_tree_creation(
    request: StartDepositTreeCreationRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<StartDepositTreeCreationResponse>>;
  /**
   * This is deprecated, please use start_deposit_tree_creation instead.
   *
   * @deprecated
   */
  start_tree_creation(
    request: StartTreeCreationRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<StartTreeCreationResponse>>;
  finalize_node_signatures(
    request: FinalizeNodeSignaturesRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<FinalizeNodeSignaturesResponse>>;
  start_transfer(
    request: StartTransferRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<StartTransferResponse>>;
  finalize_transfer(
    request: FinalizeTransferRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<FinalizeTransferResponse>>;
  cancel_transfer(
    request: CancelTransferRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<CancelTransferResponse>>;
  query_pending_transfers(
    request: TransferFilter,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<QueryTransfersResponse>>;
  query_all_transfers(
    request: TransferFilter,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<QueryTransfersResponse>>;
  claim_transfer_tweak_keys(
    request: ClaimTransferTweakKeysRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<Empty>>;
  claim_transfer_sign_refunds(
    request: ClaimTransferSignRefundsRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<ClaimTransferSignRefundsResponse>>;
  aggregate_nodes(
    request: AggregateNodesRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<AggregateNodesResponse>>;
  store_preimage_share(
    request: StorePreimageShareRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<Empty>>;
  get_signing_commitments(
    request: GetSigningCommitmentsRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<GetSigningCommitmentsResponse>>;
  cooperative_exit(
    request: CooperativeExitRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<CooperativeExitResponse>>;
  initiate_preimage_swap(
    request: InitiatePreimageSwapRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<InitiatePreimageSwapResponse>>;
  provide_preimage(
    request: ProvidePreimageRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<ProvidePreimageResponse>>;
  /**
   * This is the exact same as start_transfer, but expresses to the SO
   * this transfer is specifically for a leaf swap.
   */
  start_leaf_swap(
    request: StartTransferRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<StartTransferResponse>>;
  /**
   * This is deprecated, please use counter_leaf_swap instead.
   *
   * @deprecated
   */
  leaf_swap(
    request: CounterLeafSwapRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<CounterLeafSwapResponse>>;
  /**
   * This is the exact same as start_leaf_swap, but signs with
   * an adaptor public key after a counterparty has begun the swap via start_leaf_swap.
   */
  counter_leaf_swap(
    request: CounterLeafSwapRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<CounterLeafSwapResponse>>;
  refresh_timelock(
    request: RefreshTimelockRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<RefreshTimelockResponse>>;
  extend_leaf(
    request: ExtendLeafRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<ExtendLeafResponse>>;
  prepare_tree_address(
    request: PrepareTreeAddressRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<PrepareTreeAddressResponse>>;
  create_tree(
    request: CreateTreeRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<CreateTreeResponse>>;
  get_signing_operator_list(
    request: Empty,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<GetSigningOperatorListResponse>>;
  query_nodes(
    request: QueryNodesRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<QueryNodesResponse>>;
  query_balance(
    request: QueryBalanceRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<QueryBalanceResponse>>;
  query_user_signed_refunds(
    request: QueryUserSignedRefundsRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<QueryUserSignedRefundsResponse>>;
  /** Token RPCs */
  start_token_transaction(
    request: StartTokenTransactionRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<StartTokenTransactionResponse>>;
  sign_token_transaction(
    request: SignTokenTransactionRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<SignTokenTransactionResponse>>;
  finalize_token_transaction(
    request: FinalizeTokenTransactionRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<Empty>>;
  freeze_tokens(
    request: FreezeTokensRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<FreezeTokensResponse>>;
  query_token_outputs(
    request: QueryTokenOutputsRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<QueryTokenOutputsResponse>>;
  query_token_transactions(
    request: QueryTokenTransactionsRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<QueryTokenTransactionsResponse>>;
  cancel_signed_token_transaction(
    request: CancelSignedTokenTransactionRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<Empty>>;
  return_lightning_payment(
    request: ReturnLightningPaymentRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<Empty>>;
  query_unused_deposit_addresses(
    request: QueryUnusedDepositAddressesRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<QueryUnusedDepositAddressesResponse>>;
  subscribe_to_events(
    request: SubscribeToEventsRequest,
    context: CallContext & CallContextExt,
  ): ServerStreamingMethodResult<DeepPartial<SubscribeToEventsResponse>>;
}

export interface SparkServiceClient<CallOptionsExt = {}> {
  generate_deposit_address(
    request: DeepPartial<GenerateDepositAddressRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<GenerateDepositAddressResponse>;
  start_deposit_tree_creation(
    request: DeepPartial<StartDepositTreeCreationRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<StartDepositTreeCreationResponse>;
  /**
   * This is deprecated, please use start_deposit_tree_creation instead.
   *
   * @deprecated
   */
  start_tree_creation(
    request: DeepPartial<StartTreeCreationRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<StartTreeCreationResponse>;
  finalize_node_signatures(
    request: DeepPartial<FinalizeNodeSignaturesRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<FinalizeNodeSignaturesResponse>;
  start_transfer(
    request: DeepPartial<StartTransferRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<StartTransferResponse>;
  finalize_transfer(
    request: DeepPartial<FinalizeTransferRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<FinalizeTransferResponse>;
  cancel_transfer(
    request: DeepPartial<CancelTransferRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<CancelTransferResponse>;
  query_pending_transfers(
    request: DeepPartial<TransferFilter>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<QueryTransfersResponse>;
  query_all_transfers(
    request: DeepPartial<TransferFilter>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<QueryTransfersResponse>;
  claim_transfer_tweak_keys(
    request: DeepPartial<ClaimTransferTweakKeysRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<Empty>;
  claim_transfer_sign_refunds(
    request: DeepPartial<ClaimTransferSignRefundsRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<ClaimTransferSignRefundsResponse>;
  aggregate_nodes(
    request: DeepPartial<AggregateNodesRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<AggregateNodesResponse>;
  store_preimage_share(
    request: DeepPartial<StorePreimageShareRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<Empty>;
  get_signing_commitments(
    request: DeepPartial<GetSigningCommitmentsRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<GetSigningCommitmentsResponse>;
  cooperative_exit(
    request: DeepPartial<CooperativeExitRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<CooperativeExitResponse>;
  initiate_preimage_swap(
    request: DeepPartial<InitiatePreimageSwapRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<InitiatePreimageSwapResponse>;
  provide_preimage(
    request: DeepPartial<ProvidePreimageRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<ProvidePreimageResponse>;
  /**
   * This is the exact same as start_transfer, but expresses to the SO
   * this transfer is specifically for a leaf swap.
   */
  start_leaf_swap(
    request: DeepPartial<StartTransferRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<StartTransferResponse>;
  /**
   * This is deprecated, please use counter_leaf_swap instead.
   *
   * @deprecated
   */
  leaf_swap(
    request: DeepPartial<CounterLeafSwapRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<CounterLeafSwapResponse>;
  /**
   * This is the exact same as start_leaf_swap, but signs with
   * an adaptor public key after a counterparty has begun the swap via start_leaf_swap.
   */
  counter_leaf_swap(
    request: DeepPartial<CounterLeafSwapRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<CounterLeafSwapResponse>;
  refresh_timelock(
    request: DeepPartial<RefreshTimelockRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<RefreshTimelockResponse>;
  extend_leaf(
    request: DeepPartial<ExtendLeafRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<ExtendLeafResponse>;
  prepare_tree_address(
    request: DeepPartial<PrepareTreeAddressRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<PrepareTreeAddressResponse>;
  create_tree(
    request: DeepPartial<CreateTreeRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<CreateTreeResponse>;
  get_signing_operator_list(
    request: DeepPartial<Empty>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<GetSigningOperatorListResponse>;
  query_nodes(
    request: DeepPartial<QueryNodesRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<QueryNodesResponse>;
  query_balance(
    request: DeepPartial<QueryBalanceRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<QueryBalanceResponse>;
  query_user_signed_refunds(
    request: DeepPartial<QueryUserSignedRefundsRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<QueryUserSignedRefundsResponse>;
  /** Token RPCs */
  start_token_transaction(
    request: DeepPartial<StartTokenTransactionRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<StartTokenTransactionResponse>;
  sign_token_transaction(
    request: DeepPartial<SignTokenTransactionRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<SignTokenTransactionResponse>;
  finalize_token_transaction(
    request: DeepPartial<FinalizeTokenTransactionRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<Empty>;
  freeze_tokens(
    request: DeepPartial<FreezeTokensRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<FreezeTokensResponse>;
  query_token_outputs(
    request: DeepPartial<QueryTokenOutputsRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<QueryTokenOutputsResponse>;
  query_token_transactions(
    request: DeepPartial<QueryTokenTransactionsRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<QueryTokenTransactionsResponse>;
  cancel_signed_token_transaction(
    request: DeepPartial<CancelSignedTokenTransactionRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<Empty>;
  return_lightning_payment(
    request: DeepPartial<ReturnLightningPaymentRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<Empty>;
  query_unused_deposit_addresses(
    request: DeepPartial<QueryUnusedDepositAddressesRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<QueryUnusedDepositAddressesResponse>;
  subscribe_to_events(
    request: DeepPartial<SubscribeToEventsRequest>,
    options?: CallOptions & CallOptionsExt,
  ): AsyncIterable<SubscribeToEventsResponse>;
}

function bytesFromBase64(b64: string): Uint8Array {
  if ((globalThis as any).Buffer) {
    return Uint8Array.from(globalThis.Buffer.from(b64, "base64"));
  } else {
    const bin = globalThis.atob(b64);
    const arr = new Uint8Array(bin.length);
    for (let i = 0; i < bin.length; ++i) {
      arr[i] = bin.charCodeAt(i);
    }
    return arr;
  }
}

function base64FromBytes(arr: Uint8Array): string {
  if ((globalThis as any).Buffer) {
    return globalThis.Buffer.from(arr).toString("base64");
  } else {
    const bin: string[] = [];
    arr.forEach((byte) => {
      bin.push(globalThis.String.fromCharCode(byte));
    });
    return globalThis.btoa(bin.join(""));
  }
}

type Builtin =
  | Date
  | Function
  | Uint8Array
  | string
  | number
  | boolean
  | undefined;

export type DeepPartial<T> = T extends Builtin
  ? T
  : T extends globalThis.Array<infer U>
    ? globalThis.Array<DeepPartial<U>>
    : T extends ReadonlyArray<infer U>
      ? ReadonlyArray<DeepPartial<U>>
      : T extends { $case: string }
        ? { [K in keyof Omit<T, "$case">]?: DeepPartial<T[K]> } & {
            $case: T["$case"];
          }
        : T extends {}
          ? { [K in keyof T]?: DeepPartial<T[K]> }
          : Partial<T>;

function toTimestamp(date: Date): Timestamp {
  const seconds = Math.trunc(date.getTime() / 1_000);
  const nanos = (date.getTime() % 1_000) * 1_000_000;
  return { seconds, nanos };
}

function fromTimestamp(t: Timestamp): Date {
  let millis = (t.seconds || 0) * 1_000;
  millis += (t.nanos || 0) / 1_000_000;
  return new globalThis.Date(millis);
}

function fromJsonTimestamp(o: any): Date {
  if (o instanceof globalThis.Date) {
    return o;
  } else if (typeof o === "string") {
    return new globalThis.Date(o);
  } else {
    return fromTimestamp(Timestamp.fromJSON(o));
  }
}

function longToNumber(int64: { toString(): string }): number {
  const num = globalThis.Number(int64.toString());
  if (num > globalThis.Number.MAX_SAFE_INTEGER) {
    throw new globalThis.Error("Value is larger than Number.MAX_SAFE_INTEGER");
  }
  if (num < globalThis.Number.MIN_SAFE_INTEGER) {
    throw new globalThis.Error("Value is smaller than Number.MIN_SAFE_INTEGER");
  }
  return num;
}

function isObject(value: any): boolean {
  return typeof value === "object" && value !== null;
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export type ServerStreamingMethodResult<Response> = {
  [Symbol.asyncIterator](): AsyncIterator<Response, void>;
};

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create(base?: DeepPartial<T>): T;
  fromPartial(object: DeepPartial<T>): T;
}
