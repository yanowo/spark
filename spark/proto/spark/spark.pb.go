// Code generated by protoc-gen-go. DO NOT EDIT.
// versions:
// 	protoc-gen-go v1.36.6
// 	protoc        v5.29.3
// source: spark.proto

package spark

import (
	_ "github.com/envoyproxy/protoc-gen-validate/validate"
	common "github.com/lightsparkdev/spark/proto/common"
	protoreflect "google.golang.org/protobuf/reflect/protoreflect"
	protoimpl "google.golang.org/protobuf/runtime/protoimpl"
	emptypb "google.golang.org/protobuf/types/known/emptypb"
	timestamppb "google.golang.org/protobuf/types/known/timestamppb"
	reflect "reflect"
	sync "sync"
	unsafe "unsafe"
)

const (
	// Verify that this generated code is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(20 - protoimpl.MinVersion)
	// Verify that runtime/protoimpl is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(protoimpl.MaxVersion - 20)
)

// *
// Network is the network type of the bitcoin network.
type Network int32

const (
	Network_UNSPECIFIED Network = 0
	Network_MAINNET     Network = 1
	Network_REGTEST     Network = 2
	Network_TESTNET     Network = 3
	Network_SIGNET      Network = 4
)

// Enum value maps for Network.
var (
	Network_name = map[int32]string{
		0: "UNSPECIFIED",
		1: "MAINNET",
		2: "REGTEST",
		3: "TESTNET",
		4: "SIGNET",
	}
	Network_value = map[string]int32{
		"UNSPECIFIED": 0,
		"MAINNET":     1,
		"REGTEST":     2,
		"TESTNET":     3,
		"SIGNET":      4,
	}
)

func (x Network) Enum() *Network {
	p := new(Network)
	*p = x
	return p
}

func (x Network) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (Network) Descriptor() protoreflect.EnumDescriptor {
	return file_spark_proto_enumTypes[0].Descriptor()
}

func (Network) Type() protoreflect.EnumType {
	return &file_spark_proto_enumTypes[0]
}

func (x Network) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use Network.Descriptor instead.
func (Network) EnumDescriptor() ([]byte, []int) {
	return file_spark_proto_rawDescGZIP(), []int{0}
}

type TokenTransactionStatus int32

const (
	TokenTransactionStatus_TOKEN_TRANSACTION_STARTED   TokenTransactionStatus = 0
	TokenTransactionStatus_TOKEN_TRANSACTION_SIGNED    TokenTransactionStatus = 1
	TokenTransactionStatus_TOKEN_TRANSACTION_FINALIZED TokenTransactionStatus = 2
)

// Enum value maps for TokenTransactionStatus.
var (
	TokenTransactionStatus_name = map[int32]string{
		0: "TOKEN_TRANSACTION_STARTED",
		1: "TOKEN_TRANSACTION_SIGNED",
		2: "TOKEN_TRANSACTION_FINALIZED",
	}
	TokenTransactionStatus_value = map[string]int32{
		"TOKEN_TRANSACTION_STARTED":   0,
		"TOKEN_TRANSACTION_SIGNED":    1,
		"TOKEN_TRANSACTION_FINALIZED": 2,
	}
)

func (x TokenTransactionStatus) Enum() *TokenTransactionStatus {
	p := new(TokenTransactionStatus)
	*p = x
	return p
}

func (x TokenTransactionStatus) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (TokenTransactionStatus) Descriptor() protoreflect.EnumDescriptor {
	return file_spark_proto_enumTypes[1].Descriptor()
}

func (TokenTransactionStatus) Type() protoreflect.EnumType {
	return &file_spark_proto_enumTypes[1]
}

func (x TokenTransactionStatus) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use TokenTransactionStatus.Descriptor instead.
func (TokenTransactionStatus) EnumDescriptor() ([]byte, []int) {
	return file_spark_proto_rawDescGZIP(), []int{1}
}

type TransferStatus int32

const (
	TransferStatus_TRANSFER_STATUS_SENDER_INITIATED         TransferStatus = 0
	TransferStatus_TRANSFER_STATUS_SENDER_KEY_TWEAK_PENDING TransferStatus = 1
	TransferStatus_TRANSFER_STATUS_SENDER_KEY_TWEAKED       TransferStatus = 2
	TransferStatus_TRANSFER_STATUS_RECEIVER_KEY_TWEAKED     TransferStatus = 3
	TransferStatus_TRANSFER_STATUSR_RECEIVER_REFUND_SIGNED  TransferStatus = 4
	TransferStatus_TRANSFER_STATUS_COMPLETED                TransferStatus = 5
	TransferStatus_TRANSFER_STATUS_EXPIRED                  TransferStatus = 6
	TransferStatus_TRANSFER_STATUS_RETURNED                 TransferStatus = 7
)

// Enum value maps for TransferStatus.
var (
	TransferStatus_name = map[int32]string{
		0: "TRANSFER_STATUS_SENDER_INITIATED",
		1: "TRANSFER_STATUS_SENDER_KEY_TWEAK_PENDING",
		2: "TRANSFER_STATUS_SENDER_KEY_TWEAKED",
		3: "TRANSFER_STATUS_RECEIVER_KEY_TWEAKED",
		4: "TRANSFER_STATUSR_RECEIVER_REFUND_SIGNED",
		5: "TRANSFER_STATUS_COMPLETED",
		6: "TRANSFER_STATUS_EXPIRED",
		7: "TRANSFER_STATUS_RETURNED",
	}
	TransferStatus_value = map[string]int32{
		"TRANSFER_STATUS_SENDER_INITIATED":         0,
		"TRANSFER_STATUS_SENDER_KEY_TWEAK_PENDING": 1,
		"TRANSFER_STATUS_SENDER_KEY_TWEAKED":       2,
		"TRANSFER_STATUS_RECEIVER_KEY_TWEAKED":     3,
		"TRANSFER_STATUSR_RECEIVER_REFUND_SIGNED":  4,
		"TRANSFER_STATUS_COMPLETED":                5,
		"TRANSFER_STATUS_EXPIRED":                  6,
		"TRANSFER_STATUS_RETURNED":                 7,
	}
)

func (x TransferStatus) Enum() *TransferStatus {
	p := new(TransferStatus)
	*p = x
	return p
}

func (x TransferStatus) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (TransferStatus) Descriptor() protoreflect.EnumDescriptor {
	return file_spark_proto_enumTypes[2].Descriptor()
}

func (TransferStatus) Type() protoreflect.EnumType {
	return &file_spark_proto_enumTypes[2]
}

func (x TransferStatus) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use TransferStatus.Descriptor instead.
func (TransferStatus) EnumDescriptor() ([]byte, []int) {
	return file_spark_proto_rawDescGZIP(), []int{2}
}

type TransferType int32

const (
	TransferType_PREIMAGE_SWAP    TransferType = 0
	TransferType_COOPERATIVE_EXIT TransferType = 1
	TransferType_TRANSFER         TransferType = 2
	TransferType_SWAP             TransferType = 30
	TransferType_COUNTER_SWAP     TransferType = 40
)

// Enum value maps for TransferType.
var (
	TransferType_name = map[int32]string{
		0:  "PREIMAGE_SWAP",
		1:  "COOPERATIVE_EXIT",
		2:  "TRANSFER",
		30: "SWAP",
		40: "COUNTER_SWAP",
	}
	TransferType_value = map[string]int32{
		"PREIMAGE_SWAP":    0,
		"COOPERATIVE_EXIT": 1,
		"TRANSFER":         2,
		"SWAP":             30,
		"COUNTER_SWAP":     40,
	}
)

func (x TransferType) Enum() *TransferType {
	p := new(TransferType)
	*p = x
	return p
}

func (x TransferType) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (TransferType) Descriptor() protoreflect.EnumDescriptor {
	return file_spark_proto_enumTypes[3].Descriptor()
}

func (TransferType) Type() protoreflect.EnumType {
	return &file_spark_proto_enumTypes[3]
}

func (x TransferType) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use TransferType.Descriptor instead.
func (TransferType) EnumDescriptor() ([]byte, []int) {
	return file_spark_proto_rawDescGZIP(), []int{3}
}

type InitiatePreimageSwapRequest_Reason int32

const (
	// The associated lightning service is sending the payment.
	InitiatePreimageSwapRequest_REASON_SEND InitiatePreimageSwapRequest_Reason = 0
	// The associated lightning service is receiving the payment.
	InitiatePreimageSwapRequest_REASON_RECEIVE InitiatePreimageSwapRequest_Reason = 1
)

// Enum value maps for InitiatePreimageSwapRequest_Reason.
var (
	InitiatePreimageSwapRequest_Reason_name = map[int32]string{
		0: "REASON_SEND",
		1: "REASON_RECEIVE",
	}
	InitiatePreimageSwapRequest_Reason_value = map[string]int32{
		"REASON_SEND":    0,
		"REASON_RECEIVE": 1,
	}
)

func (x InitiatePreimageSwapRequest_Reason) Enum() *InitiatePreimageSwapRequest_Reason {
	p := new(InitiatePreimageSwapRequest_Reason)
	*p = x
	return p
}

func (x InitiatePreimageSwapRequest_Reason) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (InitiatePreimageSwapRequest_Reason) Descriptor() protoreflect.EnumDescriptor {
	return file_spark_proto_enumTypes[4].Descriptor()
}

func (InitiatePreimageSwapRequest_Reason) Type() protoreflect.EnumType {
	return &file_spark_proto_enumTypes[4]
}

func (x InitiatePreimageSwapRequest_Reason) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use InitiatePreimageSwapRequest_Reason.Descriptor instead.
func (InitiatePreimageSwapRequest_Reason) EnumDescriptor() ([]byte, []int) {
	return file_spark_proto_rawDescGZIP(), []int{78, 0}
}

type SubscribeToEventsRequest struct {
	state             protoimpl.MessageState `protogen:"open.v1"`
	IdentityPublicKey []byte                 `protobuf:"bytes,10,opt,name=identity_public_key,json=identityPublicKey,proto3" json:"identity_public_key,omitempty"`
	unknownFields     protoimpl.UnknownFields
	sizeCache         protoimpl.SizeCache
}

func (x *SubscribeToEventsRequest) Reset() {
	*x = SubscribeToEventsRequest{}
	mi := &file_spark_proto_msgTypes[0]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *SubscribeToEventsRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*SubscribeToEventsRequest) ProtoMessage() {}

func (x *SubscribeToEventsRequest) ProtoReflect() protoreflect.Message {
	mi := &file_spark_proto_msgTypes[0]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use SubscribeToEventsRequest.ProtoReflect.Descriptor instead.
func (*SubscribeToEventsRequest) Descriptor() ([]byte, []int) {
	return file_spark_proto_rawDescGZIP(), []int{0}
}

func (x *SubscribeToEventsRequest) GetIdentityPublicKey() []byte {
	if x != nil {
		return x.IdentityPublicKey
	}
	return nil
}

type SubscribeToEventsResponse struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Types that are valid to be assigned to Event:
	//
	//	*SubscribeToEventsResponse_Transfer
	//	*SubscribeToEventsResponse_Deposit
	//	*SubscribeToEventsResponse_Connected
	Event         isSubscribeToEventsResponse_Event `protobuf_oneof:"event"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *SubscribeToEventsResponse) Reset() {
	*x = SubscribeToEventsResponse{}
	mi := &file_spark_proto_msgTypes[1]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *SubscribeToEventsResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*SubscribeToEventsResponse) ProtoMessage() {}

func (x *SubscribeToEventsResponse) ProtoReflect() protoreflect.Message {
	mi := &file_spark_proto_msgTypes[1]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use SubscribeToEventsResponse.ProtoReflect.Descriptor instead.
func (*SubscribeToEventsResponse) Descriptor() ([]byte, []int) {
	return file_spark_proto_rawDescGZIP(), []int{1}
}

func (x *SubscribeToEventsResponse) GetEvent() isSubscribeToEventsResponse_Event {
	if x != nil {
		return x.Event
	}
	return nil
}

func (x *SubscribeToEventsResponse) GetTransfer() *TransferEvent {
	if x != nil {
		if x, ok := x.Event.(*SubscribeToEventsResponse_Transfer); ok {
			return x.Transfer
		}
	}
	return nil
}

func (x *SubscribeToEventsResponse) GetDeposit() *DepositEvent {
	if x != nil {
		if x, ok := x.Event.(*SubscribeToEventsResponse_Deposit); ok {
			return x.Deposit
		}
	}
	return nil
}

func (x *SubscribeToEventsResponse) GetConnected() *ConnectedEvent {
	if x != nil {
		if x, ok := x.Event.(*SubscribeToEventsResponse_Connected); ok {
			return x.Connected
		}
	}
	return nil
}

type isSubscribeToEventsResponse_Event interface {
	isSubscribeToEventsResponse_Event()
}

type SubscribeToEventsResponse_Transfer struct {
	Transfer *TransferEvent `protobuf:"bytes,1,opt,name=transfer,proto3,oneof"`
}

type SubscribeToEventsResponse_Deposit struct {
	Deposit *DepositEvent `protobuf:"bytes,2,opt,name=deposit,proto3,oneof"`
}

type SubscribeToEventsResponse_Connected struct {
	Connected *ConnectedEvent `protobuf:"bytes,3,opt,name=connected,proto3,oneof"`
}

func (*SubscribeToEventsResponse_Transfer) isSubscribeToEventsResponse_Event() {}

func (*SubscribeToEventsResponse_Deposit) isSubscribeToEventsResponse_Event() {}

func (*SubscribeToEventsResponse_Connected) isSubscribeToEventsResponse_Event() {}

type ConnectedEvent struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *ConnectedEvent) Reset() {
	*x = ConnectedEvent{}
	mi := &file_spark_proto_msgTypes[2]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ConnectedEvent) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ConnectedEvent) ProtoMessage() {}

func (x *ConnectedEvent) ProtoReflect() protoreflect.Message {
	mi := &file_spark_proto_msgTypes[2]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ConnectedEvent.ProtoReflect.Descriptor instead.
func (*ConnectedEvent) Descriptor() ([]byte, []int) {
	return file_spark_proto_rawDescGZIP(), []int{2}
}

type TransferEvent struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Transfer      *Transfer              `protobuf:"bytes,10,opt,name=transfer,proto3" json:"transfer,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *TransferEvent) Reset() {
	*x = TransferEvent{}
	mi := &file_spark_proto_msgTypes[3]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *TransferEvent) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*TransferEvent) ProtoMessage() {}

func (x *TransferEvent) ProtoReflect() protoreflect.Message {
	mi := &file_spark_proto_msgTypes[3]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use TransferEvent.ProtoReflect.Descriptor instead.
func (*TransferEvent) Descriptor() ([]byte, []int) {
	return file_spark_proto_rawDescGZIP(), []int{3}
}

func (x *TransferEvent) GetTransfer() *Transfer {
	if x != nil {
		return x.Transfer
	}
	return nil
}

type DepositEvent struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Deposit       *TreeNode              `protobuf:"bytes,10,opt,name=deposit,proto3" json:"deposit,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *DepositEvent) Reset() {
	*x = DepositEvent{}
	mi := &file_spark_proto_msgTypes[4]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *DepositEvent) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*DepositEvent) ProtoMessage() {}

func (x *DepositEvent) ProtoReflect() protoreflect.Message {
	mi := &file_spark_proto_msgTypes[4]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use DepositEvent.ProtoReflect.Descriptor instead.
func (*DepositEvent) Descriptor() ([]byte, []int) {
	return file_spark_proto_rawDescGZIP(), []int{4}
}

func (x *DepositEvent) GetDeposit() *TreeNode {
	if x != nil {
		return x.Deposit
	}
	return nil
}

// *
// DepositAddressProof is the proof of possession of the deposit address.
// When a user wants to generate a deposit address, they are sending their public key to the SE,
// and the SE will respond with an address of user's public key + SE's public key.
//
// In the trusty deposit flow, user will need to know that this address is valid, and no single SE
// can generate this address.
//
// The SE will need to sign the address with their identity keys, and have a proof of possession of
// the signing key piece that the SE holds.
type DepositAddressProof struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// The signatures of the address by the SE's identity keys.
	AddressSignatures map[string][]byte `protobuf:"bytes,1,rep,name=address_signatures,json=addressSignatures,proto3" json:"address_signatures,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
	// The proof of possession of the signing key piece by the SE.
	ProofOfPossessionSignature []byte `protobuf:"bytes,2,opt,name=proof_of_possession_signature,json=proofOfPossessionSignature,proto3" json:"proof_of_possession_signature,omitempty"`
	unknownFields              protoimpl.UnknownFields
	sizeCache                  protoimpl.SizeCache
}

func (x *DepositAddressProof) Reset() {
	*x = DepositAddressProof{}
	mi := &file_spark_proto_msgTypes[5]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *DepositAddressProof) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*DepositAddressProof) ProtoMessage() {}

func (x *DepositAddressProof) ProtoReflect() protoreflect.Message {
	mi := &file_spark_proto_msgTypes[5]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use DepositAddressProof.ProtoReflect.Descriptor instead.
func (*DepositAddressProof) Descriptor() ([]byte, []int) {
	return file_spark_proto_rawDescGZIP(), []int{5}
}

func (x *DepositAddressProof) GetAddressSignatures() map[string][]byte {
	if x != nil {
		return x.AddressSignatures
	}
	return nil
}

func (x *DepositAddressProof) GetProofOfPossessionSignature() []byte {
	if x != nil {
		return x.ProofOfPossessionSignature
	}
	return nil
}

// *
// GenerateDepositAddressRequest is the request to generate a deposit address.
// The user will send their public key to the SE, and the SE will respond with an address of user's
// public key + SE's public key.
type GenerateDepositAddressRequest struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// The signing public key of the user.
	SigningPublicKey []byte `protobuf:"bytes,1,opt,name=signing_public_key,json=signingPublicKey,proto3" json:"signing_public_key,omitempty"`
	// The identity public key of the user.
	IdentityPublicKey []byte `protobuf:"bytes,2,opt,name=identity_public_key,json=identityPublicKey,proto3" json:"identity_public_key,omitempty"`
	// The network of the bitcoin network.
	Network Network `protobuf:"varint,3,opt,name=network,proto3,enum=spark.Network" json:"network,omitempty"`
	// The UUID to use for the created TreeNode
	LeafId *string `protobuf:"bytes,4,opt,name=leaf_id,json=leafId,proto3,oneof" json:"leaf_id,omitempty"`
	// Generate static deposit address
	IsStatic      *bool `protobuf:"varint,5,opt,name=is_static,json=isStatic,proto3,oneof" json:"is_static,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *GenerateDepositAddressRequest) Reset() {
	*x = GenerateDepositAddressRequest{}
	mi := &file_spark_proto_msgTypes[6]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *GenerateDepositAddressRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*GenerateDepositAddressRequest) ProtoMessage() {}

func (x *GenerateDepositAddressRequest) ProtoReflect() protoreflect.Message {
	mi := &file_spark_proto_msgTypes[6]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use GenerateDepositAddressRequest.ProtoReflect.Descriptor instead.
func (*GenerateDepositAddressRequest) Descriptor() ([]byte, []int) {
	return file_spark_proto_rawDescGZIP(), []int{6}
}

func (x *GenerateDepositAddressRequest) GetSigningPublicKey() []byte {
	if x != nil {
		return x.SigningPublicKey
	}
	return nil
}

func (x *GenerateDepositAddressRequest) GetIdentityPublicKey() []byte {
	if x != nil {
		return x.IdentityPublicKey
	}
	return nil
}

func (x *GenerateDepositAddressRequest) GetNetwork() Network {
	if x != nil {
		return x.Network
	}
	return Network_UNSPECIFIED
}

func (x *GenerateDepositAddressRequest) GetLeafId() string {
	if x != nil && x.LeafId != nil {
		return *x.LeafId
	}
	return ""
}

func (x *GenerateDepositAddressRequest) GetIsStatic() bool {
	if x != nil && x.IsStatic != nil {
		return *x.IsStatic
	}
	return false
}

// *
// Address is the address of the user's public key + SE's public key.
type Address struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// The p2tr address of the user's public key + SE's public key.
	Address string `protobuf:"bytes,1,opt,name=address,proto3" json:"address,omitempty"`
	// The verifying key of the address, which is user's public key + SE's public key.
	VerifyingKey []byte `protobuf:"bytes,2,opt,name=verifying_key,json=verifyingKey,proto3" json:"verifying_key,omitempty"`
	// The proof of possession of the address by the SE.
	DepositAddressProof *DepositAddressProof `protobuf:"bytes,3,opt,name=deposit_address_proof,json=depositAddressProof,proto3" json:"deposit_address_proof,omitempty"`
	// Is it a static deposit address
	IsStatic      bool `protobuf:"varint,5,opt,name=is_static,json=isStatic,proto3" json:"is_static,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *Address) Reset() {
	*x = Address{}
	mi := &file_spark_proto_msgTypes[7]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *Address) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*Address) ProtoMessage() {}

func (x *Address) ProtoReflect() protoreflect.Message {
	mi := &file_spark_proto_msgTypes[7]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use Address.ProtoReflect.Descriptor instead.
func (*Address) Descriptor() ([]byte, []int) {
	return file_spark_proto_rawDescGZIP(), []int{7}
}

func (x *Address) GetAddress() string {
	if x != nil {
		return x.Address
	}
	return ""
}

func (x *Address) GetVerifyingKey() []byte {
	if x != nil {
		return x.VerifyingKey
	}
	return nil
}

func (x *Address) GetDepositAddressProof() *DepositAddressProof {
	if x != nil {
		return x.DepositAddressProof
	}
	return nil
}

func (x *Address) GetIsStatic() bool {
	if x != nil {
		return x.IsStatic
	}
	return false
}

// *
// GenerateDepositAddressResponse is the response to the request to generate a deposit address.
type GenerateDepositAddressResponse struct {
	state          protoimpl.MessageState `protogen:"open.v1"`
	DepositAddress *Address               `protobuf:"bytes,1,opt,name=deposit_address,json=depositAddress,proto3" json:"deposit_address,omitempty"`
	unknownFields  protoimpl.UnknownFields
	sizeCache      protoimpl.SizeCache
}

func (x *GenerateDepositAddressResponse) Reset() {
	*x = GenerateDepositAddressResponse{}
	mi := &file_spark_proto_msgTypes[8]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *GenerateDepositAddressResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*GenerateDepositAddressResponse) ProtoMessage() {}

func (x *GenerateDepositAddressResponse) ProtoReflect() protoreflect.Message {
	mi := &file_spark_proto_msgTypes[8]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use GenerateDepositAddressResponse.ProtoReflect.Descriptor instead.
func (*GenerateDepositAddressResponse) Descriptor() ([]byte, []int) {
	return file_spark_proto_rawDescGZIP(), []int{8}
}

func (x *GenerateDepositAddressResponse) GetDepositAddress() *Address {
	if x != nil {
		return x.DepositAddress
	}
	return nil
}

// *
// UTXO represents a utxo on the bitcoin network.
// The UTXO is used to create a tree on Spark, it can also be an off-chain utxo so that the user
// can create the tree first and the broadcast the transaction.
type UTXO struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// The raw transaction of the utxo.
	RawTx []byte `protobuf:"bytes,1,opt,name=raw_tx,json=rawTx,proto3" json:"raw_tx,omitempty"`
	// The vout of the raw transaction for the utxo, which will be used to create the tree.
	Vout uint32 `protobuf:"varint,2,opt,name=vout,proto3" json:"vout,omitempty"`
	// The network of the bitcoin network.
	Network       Network `protobuf:"varint,3,opt,name=network,proto3,enum=spark.Network" json:"network,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *UTXO) Reset() {
	*x = UTXO{}
	mi := &file_spark_proto_msgTypes[9]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *UTXO) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*UTXO) ProtoMessage() {}

func (x *UTXO) ProtoReflect() protoreflect.Message {
	mi := &file_spark_proto_msgTypes[9]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use UTXO.ProtoReflect.Descriptor instead.
func (*UTXO) Descriptor() ([]byte, []int) {
	return file_spark_proto_rawDescGZIP(), []int{9}
}

func (x *UTXO) GetRawTx() []byte {
	if x != nil {
		return x.RawTx
	}
	return nil
}

func (x *UTXO) GetVout() uint32 {
	if x != nil {
		return x.Vout
	}
	return 0
}

func (x *UTXO) GetNetwork() Network {
	if x != nil {
		return x.Network
	}
	return Network_UNSPECIFIED
}

// *
// NodeOutput represents a node on the tree.
// This is similar to a UTXO, which is used to create a subtree on Spark. But instead of using
// a utxo, a existing node on the tree is used as the utxo.
type NodeOutput struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// The id of the node.
	NodeId string `protobuf:"bytes,1,opt,name=node_id,json=nodeId,proto3" json:"node_id,omitempty"`
	// The vout of the raw transaction for the node, which will be used to create the tree.
	Vout          uint32 `protobuf:"varint,2,opt,name=vout,proto3" json:"vout,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *NodeOutput) Reset() {
	*x = NodeOutput{}
	mi := &file_spark_proto_msgTypes[10]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *NodeOutput) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*NodeOutput) ProtoMessage() {}

func (x *NodeOutput) ProtoReflect() protoreflect.Message {
	mi := &file_spark_proto_msgTypes[10]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use NodeOutput.ProtoReflect.Descriptor instead.
func (*NodeOutput) Descriptor() ([]byte, []int) {
	return file_spark_proto_rawDescGZIP(), []int{10}
}

func (x *NodeOutput) GetNodeId() string {
	if x != nil {
		return x.NodeId
	}
	return ""
}

func (x *NodeOutput) GetVout() uint32 {
	if x != nil {
		return x.Vout
	}
	return 0
}

// *
// SigningJob is the job for signing a transaction.
// The signing job is used to sign a bitcoin transaction using Spark FROST.
type SigningJob struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// The signing public key of the user.
	SigningPublicKey []byte `protobuf:"bytes,1,opt,name=signing_public_key,json=signingPublicKey,proto3" json:"signing_public_key,omitempty"`
	// The unsigned raw transaction to be signed.
	RawTx []byte `protobuf:"bytes,2,opt,name=raw_tx,json=rawTx,proto3" json:"raw_tx,omitempty"`
	// The signing nonce commitment of the user.
	SigningNonceCommitment *common.SigningCommitment `protobuf:"bytes,3,opt,name=signing_nonce_commitment,json=signingNonceCommitment,proto3" json:"signing_nonce_commitment,omitempty"`
	unknownFields          protoimpl.UnknownFields
	sizeCache              protoimpl.SizeCache
}

func (x *SigningJob) Reset() {
	*x = SigningJob{}
	mi := &file_spark_proto_msgTypes[11]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *SigningJob) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*SigningJob) ProtoMessage() {}

func (x *SigningJob) ProtoReflect() protoreflect.Message {
	mi := &file_spark_proto_msgTypes[11]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use SigningJob.ProtoReflect.Descriptor instead.
func (*SigningJob) Descriptor() ([]byte, []int) {
	return file_spark_proto_rawDescGZIP(), []int{11}
}

func (x *SigningJob) GetSigningPublicKey() []byte {
	if x != nil {
		return x.SigningPublicKey
	}
	return nil
}

func (x *SigningJob) GetRawTx() []byte {
	if x != nil {
		return x.RawTx
	}
	return nil
}

func (x *SigningJob) GetSigningNonceCommitment() *common.SigningCommitment {
	if x != nil {
		return x.SigningNonceCommitment
	}
	return nil
}

// *
// SigningKeyshare is the keyshare information of the SE keyshare group.
type SigningKeyshare struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// The identifiers of the owners of the keyshare.
	OwnerIdentifiers []string `protobuf:"bytes,1,rep,name=owner_identifiers,json=ownerIdentifiers,proto3" json:"owner_identifiers,omitempty"`
	// The threshold of the keyshare.
	Threshold     uint32 `protobuf:"varint,2,opt,name=threshold,proto3" json:"threshold,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *SigningKeyshare) Reset() {
	*x = SigningKeyshare{}
	mi := &file_spark_proto_msgTypes[12]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *SigningKeyshare) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*SigningKeyshare) ProtoMessage() {}

func (x *SigningKeyshare) ProtoReflect() protoreflect.Message {
	mi := &file_spark_proto_msgTypes[12]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use SigningKeyshare.ProtoReflect.Descriptor instead.
func (*SigningKeyshare) Descriptor() ([]byte, []int) {
	return file_spark_proto_rawDescGZIP(), []int{12}
}

func (x *SigningKeyshare) GetOwnerIdentifiers() []string {
	if x != nil {
		return x.OwnerIdentifiers
	}
	return nil
}

func (x *SigningKeyshare) GetThreshold() uint32 {
	if x != nil {
		return x.Threshold
	}
	return 0
}

// *
// SigningResult is the result of the signing job from the SE keyshare group.
// It contains all the information for user to sign their part. After user signs, the signature
// can be aggregated to form the final signature.
type SigningResult struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// The public keys of the SE keyshare group.
	PublicKeys map[string][]byte `protobuf:"bytes,1,rep,name=public_keys,json=publicKeys,proto3" json:"public_keys,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
	// The signing nonce commitments of the SE keyshare group.
	SigningNonceCommitments map[string]*common.SigningCommitment `protobuf:"bytes,2,rep,name=signing_nonce_commitments,json=signingNonceCommitments,proto3" json:"signing_nonce_commitments,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
	// The signature shares of the SE keyshare group.
	SignatureShares map[string][]byte `protobuf:"bytes,3,rep,name=signature_shares,json=signatureShares,proto3" json:"signature_shares,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
	// The keyshare information of the SE keyshare group.
	SigningKeyshare *SigningKeyshare `protobuf:"bytes,4,opt,name=signing_keyshare,json=signingKeyshare,proto3" json:"signing_keyshare,omitempty"`
	unknownFields   protoimpl.UnknownFields
	sizeCache       protoimpl.SizeCache
}

func (x *SigningResult) Reset() {
	*x = SigningResult{}
	mi := &file_spark_proto_msgTypes[13]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *SigningResult) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*SigningResult) ProtoMessage() {}

func (x *SigningResult) ProtoReflect() protoreflect.Message {
	mi := &file_spark_proto_msgTypes[13]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use SigningResult.ProtoReflect.Descriptor instead.
func (*SigningResult) Descriptor() ([]byte, []int) {
	return file_spark_proto_rawDescGZIP(), []int{13}
}

func (x *SigningResult) GetPublicKeys() map[string][]byte {
	if x != nil {
		return x.PublicKeys
	}
	return nil
}

func (x *SigningResult) GetSigningNonceCommitments() map[string]*common.SigningCommitment {
	if x != nil {
		return x.SigningNonceCommitments
	}
	return nil
}

func (x *SigningResult) GetSignatureShares() map[string][]byte {
	if x != nil {
		return x.SignatureShares
	}
	return nil
}

func (x *SigningResult) GetSigningKeyshare() *SigningKeyshare {
	if x != nil {
		return x.SigningKeyshare
	}
	return nil
}

// *
// NodeSignatureShares is the signature shares for a node on the tree.
// For each tree node, the verifying key stays the same for both transactions.
type NodeSignatureShares struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// The id of the node.
	NodeId string `protobuf:"bytes,1,opt,name=node_id,json=nodeId,proto3" json:"node_id,omitempty"`
	// The signing result of the node's transaction. This transaction is to pay to self.
	NodeTxSigningResult *SigningResult `protobuf:"bytes,2,opt,name=node_tx_signing_result,json=nodeTxSigningResult,proto3" json:"node_tx_signing_result,omitempty"`
	// The signing result of the node's refund transaction. This transaction is to pay to the user.
	RefundTxSigningResult *SigningResult `protobuf:"bytes,3,opt,name=refund_tx_signing_result,json=refundTxSigningResult,proto3" json:"refund_tx_signing_result,omitempty"`
	// The verifying key of the node.
	VerifyingKey  []byte `protobuf:"bytes,4,opt,name=verifying_key,json=verifyingKey,proto3" json:"verifying_key,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *NodeSignatureShares) Reset() {
	*x = NodeSignatureShares{}
	mi := &file_spark_proto_msgTypes[14]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *NodeSignatureShares) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*NodeSignatureShares) ProtoMessage() {}

func (x *NodeSignatureShares) ProtoReflect() protoreflect.Message {
	mi := &file_spark_proto_msgTypes[14]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use NodeSignatureShares.ProtoReflect.Descriptor instead.
func (*NodeSignatureShares) Descriptor() ([]byte, []int) {
	return file_spark_proto_rawDescGZIP(), []int{14}
}

func (x *NodeSignatureShares) GetNodeId() string {
	if x != nil {
		return x.NodeId
	}
	return ""
}

func (x *NodeSignatureShares) GetNodeTxSigningResult() *SigningResult {
	if x != nil {
		return x.NodeTxSigningResult
	}
	return nil
}

func (x *NodeSignatureShares) GetRefundTxSigningResult() *SigningResult {
	if x != nil {
		return x.RefundTxSigningResult
	}
	return nil
}

func (x *NodeSignatureShares) GetVerifyingKey() []byte {
	if x != nil {
		return x.VerifyingKey
	}
	return nil
}

// *
// NodeSignatures is the final signatures for a node on the tree.
// It contains the signature for the node's transaction and refund transaction.
type NodeSignatures struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// The id of the node.
	NodeId string `protobuf:"bytes,1,opt,name=node_id,json=nodeId,proto3" json:"node_id,omitempty"`
	// The final signature of the node's transaction. This transaction is to pay to self.
	NodeTxSignature []byte `protobuf:"bytes,2,opt,name=node_tx_signature,json=nodeTxSignature,proto3" json:"node_tx_signature,omitempty"`
	// The final signature of the node's refund transaction. This transaction is to pay to the user.
	RefundTxSignature []byte `protobuf:"bytes,3,opt,name=refund_tx_signature,json=refundTxSignature,proto3" json:"refund_tx_signature,omitempty"`
	unknownFields     protoimpl.UnknownFields
	sizeCache         protoimpl.SizeCache
}

func (x *NodeSignatures) Reset() {
	*x = NodeSignatures{}
	mi := &file_spark_proto_msgTypes[15]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *NodeSignatures) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*NodeSignatures) ProtoMessage() {}

func (x *NodeSignatures) ProtoReflect() protoreflect.Message {
	mi := &file_spark_proto_msgTypes[15]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use NodeSignatures.ProtoReflect.Descriptor instead.
func (*NodeSignatures) Descriptor() ([]byte, []int) {
	return file_spark_proto_rawDescGZIP(), []int{15}
}

func (x *NodeSignatures) GetNodeId() string {
	if x != nil {
		return x.NodeId
	}
	return ""
}

func (x *NodeSignatures) GetNodeTxSignature() []byte {
	if x != nil {
		return x.NodeTxSignature
	}
	return nil
}

func (x *NodeSignatures) GetRefundTxSignature() []byte {
	if x != nil {
		return x.RefundTxSignature
	}
	return nil
}

// *
// StartTreeCreationRequest is the request to start the tree creation for a tree root node.
type StartTreeCreationRequest struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// The identity public key of the user.
	IdentityPublicKey []byte `protobuf:"bytes,1,opt,name=identity_public_key,json=identityPublicKey,proto3" json:"identity_public_key,omitempty"`
	// The on-chain utxo to be used to be spent by the root node.
	OnChainUtxo *UTXO `protobuf:"bytes,2,opt,name=on_chain_utxo,json=onChainUtxo,proto3" json:"on_chain_utxo,omitempty"`
	// The signing job for the root node's transaction.
	RootTxSigningJob *SigningJob `protobuf:"bytes,3,opt,name=root_tx_signing_job,json=rootTxSigningJob,proto3" json:"root_tx_signing_job,omitempty"`
	// The signing job for the root node's refund transaction.
	RefundTxSigningJob *SigningJob `protobuf:"bytes,4,opt,name=refund_tx_signing_job,json=refundTxSigningJob,proto3" json:"refund_tx_signing_job,omitempty"`
	unknownFields      protoimpl.UnknownFields
	sizeCache          protoimpl.SizeCache
}

func (x *StartTreeCreationRequest) Reset() {
	*x = StartTreeCreationRequest{}
	mi := &file_spark_proto_msgTypes[16]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *StartTreeCreationRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*StartTreeCreationRequest) ProtoMessage() {}

func (x *StartTreeCreationRequest) ProtoReflect() protoreflect.Message {
	mi := &file_spark_proto_msgTypes[16]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use StartTreeCreationRequest.ProtoReflect.Descriptor instead.
func (*StartTreeCreationRequest) Descriptor() ([]byte, []int) {
	return file_spark_proto_rawDescGZIP(), []int{16}
}

func (x *StartTreeCreationRequest) GetIdentityPublicKey() []byte {
	if x != nil {
		return x.IdentityPublicKey
	}
	return nil
}

func (x *StartTreeCreationRequest) GetOnChainUtxo() *UTXO {
	if x != nil {
		return x.OnChainUtxo
	}
	return nil
}

func (x *StartTreeCreationRequest) GetRootTxSigningJob() *SigningJob {
	if x != nil {
		return x.RootTxSigningJob
	}
	return nil
}

func (x *StartTreeCreationRequest) GetRefundTxSigningJob() *SigningJob {
	if x != nil {
		return x.RefundTxSigningJob
	}
	return nil
}

// *
// StartTreeCreationResponse is the response to the request to start the tree creation for a tree root node.
type StartTreeCreationResponse struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// The id of the tree.
	TreeId string `protobuf:"bytes,1,opt,name=tree_id,json=treeId,proto3" json:"tree_id,omitempty"`
	// The signature shares for the root node.
	RootNodeSignatureShares *NodeSignatureShares `protobuf:"bytes,2,opt,name=root_node_signature_shares,json=rootNodeSignatureShares,proto3" json:"root_node_signature_shares,omitempty"`
	unknownFields           protoimpl.UnknownFields
	sizeCache               protoimpl.SizeCache
}

func (x *StartTreeCreationResponse) Reset() {
	*x = StartTreeCreationResponse{}
	mi := &file_spark_proto_msgTypes[17]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *StartTreeCreationResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*StartTreeCreationResponse) ProtoMessage() {}

func (x *StartTreeCreationResponse) ProtoReflect() protoreflect.Message {
	mi := &file_spark_proto_msgTypes[17]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use StartTreeCreationResponse.ProtoReflect.Descriptor instead.
func (*StartTreeCreationResponse) Descriptor() ([]byte, []int) {
	return file_spark_proto_rawDescGZIP(), []int{17}
}

func (x *StartTreeCreationResponse) GetTreeId() string {
	if x != nil {
		return x.TreeId
	}
	return ""
}

func (x *StartTreeCreationResponse) GetRootNodeSignatureShares() *NodeSignatureShares {
	if x != nil {
		return x.RootNodeSignatureShares
	}
	return nil
}

// *
// StartDepositTreeCreationRequest is the request to start the tree creation for a tree root node.
type StartDepositTreeCreationRequest struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// The identity public key of the user.
	IdentityPublicKey []byte `protobuf:"bytes,1,opt,name=identity_public_key,json=identityPublicKey,proto3" json:"identity_public_key,omitempty"`
	// The on-chain utxo to be used to be spent by the root node.
	OnChainUtxo *UTXO `protobuf:"bytes,2,opt,name=on_chain_utxo,json=onChainUtxo,proto3" json:"on_chain_utxo,omitempty"`
	// The signing job for the root node's transaction.
	RootTxSigningJob *SigningJob `protobuf:"bytes,3,opt,name=root_tx_signing_job,json=rootTxSigningJob,proto3" json:"root_tx_signing_job,omitempty"`
	// The signing job for the root node's refund transaction.
	RefundTxSigningJob *SigningJob `protobuf:"bytes,4,opt,name=refund_tx_signing_job,json=refundTxSigningJob,proto3" json:"refund_tx_signing_job,omitempty"`
	unknownFields      protoimpl.UnknownFields
	sizeCache          protoimpl.SizeCache
}

func (x *StartDepositTreeCreationRequest) Reset() {
	*x = StartDepositTreeCreationRequest{}
	mi := &file_spark_proto_msgTypes[18]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *StartDepositTreeCreationRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*StartDepositTreeCreationRequest) ProtoMessage() {}

func (x *StartDepositTreeCreationRequest) ProtoReflect() protoreflect.Message {
	mi := &file_spark_proto_msgTypes[18]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use StartDepositTreeCreationRequest.ProtoReflect.Descriptor instead.
func (*StartDepositTreeCreationRequest) Descriptor() ([]byte, []int) {
	return file_spark_proto_rawDescGZIP(), []int{18}
}

func (x *StartDepositTreeCreationRequest) GetIdentityPublicKey() []byte {
	if x != nil {
		return x.IdentityPublicKey
	}
	return nil
}

func (x *StartDepositTreeCreationRequest) GetOnChainUtxo() *UTXO {
	if x != nil {
		return x.OnChainUtxo
	}
	return nil
}

func (x *StartDepositTreeCreationRequest) GetRootTxSigningJob() *SigningJob {
	if x != nil {
		return x.RootTxSigningJob
	}
	return nil
}

func (x *StartDepositTreeCreationRequest) GetRefundTxSigningJob() *SigningJob {
	if x != nil {
		return x.RefundTxSigningJob
	}
	return nil
}

// *
// StartDepositTreeCreationResponse is the response to the request to start the tree creation for a tree root node.
type StartDepositTreeCreationResponse struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// The id of the tree.
	TreeId string `protobuf:"bytes,1,opt,name=tree_id,json=treeId,proto3" json:"tree_id,omitempty"`
	// The signature shares for the root node.
	RootNodeSignatureShares *NodeSignatureShares `protobuf:"bytes,2,opt,name=root_node_signature_shares,json=rootNodeSignatureShares,proto3" json:"root_node_signature_shares,omitempty"`
	unknownFields           protoimpl.UnknownFields
	sizeCache               protoimpl.SizeCache
}

func (x *StartDepositTreeCreationResponse) Reset() {
	*x = StartDepositTreeCreationResponse{}
	mi := &file_spark_proto_msgTypes[19]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *StartDepositTreeCreationResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*StartDepositTreeCreationResponse) ProtoMessage() {}

func (x *StartDepositTreeCreationResponse) ProtoReflect() protoreflect.Message {
	mi := &file_spark_proto_msgTypes[19]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use StartDepositTreeCreationResponse.ProtoReflect.Descriptor instead.
func (*StartDepositTreeCreationResponse) Descriptor() ([]byte, []int) {
	return file_spark_proto_rawDescGZIP(), []int{19}
}

func (x *StartDepositTreeCreationResponse) GetTreeId() string {
	if x != nil {
		return x.TreeId
	}
	return ""
}

func (x *StartDepositTreeCreationResponse) GetRootNodeSignatureShares() *NodeSignatureShares {
	if x != nil {
		return x.RootNodeSignatureShares
	}
	return nil
}

// This proto is constructed by the wallet to specify leaves it wants to spend as
// part of the token transaction.
type TokenOutputToSpend struct {
	state                    protoimpl.MessageState `protogen:"open.v1"`
	PrevTokenTransactionHash []byte                 `protobuf:"bytes,1,opt,name=prev_token_transaction_hash,json=prevTokenTransactionHash,proto3" json:"prev_token_transaction_hash,omitempty"`
	PrevTokenTransactionVout uint32                 `protobuf:"varint,2,opt,name=prev_token_transaction_vout,json=prevTokenTransactionVout,proto3" json:"prev_token_transaction_vout,omitempty"`
	unknownFields            protoimpl.UnknownFields
	sizeCache                protoimpl.SizeCache
}

func (x *TokenOutputToSpend) Reset() {
	*x = TokenOutputToSpend{}
	mi := &file_spark_proto_msgTypes[20]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *TokenOutputToSpend) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*TokenOutputToSpend) ProtoMessage() {}

func (x *TokenOutputToSpend) ProtoReflect() protoreflect.Message {
	mi := &file_spark_proto_msgTypes[20]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use TokenOutputToSpend.ProtoReflect.Descriptor instead.
func (*TokenOutputToSpend) Descriptor() ([]byte, []int) {
	return file_spark_proto_rawDescGZIP(), []int{20}
}

func (x *TokenOutputToSpend) GetPrevTokenTransactionHash() []byte {
	if x != nil {
		return x.PrevTokenTransactionHash
	}
	return nil
}

func (x *TokenOutputToSpend) GetPrevTokenTransactionVout() uint32 {
	if x != nil {
		return x.PrevTokenTransactionVout
	}
	return 0
}

type TokenTransferInput struct {
	state          protoimpl.MessageState `protogen:"open.v1"`
	OutputsToSpend []*TokenOutputToSpend  `protobuf:"bytes,1,rep,name=outputs_to_spend,json=outputsToSpend,proto3" json:"outputs_to_spend,omitempty"`
	unknownFields  protoimpl.UnknownFields
	sizeCache      protoimpl.SizeCache
}

func (x *TokenTransferInput) Reset() {
	*x = TokenTransferInput{}
	mi := &file_spark_proto_msgTypes[21]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *TokenTransferInput) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*TokenTransferInput) ProtoMessage() {}

func (x *TokenTransferInput) ProtoReflect() protoreflect.Message {
	mi := &file_spark_proto_msgTypes[21]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use TokenTransferInput.ProtoReflect.Descriptor instead.
func (*TokenTransferInput) Descriptor() ([]byte, []int) {
	return file_spark_proto_rawDescGZIP(), []int{21}
}

func (x *TokenTransferInput) GetOutputsToSpend() []*TokenOutputToSpend {
	if x != nil {
		return x.OutputsToSpend
	}
	return nil
}

type TokenMintInput struct {
	state           protoimpl.MessageState `protogen:"open.v1"`
	IssuerPublicKey []byte                 `protobuf:"bytes,1,opt,name=issuer_public_key,json=issuerPublicKey,proto3" json:"issuer_public_key,omitempty"`
	// Issuer provided timestamp of when the transaction was signed/constructed.
	// Helps provide idempotency and ensures that each mint input signature is unique
	// as long as multiple mint signatures are not happening at the same time. Also gives a
	// potentially useful data point for when the issuer authorized from their
	// perspective.  Note that we have no way of proving this is accurate.
	// TODO: Consider whether implementing generic idempotency controls and/or a
	// random nonce would be favorable to populating this field.
	IssuerProvidedTimestamp uint64 `protobuf:"varint,2,opt,name=issuer_provided_timestamp,json=issuerProvidedTimestamp,proto3" json:"issuer_provided_timestamp,omitempty"`
	unknownFields           protoimpl.UnknownFields
	sizeCache               protoimpl.SizeCache
}

func (x *TokenMintInput) Reset() {
	*x = TokenMintInput{}
	mi := &file_spark_proto_msgTypes[22]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *TokenMintInput) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*TokenMintInput) ProtoMessage() {}

func (x *TokenMintInput) ProtoReflect() protoreflect.Message {
	mi := &file_spark_proto_msgTypes[22]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use TokenMintInput.ProtoReflect.Descriptor instead.
func (*TokenMintInput) Descriptor() ([]byte, []int) {
	return file_spark_proto_rawDescGZIP(), []int{22}
}

func (x *TokenMintInput) GetIssuerPublicKey() []byte {
	if x != nil {
		return x.IssuerPublicKey
	}
	return nil
}

func (x *TokenMintInput) GetIssuerProvidedTimestamp() uint64 {
	if x != nil {
		return x.IssuerProvidedTimestamp
	}
	return 0
}

// This proto is constructed by the wallet to specify outputs it wants to create
// as part of a token transaction. Output id and revocation public key should remain unfilled
// so that the SE can fill them as part of the StartTokenTransaction() call.
type TokenOutput struct {
	state                         protoimpl.MessageState `protogen:"open.v1"`
	Id                            *string                `protobuf:"bytes,1,opt,name=id,proto3,oneof" json:"id,omitempty"`
	OwnerPublicKey                []byte                 `protobuf:"bytes,2,opt,name=owner_public_key,json=ownerPublicKey,proto3" json:"owner_public_key,omitempty"`
	RevocationCommitment          []byte                 `protobuf:"bytes,3,opt,name=revocation_commitment,json=revocationCommitment,proto3,oneof" json:"revocation_commitment,omitempty"`
	WithdrawBondSats              *uint64                `protobuf:"varint,4,opt,name=withdraw_bond_sats,json=withdrawBondSats,proto3,oneof" json:"withdraw_bond_sats,omitempty"`
	WithdrawRelativeBlockLocktime *uint64                `protobuf:"varint,5,opt,name=withdraw_relative_block_locktime,json=withdrawRelativeBlockLocktime,proto3,oneof" json:"withdraw_relative_block_locktime,omitempty"`
	TokenPublicKey                []byte                 `protobuf:"bytes,6,opt,name=token_public_key,json=tokenPublicKey,proto3" json:"token_public_key,omitempty"`
	TokenAmount                   []byte                 `protobuf:"bytes,7,opt,name=token_amount,json=tokenAmount,proto3" json:"token_amount,omitempty"` // Decoded uint128
	unknownFields                 protoimpl.UnknownFields
	sizeCache                     protoimpl.SizeCache
}

func (x *TokenOutput) Reset() {
	*x = TokenOutput{}
	mi := &file_spark_proto_msgTypes[23]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *TokenOutput) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*TokenOutput) ProtoMessage() {}

func (x *TokenOutput) ProtoReflect() protoreflect.Message {
	mi := &file_spark_proto_msgTypes[23]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use TokenOutput.ProtoReflect.Descriptor instead.
func (*TokenOutput) Descriptor() ([]byte, []int) {
	return file_spark_proto_rawDescGZIP(), []int{23}
}

func (x *TokenOutput) GetId() string {
	if x != nil && x.Id != nil {
		return *x.Id
	}
	return ""
}

func (x *TokenOutput) GetOwnerPublicKey() []byte {
	if x != nil {
		return x.OwnerPublicKey
	}
	return nil
}

func (x *TokenOutput) GetRevocationCommitment() []byte {
	if x != nil {
		return x.RevocationCommitment
	}
	return nil
}

func (x *TokenOutput) GetWithdrawBondSats() uint64 {
	if x != nil && x.WithdrawBondSats != nil {
		return *x.WithdrawBondSats
	}
	return 0
}

func (x *TokenOutput) GetWithdrawRelativeBlockLocktime() uint64 {
	if x != nil && x.WithdrawRelativeBlockLocktime != nil {
		return *x.WithdrawRelativeBlockLocktime
	}
	return 0
}

func (x *TokenOutput) GetTokenPublicKey() []byte {
	if x != nil {
		return x.TokenPublicKey
	}
	return nil
}

func (x *TokenOutput) GetTokenAmount() []byte {
	if x != nil {
		return x.TokenAmount
	}
	return nil
}

// This proto is constructed by the wallet and is the core transaction data structure.
// This proto is deterministically hashed to generate the token_transaction_hash that
// is cooperatively signed by the SO group to confirm a token transaction.
type TokenTransaction struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// For mint transactions issuer_public_key will be specified without any outputs_to_spend.
	// For transfer transactions the token amount in the input leaves must match the token amount in the output leaves.
	//
	// Types that are valid to be assigned to TokenInputs:
	//
	//	*TokenTransaction_MintInput
	//	*TokenTransaction_TransferInput
	TokenInputs                     isTokenTransaction_TokenInputs `protobuf_oneof:"token_inputs"`
	TokenOutputs                    []*TokenOutput                 `protobuf:"bytes,3,rep,name=token_outputs,json=tokenOutputs,proto3" json:"token_outputs,omitempty"`
	SparkOperatorIdentityPublicKeys [][]byte                       `protobuf:"bytes,4,rep,name=spark_operator_identity_public_keys,json=sparkOperatorIdentityPublicKeys,proto3" json:"spark_operator_identity_public_keys,omitempty"`
	Network                         Network                        `protobuf:"varint,10,opt,name=network,proto3,enum=spark.Network" json:"network,omitempty"`
	unknownFields                   protoimpl.UnknownFields
	sizeCache                       protoimpl.SizeCache
}

func (x *TokenTransaction) Reset() {
	*x = TokenTransaction{}
	mi := &file_spark_proto_msgTypes[24]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *TokenTransaction) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*TokenTransaction) ProtoMessage() {}

func (x *TokenTransaction) ProtoReflect() protoreflect.Message {
	mi := &file_spark_proto_msgTypes[24]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use TokenTransaction.ProtoReflect.Descriptor instead.
func (*TokenTransaction) Descriptor() ([]byte, []int) {
	return file_spark_proto_rawDescGZIP(), []int{24}
}

func (x *TokenTransaction) GetTokenInputs() isTokenTransaction_TokenInputs {
	if x != nil {
		return x.TokenInputs
	}
	return nil
}

func (x *TokenTransaction) GetMintInput() *TokenMintInput {
	if x != nil {
		if x, ok := x.TokenInputs.(*TokenTransaction_MintInput); ok {
			return x.MintInput
		}
	}
	return nil
}

func (x *TokenTransaction) GetTransferInput() *TokenTransferInput {
	if x != nil {
		if x, ok := x.TokenInputs.(*TokenTransaction_TransferInput); ok {
			return x.TransferInput
		}
	}
	return nil
}

func (x *TokenTransaction) GetTokenOutputs() []*TokenOutput {
	if x != nil {
		return x.TokenOutputs
	}
	return nil
}

func (x *TokenTransaction) GetSparkOperatorIdentityPublicKeys() [][]byte {
	if x != nil {
		return x.SparkOperatorIdentityPublicKeys
	}
	return nil
}

func (x *TokenTransaction) GetNetwork() Network {
	if x != nil {
		return x.Network
	}
	return Network_UNSPECIFIED
}

type isTokenTransaction_TokenInputs interface {
	isTokenTransaction_TokenInputs()
}

type TokenTransaction_MintInput struct {
	MintInput *TokenMintInput `protobuf:"bytes,1,opt,name=mint_input,json=mintInput,proto3,oneof"`
}

type TokenTransaction_TransferInput struct {
	TransferInput *TokenTransferInput `protobuf:"bytes,2,opt,name=transfer_input,json=transferInput,proto3,oneof"`
}

func (*TokenTransaction_MintInput) isTokenTransaction_TokenInputs() {}

func (*TokenTransaction_TransferInput) isTokenTransaction_TokenInputs() {}

type TokenTransactionWithStatus struct {
	state            protoimpl.MessageState `protogen:"open.v1"`
	TokenTransaction *TokenTransaction      `protobuf:"bytes,1,opt,name=token_transaction,json=tokenTransaction,proto3" json:"token_transaction,omitempty"`
	Status           TokenTransactionStatus `protobuf:"varint,2,opt,name=status,proto3,enum=spark.TokenTransactionStatus" json:"status,omitempty"`
	unknownFields    protoimpl.UnknownFields
	sizeCache        protoimpl.SizeCache
}

func (x *TokenTransactionWithStatus) Reset() {
	*x = TokenTransactionWithStatus{}
	mi := &file_spark_proto_msgTypes[25]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *TokenTransactionWithStatus) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*TokenTransactionWithStatus) ProtoMessage() {}

func (x *TokenTransactionWithStatus) ProtoReflect() protoreflect.Message {
	mi := &file_spark_proto_msgTypes[25]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use TokenTransactionWithStatus.ProtoReflect.Descriptor instead.
func (*TokenTransactionWithStatus) Descriptor() ([]byte, []int) {
	return file_spark_proto_rawDescGZIP(), []int{25}
}

func (x *TokenTransactionWithStatus) GetTokenTransaction() *TokenTransaction {
	if x != nil {
		return x.TokenTransaction
	}
	return nil
}

func (x *TokenTransactionWithStatus) GetStatus() TokenTransactionStatus {
	if x != nil {
		return x.Status
	}
	return TokenTransactionStatus_TOKEN_TRANSACTION_STARTED
}

type SignatureWithIndex struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// This is a Schnorr or ECDSA DER signature which can be between 64 and 73 bytes.
	Signature []byte `protobuf:"bytes,1,opt,name=signature,proto3" json:"signature,omitempty"`
	// The index of the TTXO associated with this signature.
	InputIndex    uint32 `protobuf:"varint,2,opt,name=input_index,json=inputIndex,proto3" json:"input_index,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *SignatureWithIndex) Reset() {
	*x = SignatureWithIndex{}
	mi := &file_spark_proto_msgTypes[26]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *SignatureWithIndex) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*SignatureWithIndex) ProtoMessage() {}

func (x *SignatureWithIndex) ProtoReflect() protoreflect.Message {
	mi := &file_spark_proto_msgTypes[26]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use SignatureWithIndex.ProtoReflect.Descriptor instead.
func (*SignatureWithIndex) Descriptor() ([]byte, []int) {
	return file_spark_proto_rawDescGZIP(), []int{26}
}

func (x *SignatureWithIndex) GetSignature() []byte {
	if x != nil {
		return x.Signature
	}
	return nil
}

func (x *SignatureWithIndex) GetInputIndex() uint32 {
	if x != nil {
		return x.InputIndex
	}
	return 0
}

type TokenTransactionSignatures struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Filled by signing the partial token transaction hash with the owner/issuer private key.
	// For mint transactions this will be one signature for the input issuer_public_key
	// For transfer transactions this will be one for each output for the output owner_public_key
	OwnerSignatures []*SignatureWithIndex `protobuf:"bytes,1,rep,name=owner_signatures,json=ownerSignatures,proto3" json:"owner_signatures,omitempty"`
	unknownFields   protoimpl.UnknownFields
	sizeCache       protoimpl.SizeCache
}

func (x *TokenTransactionSignatures) Reset() {
	*x = TokenTransactionSignatures{}
	mi := &file_spark_proto_msgTypes[27]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *TokenTransactionSignatures) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*TokenTransactionSignatures) ProtoMessage() {}

func (x *TokenTransactionSignatures) ProtoReflect() protoreflect.Message {
	mi := &file_spark_proto_msgTypes[27]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use TokenTransactionSignatures.ProtoReflect.Descriptor instead.
func (*TokenTransactionSignatures) Descriptor() ([]byte, []int) {
	return file_spark_proto_rawDescGZIP(), []int{27}
}

func (x *TokenTransactionSignatures) GetOwnerSignatures() []*SignatureWithIndex {
	if x != nil {
		return x.OwnerSignatures
	}
	return nil
}

type StartTokenTransactionRequest struct {
	state                   protoimpl.MessageState `protogen:"open.v1"`
	IdentityPublicKey       []byte                 `protobuf:"bytes,1,opt,name=identity_public_key,json=identityPublicKey,proto3" json:"identity_public_key,omitempty"`
	PartialTokenTransaction *TokenTransaction      `protobuf:"bytes,2,opt,name=partial_token_transaction,json=partialTokenTransaction,proto3" json:"partial_token_transaction,omitempty"`
	// List of ecdsa signatures authorizing movement of tokens from the token input.
	TokenTransactionSignatures *TokenTransactionSignatures `protobuf:"bytes,3,opt,name=token_transaction_signatures,json=tokenTransactionSignatures,proto3" json:"token_transaction_signatures,omitempty"`
	unknownFields              protoimpl.UnknownFields
	sizeCache                  protoimpl.SizeCache
}

func (x *StartTokenTransactionRequest) Reset() {
	*x = StartTokenTransactionRequest{}
	mi := &file_spark_proto_msgTypes[28]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *StartTokenTransactionRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*StartTokenTransactionRequest) ProtoMessage() {}

func (x *StartTokenTransactionRequest) ProtoReflect() protoreflect.Message {
	mi := &file_spark_proto_msgTypes[28]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use StartTokenTransactionRequest.ProtoReflect.Descriptor instead.
func (*StartTokenTransactionRequest) Descriptor() ([]byte, []int) {
	return file_spark_proto_rawDescGZIP(), []int{28}
}

func (x *StartTokenTransactionRequest) GetIdentityPublicKey() []byte {
	if x != nil {
		return x.IdentityPublicKey
	}
	return nil
}

func (x *StartTokenTransactionRequest) GetPartialTokenTransaction() *TokenTransaction {
	if x != nil {
		return x.PartialTokenTransaction
	}
	return nil
}

func (x *StartTokenTransactionRequest) GetTokenTransactionSignatures() *TokenTransactionSignatures {
	if x != nil {
		return x.TokenTransactionSignatures
	}
	return nil
}

type StartTokenTransactionResponse struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// This is the same token transaction sent by the wallet with output revocation public keys
	// filled. This is the final transaction that is published and gossiped among LRC20 nodes.
	FinalTokenTransaction *TokenTransaction `protobuf:"bytes,1,opt,name=final_token_transaction,json=finalTokenTransaction,proto3" json:"final_token_transaction,omitempty"`
	// Information for fetching and resolving the revocation keyshare on a transfer operation.
	// Contains the threshold of keyshares needed and the SO owners of those keyshares.
	KeyshareInfo  *SigningKeyshare `protobuf:"bytes,2,opt,name=keyshare_info,json=keyshareInfo,proto3" json:"keyshare_info,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *StartTokenTransactionResponse) Reset() {
	*x = StartTokenTransactionResponse{}
	mi := &file_spark_proto_msgTypes[29]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *StartTokenTransactionResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*StartTokenTransactionResponse) ProtoMessage() {}

func (x *StartTokenTransactionResponse) ProtoReflect() protoreflect.Message {
	mi := &file_spark_proto_msgTypes[29]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use StartTokenTransactionResponse.ProtoReflect.Descriptor instead.
func (*StartTokenTransactionResponse) Descriptor() ([]byte, []int) {
	return file_spark_proto_rawDescGZIP(), []int{29}
}

func (x *StartTokenTransactionResponse) GetFinalTokenTransaction() *TokenTransaction {
	if x != nil {
		return x.FinalTokenTransaction
	}
	return nil
}

func (x *StartTokenTransactionResponse) GetKeyshareInfo() *SigningKeyshare {
	if x != nil {
		return x.KeyshareInfo
	}
	return nil
}

type OperatorSpecificTokenTransactionSignablePayload struct {
	state                     protoimpl.MessageState `protogen:"open.v1"`
	FinalTokenTransactionHash []byte                 `protobuf:"bytes,1,opt,name=final_token_transaction_hash,json=finalTokenTransactionHash,proto3" json:"final_token_transaction_hash,omitempty"`
	OperatorIdentityPublicKey []byte                 `protobuf:"bytes,2,opt,name=operator_identity_public_key,json=operatorIdentityPublicKey,proto3" json:"operator_identity_public_key,omitempty"`
	unknownFields             protoimpl.UnknownFields
	sizeCache                 protoimpl.SizeCache
}

func (x *OperatorSpecificTokenTransactionSignablePayload) Reset() {
	*x = OperatorSpecificTokenTransactionSignablePayload{}
	mi := &file_spark_proto_msgTypes[30]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *OperatorSpecificTokenTransactionSignablePayload) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*OperatorSpecificTokenTransactionSignablePayload) ProtoMessage() {}

func (x *OperatorSpecificTokenTransactionSignablePayload) ProtoReflect() protoreflect.Message {
	mi := &file_spark_proto_msgTypes[30]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use OperatorSpecificTokenTransactionSignablePayload.ProtoReflect.Descriptor instead.
func (*OperatorSpecificTokenTransactionSignablePayload) Descriptor() ([]byte, []int) {
	return file_spark_proto_rawDescGZIP(), []int{30}
}

func (x *OperatorSpecificTokenTransactionSignablePayload) GetFinalTokenTransactionHash() []byte {
	if x != nil {
		return x.FinalTokenTransactionHash
	}
	return nil
}

func (x *OperatorSpecificTokenTransactionSignablePayload) GetOperatorIdentityPublicKey() []byte {
	if x != nil {
		return x.OperatorIdentityPublicKey
	}
	return nil
}

// This message allows the sender of a output being spent to provide final evidence
// that it owns a output to an SO when requesting signing and release of the  revocation keyshare.
type OperatorSpecificOwnerSignature struct {
	state          protoimpl.MessageState                           `protogen:"open.v1"`
	OwnerSignature *SignatureWithIndex                              `protobuf:"bytes,1,opt,name=owner_signature,json=ownerSignature,proto3" json:"owner_signature,omitempty"`
	Payload        *OperatorSpecificTokenTransactionSignablePayload `protobuf:"bytes,2,opt,name=payload,proto3" json:"payload,omitempty"`
	unknownFields  protoimpl.UnknownFields
	sizeCache      protoimpl.SizeCache
}

func (x *OperatorSpecificOwnerSignature) Reset() {
	*x = OperatorSpecificOwnerSignature{}
	mi := &file_spark_proto_msgTypes[31]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *OperatorSpecificOwnerSignature) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*OperatorSpecificOwnerSignature) ProtoMessage() {}

func (x *OperatorSpecificOwnerSignature) ProtoReflect() protoreflect.Message {
	mi := &file_spark_proto_msgTypes[31]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use OperatorSpecificOwnerSignature.ProtoReflect.Descriptor instead.
func (*OperatorSpecificOwnerSignature) Descriptor() ([]byte, []int) {
	return file_spark_proto_rawDescGZIP(), []int{31}
}

func (x *OperatorSpecificOwnerSignature) GetOwnerSignature() *SignatureWithIndex {
	if x != nil {
		return x.OwnerSignature
	}
	return nil
}

func (x *OperatorSpecificOwnerSignature) GetPayload() *OperatorSpecificTokenTransactionSignablePayload {
	if x != nil {
		return x.Payload
	}
	return nil
}

type SignTokenTransactionRequest struct {
	state                      protoimpl.MessageState            `protogen:"open.v1"`
	FinalTokenTransaction      *TokenTransaction                 `protobuf:"bytes,1,opt,name=final_token_transaction,json=finalTokenTransaction,proto3" json:"final_token_transaction,omitempty"`
	OperatorSpecificSignatures []*OperatorSpecificOwnerSignature `protobuf:"bytes,2,rep,name=operator_specific_signatures,json=operatorSpecificSignatures,proto3" json:"operator_specific_signatures,omitempty"`
	IdentityPublicKey          []byte                            `protobuf:"bytes,3,opt,name=identity_public_key,json=identityPublicKey,proto3" json:"identity_public_key,omitempty"`
	unknownFields              protoimpl.UnknownFields
	sizeCache                  protoimpl.SizeCache
}

func (x *SignTokenTransactionRequest) Reset() {
	*x = SignTokenTransactionRequest{}
	mi := &file_spark_proto_msgTypes[32]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *SignTokenTransactionRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*SignTokenTransactionRequest) ProtoMessage() {}

func (x *SignTokenTransactionRequest) ProtoReflect() protoreflect.Message {
	mi := &file_spark_proto_msgTypes[32]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use SignTokenTransactionRequest.ProtoReflect.Descriptor instead.
func (*SignTokenTransactionRequest) Descriptor() ([]byte, []int) {
	return file_spark_proto_rawDescGZIP(), []int{32}
}

func (x *SignTokenTransactionRequest) GetFinalTokenTransaction() *TokenTransaction {
	if x != nil {
		return x.FinalTokenTransaction
	}
	return nil
}

func (x *SignTokenTransactionRequest) GetOperatorSpecificSignatures() []*OperatorSpecificOwnerSignature {
	if x != nil {
		return x.OperatorSpecificSignatures
	}
	return nil
}

func (x *SignTokenTransactionRequest) GetIdentityPublicKey() []byte {
	if x != nil {
		return x.IdentityPublicKey
	}
	return nil
}

type KeyshareWithIndex struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// The index of the input TTXO associated with this keyshare.
	InputIndex    uint32 `protobuf:"varint,1,opt,name=input_index,json=inputIndex,proto3" json:"input_index,omitempty"`
	Keyshare      []byte `protobuf:"bytes,2,opt,name=keyshare,proto3" json:"keyshare,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *KeyshareWithIndex) Reset() {
	*x = KeyshareWithIndex{}
	mi := &file_spark_proto_msgTypes[33]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *KeyshareWithIndex) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*KeyshareWithIndex) ProtoMessage() {}

func (x *KeyshareWithIndex) ProtoReflect() protoreflect.Message {
	mi := &file_spark_proto_msgTypes[33]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use KeyshareWithIndex.ProtoReflect.Descriptor instead.
func (*KeyshareWithIndex) Descriptor() ([]byte, []int) {
	return file_spark_proto_rawDescGZIP(), []int{33}
}

func (x *KeyshareWithIndex) GetInputIndex() uint32 {
	if x != nil {
		return x.InputIndex
	}
	return 0
}

func (x *KeyshareWithIndex) GetKeyshare() []byte {
	if x != nil {
		return x.Keyshare
	}
	return nil
}

type SignTokenTransactionResponse struct {
	state                  protoimpl.MessageState `protogen:"open.v1"`
	SparkOperatorSignature []byte                 `protobuf:"bytes,1,opt,name=spark_operator_signature,json=sparkOperatorSignature,proto3" json:"spark_operator_signature,omitempty"`
	RevocationKeyshares    []*KeyshareWithIndex   `protobuf:"bytes,2,rep,name=revocation_keyshares,json=revocationKeyshares,proto3" json:"revocation_keyshares,omitempty"`
	unknownFields          protoimpl.UnknownFields
	sizeCache              protoimpl.SizeCache
}

func (x *SignTokenTransactionResponse) Reset() {
	*x = SignTokenTransactionResponse{}
	mi := &file_spark_proto_msgTypes[34]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *SignTokenTransactionResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*SignTokenTransactionResponse) ProtoMessage() {}

func (x *SignTokenTransactionResponse) ProtoReflect() protoreflect.Message {
	mi := &file_spark_proto_msgTypes[34]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use SignTokenTransactionResponse.ProtoReflect.Descriptor instead.
func (*SignTokenTransactionResponse) Descriptor() ([]byte, []int) {
	return file_spark_proto_rawDescGZIP(), []int{34}
}

func (x *SignTokenTransactionResponse) GetSparkOperatorSignature() []byte {
	if x != nil {
		return x.SparkOperatorSignature
	}
	return nil
}

func (x *SignTokenTransactionResponse) GetRevocationKeyshares() []*KeyshareWithIndex {
	if x != nil {
		return x.RevocationKeyshares
	}
	return nil
}

type RevocationSecretWithIndex struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// The index of the input TTXO associated with this secret.
	InputIndex       uint32 `protobuf:"varint,1,opt,name=input_index,json=inputIndex,proto3" json:"input_index,omitempty"`
	RevocationSecret []byte `protobuf:"bytes,2,opt,name=revocation_secret,json=revocationSecret,proto3" json:"revocation_secret,omitempty"`
	unknownFields    protoimpl.UnknownFields
	sizeCache        protoimpl.SizeCache
}

func (x *RevocationSecretWithIndex) Reset() {
	*x = RevocationSecretWithIndex{}
	mi := &file_spark_proto_msgTypes[35]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *RevocationSecretWithIndex) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*RevocationSecretWithIndex) ProtoMessage() {}

func (x *RevocationSecretWithIndex) ProtoReflect() protoreflect.Message {
	mi := &file_spark_proto_msgTypes[35]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use RevocationSecretWithIndex.ProtoReflect.Descriptor instead.
func (*RevocationSecretWithIndex) Descriptor() ([]byte, []int) {
	return file_spark_proto_rawDescGZIP(), []int{35}
}

func (x *RevocationSecretWithIndex) GetInputIndex() uint32 {
	if x != nil {
		return x.InputIndex
	}
	return 0
}

func (x *RevocationSecretWithIndex) GetRevocationSecret() []byte {
	if x != nil {
		return x.RevocationSecret
	}
	return nil
}

type FinalizeTokenTransactionRequest struct {
	state                 protoimpl.MessageState `protogen:"open.v1"`
	FinalTokenTransaction *TokenTransaction      `protobuf:"bytes,1,opt,name=final_token_transaction,json=finalTokenTransaction,proto3" json:"final_token_transaction,omitempty"`
	// List of ordered revocation secrets that map 1:1 with leaves being spent in the
	// token transaction.
	RevocationSecrets []*RevocationSecretWithIndex `protobuf:"bytes,2,rep,name=revocation_secrets,json=revocationSecrets,proto3" json:"revocation_secrets,omitempty"`
	IdentityPublicKey []byte                       `protobuf:"bytes,3,opt,name=identity_public_key,json=identityPublicKey,proto3" json:"identity_public_key,omitempty"`
	unknownFields     protoimpl.UnknownFields
	sizeCache         protoimpl.SizeCache
}

func (x *FinalizeTokenTransactionRequest) Reset() {
	*x = FinalizeTokenTransactionRequest{}
	mi := &file_spark_proto_msgTypes[36]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *FinalizeTokenTransactionRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*FinalizeTokenTransactionRequest) ProtoMessage() {}

func (x *FinalizeTokenTransactionRequest) ProtoReflect() protoreflect.Message {
	mi := &file_spark_proto_msgTypes[36]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use FinalizeTokenTransactionRequest.ProtoReflect.Descriptor instead.
func (*FinalizeTokenTransactionRequest) Descriptor() ([]byte, []int) {
	return file_spark_proto_rawDescGZIP(), []int{36}
}

func (x *FinalizeTokenTransactionRequest) GetFinalTokenTransaction() *TokenTransaction {
	if x != nil {
		return x.FinalTokenTransaction
	}
	return nil
}

func (x *FinalizeTokenTransactionRequest) GetRevocationSecrets() []*RevocationSecretWithIndex {
	if x != nil {
		return x.RevocationSecrets
	}
	return nil
}

func (x *FinalizeTokenTransactionRequest) GetIdentityPublicKey() []byte {
	if x != nil {
		return x.IdentityPublicKey
	}
	return nil
}

type FreezeTokensPayload struct {
	state                     protoimpl.MessageState `protogen:"open.v1"`
	OwnerPublicKey            []byte                 `protobuf:"bytes,1,opt,name=owner_public_key,json=ownerPublicKey,proto3" json:"owner_public_key,omitempty"`
	TokenPublicKey            []byte                 `protobuf:"bytes,2,opt,name=token_public_key,json=tokenPublicKey,proto3" json:"token_public_key,omitempty"`
	IssuerProvidedTimestamp   uint64                 `protobuf:"varint,3,opt,name=issuer_provided_timestamp,json=issuerProvidedTimestamp,proto3" json:"issuer_provided_timestamp,omitempty"`
	OperatorIdentityPublicKey []byte                 `protobuf:"bytes,4,opt,name=operator_identity_public_key,json=operatorIdentityPublicKey,proto3" json:"operator_identity_public_key,omitempty"`
	// Set to false when requesting a freeze.
	ShouldUnfreeze bool `protobuf:"varint,5,opt,name=should_unfreeze,json=shouldUnfreeze,proto3" json:"should_unfreeze,omitempty"`
	unknownFields  protoimpl.UnknownFields
	sizeCache      protoimpl.SizeCache
}

func (x *FreezeTokensPayload) Reset() {
	*x = FreezeTokensPayload{}
	mi := &file_spark_proto_msgTypes[37]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *FreezeTokensPayload) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*FreezeTokensPayload) ProtoMessage() {}

func (x *FreezeTokensPayload) ProtoReflect() protoreflect.Message {
	mi := &file_spark_proto_msgTypes[37]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use FreezeTokensPayload.ProtoReflect.Descriptor instead.
func (*FreezeTokensPayload) Descriptor() ([]byte, []int) {
	return file_spark_proto_rawDescGZIP(), []int{37}
}

func (x *FreezeTokensPayload) GetOwnerPublicKey() []byte {
	if x != nil {
		return x.OwnerPublicKey
	}
	return nil
}

func (x *FreezeTokensPayload) GetTokenPublicKey() []byte {
	if x != nil {
		return x.TokenPublicKey
	}
	return nil
}

func (x *FreezeTokensPayload) GetIssuerProvidedTimestamp() uint64 {
	if x != nil {
		return x.IssuerProvidedTimestamp
	}
	return 0
}

func (x *FreezeTokensPayload) GetOperatorIdentityPublicKey() []byte {
	if x != nil {
		return x.OperatorIdentityPublicKey
	}
	return nil
}

func (x *FreezeTokensPayload) GetShouldUnfreeze() bool {
	if x != nil {
		return x.ShouldUnfreeze
	}
	return false
}

type FreezeTokensRequest struct {
	state               protoimpl.MessageState `protogen:"open.v1"`
	FreezeTokensPayload *FreezeTokensPayload   `protobuf:"bytes,1,opt,name=freeze_tokens_payload,json=freezeTokensPayload,proto3" json:"freeze_tokens_payload,omitempty"`
	// This is a Schnorr or ECDSA DER signature which can be between 64 and 73 bytes.
	IssuerSignature []byte `protobuf:"bytes,2,opt,name=issuer_signature,json=issuerSignature,proto3" json:"issuer_signature,omitempty"`
	unknownFields   protoimpl.UnknownFields
	sizeCache       protoimpl.SizeCache
}

func (x *FreezeTokensRequest) Reset() {
	*x = FreezeTokensRequest{}
	mi := &file_spark_proto_msgTypes[38]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *FreezeTokensRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*FreezeTokensRequest) ProtoMessage() {}

func (x *FreezeTokensRequest) ProtoReflect() protoreflect.Message {
	mi := &file_spark_proto_msgTypes[38]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use FreezeTokensRequest.ProtoReflect.Descriptor instead.
func (*FreezeTokensRequest) Descriptor() ([]byte, []int) {
	return file_spark_proto_rawDescGZIP(), []int{38}
}

func (x *FreezeTokensRequest) GetFreezeTokensPayload() *FreezeTokensPayload {
	if x != nil {
		return x.FreezeTokensPayload
	}
	return nil
}

func (x *FreezeTokensRequest) GetIssuerSignature() []byte {
	if x != nil {
		return x.IssuerSignature
	}
	return nil
}

type FreezeTokensResponse struct {
	state               protoimpl.MessageState `protogen:"open.v1"`
	ImpactedOutputIds   []string               `protobuf:"bytes,1,rep,name=impacted_output_ids,json=impactedOutputIds,proto3" json:"impacted_output_ids,omitempty"`
	ImpactedTokenAmount []byte                 `protobuf:"bytes,2,opt,name=impacted_token_amount,json=impactedTokenAmount,proto3" json:"impacted_token_amount,omitempty"` // Decoded uint128
	unknownFields       protoimpl.UnknownFields
	sizeCache           protoimpl.SizeCache
}

func (x *FreezeTokensResponse) Reset() {
	*x = FreezeTokensResponse{}
	mi := &file_spark_proto_msgTypes[39]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *FreezeTokensResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*FreezeTokensResponse) ProtoMessage() {}

func (x *FreezeTokensResponse) ProtoReflect() protoreflect.Message {
	mi := &file_spark_proto_msgTypes[39]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use FreezeTokensResponse.ProtoReflect.Descriptor instead.
func (*FreezeTokensResponse) Descriptor() ([]byte, []int) {
	return file_spark_proto_rawDescGZIP(), []int{39}
}

func (x *FreezeTokensResponse) GetImpactedOutputIds() []string {
	if x != nil {
		return x.ImpactedOutputIds
	}
	return nil
}

func (x *FreezeTokensResponse) GetImpactedTokenAmount() []byte {
	if x != nil {
		return x.ImpactedTokenAmount
	}
	return nil
}

type QueryTokenOutputsRequest struct {
	state           protoimpl.MessageState `protogen:"open.v1"`
	OwnerPublicKeys [][]byte               `protobuf:"bytes,1,rep,name=owner_public_keys,json=ownerPublicKeys,proto3" json:"owner_public_keys,omitempty"`
	// Optionally provide token public keys. If not set return leaves for all tokens.
	TokenPublicKeys [][]byte `protobuf:"bytes,2,rep,name=token_public_keys,json=tokenPublicKeys,proto3" json:"token_public_keys,omitempty"`
	unknownFields   protoimpl.UnknownFields
	sizeCache       protoimpl.SizeCache
}

func (x *QueryTokenOutputsRequest) Reset() {
	*x = QueryTokenOutputsRequest{}
	mi := &file_spark_proto_msgTypes[40]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *QueryTokenOutputsRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*QueryTokenOutputsRequest) ProtoMessage() {}

func (x *QueryTokenOutputsRequest) ProtoReflect() protoreflect.Message {
	mi := &file_spark_proto_msgTypes[40]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use QueryTokenOutputsRequest.ProtoReflect.Descriptor instead.
func (*QueryTokenOutputsRequest) Descriptor() ([]byte, []int) {
	return file_spark_proto_rawDescGZIP(), []int{40}
}

func (x *QueryTokenOutputsRequest) GetOwnerPublicKeys() [][]byte {
	if x != nil {
		return x.OwnerPublicKeys
	}
	return nil
}

func (x *QueryTokenOutputsRequest) GetTokenPublicKeys() [][]byte {
	if x != nil {
		return x.TokenPublicKeys
	}
	return nil
}

// Request constraints are combined using an AND relation.
type QueryTokenTransactionsRequest struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Returns transactions that have one of these output ids in the input or output.
	OutputIds []string `protobuf:"bytes,1,rep,name=output_ids,json=outputIds,proto3" json:"output_ids,omitempty"`
	// Returns transactions that have this owner public key as the sender or receiver in one or more of the input/output leaves.
	OwnerPublicKeys [][]byte `protobuf:"bytes,2,rep,name=owner_public_keys,json=ownerPublicKeys,proto3" json:"owner_public_keys,omitempty"`
	// Returns transactions that related to this token public key.
	TokenPublicKeys [][]byte `protobuf:"bytes,3,rep,name=token_public_keys,json=tokenPublicKeys,proto3" json:"token_public_keys,omitempty"`
	// Returns transactions that match the provided transaction hashes.
	TokenTransactionHashes [][]byte `protobuf:"bytes,4,rep,name=token_transaction_hashes,json=tokenTransactionHashes,proto3" json:"token_transaction_hashes,omitempty"`
	Limit                  int64    `protobuf:"varint,5,opt,name=limit,proto3" json:"limit,omitempty"`
	Offset                 int64    `protobuf:"varint,6,opt,name=offset,proto3" json:"offset,omitempty"`
	unknownFields          protoimpl.UnknownFields
	sizeCache              protoimpl.SizeCache
}

func (x *QueryTokenTransactionsRequest) Reset() {
	*x = QueryTokenTransactionsRequest{}
	mi := &file_spark_proto_msgTypes[41]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *QueryTokenTransactionsRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*QueryTokenTransactionsRequest) ProtoMessage() {}

func (x *QueryTokenTransactionsRequest) ProtoReflect() protoreflect.Message {
	mi := &file_spark_proto_msgTypes[41]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use QueryTokenTransactionsRequest.ProtoReflect.Descriptor instead.
func (*QueryTokenTransactionsRequest) Descriptor() ([]byte, []int) {
	return file_spark_proto_rawDescGZIP(), []int{41}
}

func (x *QueryTokenTransactionsRequest) GetOutputIds() []string {
	if x != nil {
		return x.OutputIds
	}
	return nil
}

func (x *QueryTokenTransactionsRequest) GetOwnerPublicKeys() [][]byte {
	if x != nil {
		return x.OwnerPublicKeys
	}
	return nil
}

func (x *QueryTokenTransactionsRequest) GetTokenPublicKeys() [][]byte {
	if x != nil {
		return x.TokenPublicKeys
	}
	return nil
}

func (x *QueryTokenTransactionsRequest) GetTokenTransactionHashes() [][]byte {
	if x != nil {
		return x.TokenTransactionHashes
	}
	return nil
}

func (x *QueryTokenTransactionsRequest) GetLimit() int64 {
	if x != nil {
		return x.Limit
	}
	return 0
}

func (x *QueryTokenTransactionsRequest) GetOffset() int64 {
	if x != nil {
		return x.Offset
	}
	return 0
}

type QueryTokenTransactionsResponse struct {
	state                       protoimpl.MessageState        `protogen:"open.v1"`
	TokenTransactionsWithStatus []*TokenTransactionWithStatus `protobuf:"bytes,1,rep,name=token_transactions_with_status,json=tokenTransactionsWithStatus,proto3" json:"token_transactions_with_status,omitempty"`
	Offset                      int64                         `protobuf:"varint,2,opt,name=offset,proto3" json:"offset,omitempty"`
	unknownFields               protoimpl.UnknownFields
	sizeCache                   protoimpl.SizeCache
}

func (x *QueryTokenTransactionsResponse) Reset() {
	*x = QueryTokenTransactionsResponse{}
	mi := &file_spark_proto_msgTypes[42]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *QueryTokenTransactionsResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*QueryTokenTransactionsResponse) ProtoMessage() {}

func (x *QueryTokenTransactionsResponse) ProtoReflect() protoreflect.Message {
	mi := &file_spark_proto_msgTypes[42]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use QueryTokenTransactionsResponse.ProtoReflect.Descriptor instead.
func (*QueryTokenTransactionsResponse) Descriptor() ([]byte, []int) {
	return file_spark_proto_rawDescGZIP(), []int{42}
}

func (x *QueryTokenTransactionsResponse) GetTokenTransactionsWithStatus() []*TokenTransactionWithStatus {
	if x != nil {
		return x.TokenTransactionsWithStatus
	}
	return nil
}

func (x *QueryTokenTransactionsResponse) GetOffset() int64 {
	if x != nil {
		return x.Offset
	}
	return 0
}

type OutputWithPreviousTransactionData struct {
	state                   protoimpl.MessageState `protogen:"open.v1"`
	Output                  *TokenOutput           `protobuf:"bytes,1,opt,name=output,proto3" json:"output,omitempty"`
	PreviousTransactionHash []byte                 `protobuf:"bytes,2,opt,name=previous_transaction_hash,json=previousTransactionHash,proto3" json:"previous_transaction_hash,omitempty"`
	PreviousTransactionVout uint32                 `protobuf:"varint,3,opt,name=previous_transaction_vout,json=previousTransactionVout,proto3" json:"previous_transaction_vout,omitempty"`
	unknownFields           protoimpl.UnknownFields
	sizeCache               protoimpl.SizeCache
}

func (x *OutputWithPreviousTransactionData) Reset() {
	*x = OutputWithPreviousTransactionData{}
	mi := &file_spark_proto_msgTypes[43]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *OutputWithPreviousTransactionData) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*OutputWithPreviousTransactionData) ProtoMessage() {}

func (x *OutputWithPreviousTransactionData) ProtoReflect() protoreflect.Message {
	mi := &file_spark_proto_msgTypes[43]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use OutputWithPreviousTransactionData.ProtoReflect.Descriptor instead.
func (*OutputWithPreviousTransactionData) Descriptor() ([]byte, []int) {
	return file_spark_proto_rawDescGZIP(), []int{43}
}

func (x *OutputWithPreviousTransactionData) GetOutput() *TokenOutput {
	if x != nil {
		return x.Output
	}
	return nil
}

func (x *OutputWithPreviousTransactionData) GetPreviousTransactionHash() []byte {
	if x != nil {
		return x.PreviousTransactionHash
	}
	return nil
}

func (x *OutputWithPreviousTransactionData) GetPreviousTransactionVout() uint32 {
	if x != nil {
		return x.PreviousTransactionVout
	}
	return 0
}

type QueryTokenOutputsResponse struct {
	state                              protoimpl.MessageState               `protogen:"open.v1"`
	OutputsWithPreviousTransactionData []*OutputWithPreviousTransactionData `protobuf:"bytes,1,rep,name=outputs_with_previous_transaction_data,json=outputsWithPreviousTransactionData,proto3" json:"outputs_with_previous_transaction_data,omitempty"`
	unknownFields                      protoimpl.UnknownFields
	sizeCache                          protoimpl.SizeCache
}

func (x *QueryTokenOutputsResponse) Reset() {
	*x = QueryTokenOutputsResponse{}
	mi := &file_spark_proto_msgTypes[44]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *QueryTokenOutputsResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*QueryTokenOutputsResponse) ProtoMessage() {}

func (x *QueryTokenOutputsResponse) ProtoReflect() protoreflect.Message {
	mi := &file_spark_proto_msgTypes[44]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use QueryTokenOutputsResponse.ProtoReflect.Descriptor instead.
func (*QueryTokenOutputsResponse) Descriptor() ([]byte, []int) {
	return file_spark_proto_rawDescGZIP(), []int{44}
}

func (x *QueryTokenOutputsResponse) GetOutputsWithPreviousTransactionData() []*OutputWithPreviousTransactionData {
	if x != nil {
		return x.OutputsWithPreviousTransactionData
	}
	return nil
}

type CancelSignedTokenTransactionRequest struct {
	state                   protoimpl.MessageState `protogen:"open.v1"`
	FinalTokenTransaction   *TokenTransaction      `protobuf:"bytes,1,opt,name=final_token_transaction,json=finalTokenTransaction,proto3" json:"final_token_transaction,omitempty"`
	SenderIdentityPublicKey []byte                 `protobuf:"bytes,2,opt,name=sender_identity_public_key,json=senderIdentityPublicKey,proto3" json:"sender_identity_public_key,omitempty"`
	unknownFields           protoimpl.UnknownFields
	sizeCache               protoimpl.SizeCache
}

func (x *CancelSignedTokenTransactionRequest) Reset() {
	*x = CancelSignedTokenTransactionRequest{}
	mi := &file_spark_proto_msgTypes[45]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *CancelSignedTokenTransactionRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*CancelSignedTokenTransactionRequest) ProtoMessage() {}

func (x *CancelSignedTokenTransactionRequest) ProtoReflect() protoreflect.Message {
	mi := &file_spark_proto_msgTypes[45]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use CancelSignedTokenTransactionRequest.ProtoReflect.Descriptor instead.
func (*CancelSignedTokenTransactionRequest) Descriptor() ([]byte, []int) {
	return file_spark_proto_rawDescGZIP(), []int{45}
}

func (x *CancelSignedTokenTransactionRequest) GetFinalTokenTransaction() *TokenTransaction {
	if x != nil {
		return x.FinalTokenTransaction
	}
	return nil
}

func (x *CancelSignedTokenTransactionRequest) GetSenderIdentityPublicKey() []byte {
	if x != nil {
		return x.SenderIdentityPublicKey
	}
	return nil
}

// *
// TreeNode represents a node on the tree.
type TreeNode struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// The id of the node.
	Id string `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
	// The id of the tree for this node .
	TreeId string `protobuf:"bytes,2,opt,name=tree_id,json=treeId,proto3" json:"tree_id,omitempty"`
	// The value that this node holds.
	Value uint64 `protobuf:"varint,3,opt,name=value,proto3" json:"value,omitempty"`
	// The id of the parent node.
	ParentNodeId *string `protobuf:"bytes,4,opt,name=parent_node_id,json=parentNodeId,proto3,oneof" json:"parent_node_id,omitempty"`
	// The transaction of the node, this transaction is to pay to the same address as the node.
	NodeTx []byte `protobuf:"bytes,5,opt,name=node_tx,json=nodeTx,proto3" json:"node_tx,omitempty"`
	// The refund transaction of the node, this transaction is to pay to the user.
	RefundTx []byte `protobuf:"bytes,6,opt,name=refund_tx,json=refundTx,proto3" json:"refund_tx,omitempty"`
	// This vout is the vout to spend the previous transaction, which is in the parent node.
	Vout uint32 `protobuf:"varint,7,opt,name=vout,proto3" json:"vout,omitempty"`
	// The verifying public key of the node.
	VerifyingPublicKey []byte `protobuf:"bytes,8,opt,name=verifying_public_key,json=verifyingPublicKey,proto3" json:"verifying_public_key,omitempty"`
	// The identity public key of the owner of the node.
	OwnerIdentityPublicKey []byte `protobuf:"bytes,9,opt,name=owner_identity_public_key,json=ownerIdentityPublicKey,proto3" json:"owner_identity_public_key,omitempty"`
	// The signing keyshare information of the node on the SE side.
	SigningKeyshare *SigningKeyshare `protobuf:"bytes,10,opt,name=signing_keyshare,json=signingKeyshare,proto3" json:"signing_keyshare,omitempty"`
	// The status of the node.
	Status string `protobuf:"bytes,11,opt,name=status,proto3" json:"status,omitempty"`
	// The network of the node.
	Network       Network `protobuf:"varint,12,opt,name=network,proto3,enum=spark.Network" json:"network,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *TreeNode) Reset() {
	*x = TreeNode{}
	mi := &file_spark_proto_msgTypes[46]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *TreeNode) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*TreeNode) ProtoMessage() {}

func (x *TreeNode) ProtoReflect() protoreflect.Message {
	mi := &file_spark_proto_msgTypes[46]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use TreeNode.ProtoReflect.Descriptor instead.
func (*TreeNode) Descriptor() ([]byte, []int) {
	return file_spark_proto_rawDescGZIP(), []int{46}
}

func (x *TreeNode) GetId() string {
	if x != nil {
		return x.Id
	}
	return ""
}

func (x *TreeNode) GetTreeId() string {
	if x != nil {
		return x.TreeId
	}
	return ""
}

func (x *TreeNode) GetValue() uint64 {
	if x != nil {
		return x.Value
	}
	return 0
}

func (x *TreeNode) GetParentNodeId() string {
	if x != nil && x.ParentNodeId != nil {
		return *x.ParentNodeId
	}
	return ""
}

func (x *TreeNode) GetNodeTx() []byte {
	if x != nil {
		return x.NodeTx
	}
	return nil
}

func (x *TreeNode) GetRefundTx() []byte {
	if x != nil {
		return x.RefundTx
	}
	return nil
}

func (x *TreeNode) GetVout() uint32 {
	if x != nil {
		return x.Vout
	}
	return 0
}

func (x *TreeNode) GetVerifyingPublicKey() []byte {
	if x != nil {
		return x.VerifyingPublicKey
	}
	return nil
}

func (x *TreeNode) GetOwnerIdentityPublicKey() []byte {
	if x != nil {
		return x.OwnerIdentityPublicKey
	}
	return nil
}

func (x *TreeNode) GetSigningKeyshare() *SigningKeyshare {
	if x != nil {
		return x.SigningKeyshare
	}
	return nil
}

func (x *TreeNode) GetStatus() string {
	if x != nil {
		return x.Status
	}
	return ""
}

func (x *TreeNode) GetNetwork() Network {
	if x != nil {
		return x.Network
	}
	return Network_UNSPECIFIED
}

// *
// FinalizeNodeSignaturesRequest is the request to finalize the signatures for a node.
type FinalizeNodeSignaturesRequest struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// The intent of the signature.
	Intent common.SignatureIntent `protobuf:"varint,1,opt,name=intent,proto3,enum=common.SignatureIntent" json:"intent,omitempty"`
	// The signatures for the node.
	NodeSignatures []*NodeSignatures `protobuf:"bytes,2,rep,name=node_signatures,json=nodeSignatures,proto3" json:"node_signatures,omitempty"`
	unknownFields  protoimpl.UnknownFields
	sizeCache      protoimpl.SizeCache
}

func (x *FinalizeNodeSignaturesRequest) Reset() {
	*x = FinalizeNodeSignaturesRequest{}
	mi := &file_spark_proto_msgTypes[47]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *FinalizeNodeSignaturesRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*FinalizeNodeSignaturesRequest) ProtoMessage() {}

func (x *FinalizeNodeSignaturesRequest) ProtoReflect() protoreflect.Message {
	mi := &file_spark_proto_msgTypes[47]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use FinalizeNodeSignaturesRequest.ProtoReflect.Descriptor instead.
func (*FinalizeNodeSignaturesRequest) Descriptor() ([]byte, []int) {
	return file_spark_proto_rawDescGZIP(), []int{47}
}

func (x *FinalizeNodeSignaturesRequest) GetIntent() common.SignatureIntent {
	if x != nil {
		return x.Intent
	}
	return common.SignatureIntent(0)
}

func (x *FinalizeNodeSignaturesRequest) GetNodeSignatures() []*NodeSignatures {
	if x != nil {
		return x.NodeSignatures
	}
	return nil
}

// *
// FinalizeNodeSignaturesResponse is the response to the request to finalize the signatures for a node.
type FinalizeNodeSignaturesResponse struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// The nodes that are finalized.
	Nodes         []*TreeNode `protobuf:"bytes,1,rep,name=nodes,proto3" json:"nodes,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *FinalizeNodeSignaturesResponse) Reset() {
	*x = FinalizeNodeSignaturesResponse{}
	mi := &file_spark_proto_msgTypes[48]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *FinalizeNodeSignaturesResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*FinalizeNodeSignaturesResponse) ProtoMessage() {}

func (x *FinalizeNodeSignaturesResponse) ProtoReflect() protoreflect.Message {
	mi := &file_spark_proto_msgTypes[48]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use FinalizeNodeSignaturesResponse.ProtoReflect.Descriptor instead.
func (*FinalizeNodeSignaturesResponse) Descriptor() ([]byte, []int) {
	return file_spark_proto_rawDescGZIP(), []int{48}
}

func (x *FinalizeNodeSignaturesResponse) GetNodes() []*TreeNode {
	if x != nil {
		return x.Nodes
	}
	return nil
}

// *
// SecretShare is a secret share of a secret, using Feldman VSS.
// The secret share is in the field of secp256k1 scalar field.
type SecretShare struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// The secret share.
	SecretShare []byte `protobuf:"bytes,1,opt,name=secret_share,json=secretShare,proto3" json:"secret_share,omitempty"`
	// The proofs for the secret share. They are the compressed public keys in secp256k1 curve.
	// proofs[0] is the public key of the secret, while proofs[1..n] are the public key of the polynomial.
	Proofs        [][]byte `protobuf:"bytes,2,rep,name=proofs,proto3" json:"proofs,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *SecretShare) Reset() {
	*x = SecretShare{}
	mi := &file_spark_proto_msgTypes[49]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *SecretShare) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*SecretShare) ProtoMessage() {}

func (x *SecretShare) ProtoReflect() protoreflect.Message {
	mi := &file_spark_proto_msgTypes[49]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use SecretShare.ProtoReflect.Descriptor instead.
func (*SecretShare) Descriptor() ([]byte, []int) {
	return file_spark_proto_rawDescGZIP(), []int{49}
}

func (x *SecretShare) GetSecretShare() []byte {
	if x != nil {
		return x.SecretShare
	}
	return nil
}

func (x *SecretShare) GetProofs() [][]byte {
	if x != nil {
		return x.Proofs
	}
	return nil
}

// *
// SecretProof is the proof for a secret share using Feldman VSS.
// The proof is the compressed public keys in secp256k1 curve.
type SecretProof struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// The proofs for the secret share.
	// proofs[0] is the public key of the secret, while proofs[1..n] are the public key of the polynomial.
	Proofs        [][]byte `protobuf:"bytes,1,rep,name=proofs,proto3" json:"proofs,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *SecretProof) Reset() {
	*x = SecretProof{}
	mi := &file_spark_proto_msgTypes[50]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *SecretProof) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*SecretProof) ProtoMessage() {}

func (x *SecretProof) ProtoReflect() protoreflect.Message {
	mi := &file_spark_proto_msgTypes[50]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use SecretProof.ProtoReflect.Descriptor instead.
func (*SecretProof) Descriptor() ([]byte, []int) {
	return file_spark_proto_rawDescGZIP(), []int{50}
}

func (x *SecretProof) GetProofs() [][]byte {
	if x != nil {
		return x.Proofs
	}
	return nil
}

type LeafRefundTxSigningJob struct {
	state              protoimpl.MessageState `protogen:"open.v1"`
	LeafId             string                 `protobuf:"bytes,1,opt,name=leaf_id,json=leafId,proto3" json:"leaf_id,omitempty"`
	RefundTxSigningJob *SigningJob            `protobuf:"bytes,2,opt,name=refund_tx_signing_job,json=refundTxSigningJob,proto3" json:"refund_tx_signing_job,omitempty"`
	unknownFields      protoimpl.UnknownFields
	sizeCache          protoimpl.SizeCache
}

func (x *LeafRefundTxSigningJob) Reset() {
	*x = LeafRefundTxSigningJob{}
	mi := &file_spark_proto_msgTypes[51]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *LeafRefundTxSigningJob) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*LeafRefundTxSigningJob) ProtoMessage() {}

func (x *LeafRefundTxSigningJob) ProtoReflect() protoreflect.Message {
	mi := &file_spark_proto_msgTypes[51]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use LeafRefundTxSigningJob.ProtoReflect.Descriptor instead.
func (*LeafRefundTxSigningJob) Descriptor() ([]byte, []int) {
	return file_spark_proto_rawDescGZIP(), []int{51}
}

func (x *LeafRefundTxSigningJob) GetLeafId() string {
	if x != nil {
		return x.LeafId
	}
	return ""
}

func (x *LeafRefundTxSigningJob) GetRefundTxSigningJob() *SigningJob {
	if x != nil {
		return x.RefundTxSigningJob
	}
	return nil
}

type UserSignedTxSigningJob struct {
	state                  protoimpl.MessageState    `protogen:"open.v1"`
	LeafId                 string                    `protobuf:"bytes,1,opt,name=leaf_id,json=leafId,proto3" json:"leaf_id,omitempty"`
	SigningPublicKey       []byte                    `protobuf:"bytes,2,opt,name=signing_public_key,json=signingPublicKey,proto3" json:"signing_public_key,omitempty"`
	RawTx                  []byte                    `protobuf:"bytes,3,opt,name=raw_tx,json=rawTx,proto3" json:"raw_tx,omitempty"`
	SigningNonceCommitment *common.SigningCommitment `protobuf:"bytes,4,opt,name=signing_nonce_commitment,json=signingNonceCommitment,proto3" json:"signing_nonce_commitment,omitempty"`
	UserSignature          []byte                    `protobuf:"bytes,5,opt,name=user_signature,json=userSignature,proto3" json:"user_signature,omitempty"`
	SigningCommitments     *SigningCommitments       `protobuf:"bytes,6,opt,name=signing_commitments,json=signingCommitments,proto3" json:"signing_commitments,omitempty"`
	unknownFields          protoimpl.UnknownFields
	sizeCache              protoimpl.SizeCache
}

func (x *UserSignedTxSigningJob) Reset() {
	*x = UserSignedTxSigningJob{}
	mi := &file_spark_proto_msgTypes[52]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *UserSignedTxSigningJob) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*UserSignedTxSigningJob) ProtoMessage() {}

func (x *UserSignedTxSigningJob) ProtoReflect() protoreflect.Message {
	mi := &file_spark_proto_msgTypes[52]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use UserSignedTxSigningJob.ProtoReflect.Descriptor instead.
func (*UserSignedTxSigningJob) Descriptor() ([]byte, []int) {
	return file_spark_proto_rawDescGZIP(), []int{52}
}

func (x *UserSignedTxSigningJob) GetLeafId() string {
	if x != nil {
		return x.LeafId
	}
	return ""
}

func (x *UserSignedTxSigningJob) GetSigningPublicKey() []byte {
	if x != nil {
		return x.SigningPublicKey
	}
	return nil
}

func (x *UserSignedTxSigningJob) GetRawTx() []byte {
	if x != nil {
		return x.RawTx
	}
	return nil
}

func (x *UserSignedTxSigningJob) GetSigningNonceCommitment() *common.SigningCommitment {
	if x != nil {
		return x.SigningNonceCommitment
	}
	return nil
}

func (x *UserSignedTxSigningJob) GetUserSignature() []byte {
	if x != nil {
		return x.UserSignature
	}
	return nil
}

func (x *UserSignedTxSigningJob) GetSigningCommitments() *SigningCommitments {
	if x != nil {
		return x.SigningCommitments
	}
	return nil
}

type LeafRefundTxSigningResult struct {
	state                 protoimpl.MessageState `protogen:"open.v1"`
	LeafId                string                 `protobuf:"bytes,1,opt,name=leaf_id,json=leafId,proto3" json:"leaf_id,omitempty"`
	RefundTxSigningResult *SigningResult         `protobuf:"bytes,2,opt,name=refund_tx_signing_result,json=refundTxSigningResult,proto3" json:"refund_tx_signing_result,omitempty"`
	VerifyingKey          []byte                 `protobuf:"bytes,3,opt,name=verifying_key,json=verifyingKey,proto3" json:"verifying_key,omitempty"`
	unknownFields         protoimpl.UnknownFields
	sizeCache             protoimpl.SizeCache
}

func (x *LeafRefundTxSigningResult) Reset() {
	*x = LeafRefundTxSigningResult{}
	mi := &file_spark_proto_msgTypes[53]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *LeafRefundTxSigningResult) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*LeafRefundTxSigningResult) ProtoMessage() {}

func (x *LeafRefundTxSigningResult) ProtoReflect() protoreflect.Message {
	mi := &file_spark_proto_msgTypes[53]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use LeafRefundTxSigningResult.ProtoReflect.Descriptor instead.
func (*LeafRefundTxSigningResult) Descriptor() ([]byte, []int) {
	return file_spark_proto_rawDescGZIP(), []int{53}
}

func (x *LeafRefundTxSigningResult) GetLeafId() string {
	if x != nil {
		return x.LeafId
	}
	return ""
}

func (x *LeafRefundTxSigningResult) GetRefundTxSigningResult() *SigningResult {
	if x != nil {
		return x.RefundTxSigningResult
	}
	return nil
}

func (x *LeafRefundTxSigningResult) GetVerifyingKey() []byte {
	if x != nil {
		return x.VerifyingKey
	}
	return nil
}

type StartUserSignedTransferRequest struct {
	state                     protoimpl.MessageState    `protogen:"open.v1"`
	TransferId                string                    `protobuf:"bytes,1,opt,name=transfer_id,json=transferId,proto3" json:"transfer_id,omitempty"`
	OwnerIdentityPublicKey    []byte                    `protobuf:"bytes,2,opt,name=owner_identity_public_key,json=ownerIdentityPublicKey,proto3" json:"owner_identity_public_key,omitempty"`
	LeavesToSend              []*UserSignedTxSigningJob `protobuf:"bytes,3,rep,name=leaves_to_send,json=leavesToSend,proto3" json:"leaves_to_send,omitempty"`
	ReceiverIdentityPublicKey []byte                    `protobuf:"bytes,4,opt,name=receiver_identity_public_key,json=receiverIdentityPublicKey,proto3" json:"receiver_identity_public_key,omitempty"`
	ExpiryTime                *timestamppb.Timestamp    `protobuf:"bytes,5,opt,name=expiry_time,json=expiryTime,proto3" json:"expiry_time,omitempty"`
	unknownFields             protoimpl.UnknownFields
	sizeCache                 protoimpl.SizeCache
}

func (x *StartUserSignedTransferRequest) Reset() {
	*x = StartUserSignedTransferRequest{}
	mi := &file_spark_proto_msgTypes[54]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *StartUserSignedTransferRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*StartUserSignedTransferRequest) ProtoMessage() {}

func (x *StartUserSignedTransferRequest) ProtoReflect() protoreflect.Message {
	mi := &file_spark_proto_msgTypes[54]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use StartUserSignedTransferRequest.ProtoReflect.Descriptor instead.
func (*StartUserSignedTransferRequest) Descriptor() ([]byte, []int) {
	return file_spark_proto_rawDescGZIP(), []int{54}
}

func (x *StartUserSignedTransferRequest) GetTransferId() string {
	if x != nil {
		return x.TransferId
	}
	return ""
}

func (x *StartUserSignedTransferRequest) GetOwnerIdentityPublicKey() []byte {
	if x != nil {
		return x.OwnerIdentityPublicKey
	}
	return nil
}

func (x *StartUserSignedTransferRequest) GetLeavesToSend() []*UserSignedTxSigningJob {
	if x != nil {
		return x.LeavesToSend
	}
	return nil
}

func (x *StartUserSignedTransferRequest) GetReceiverIdentityPublicKey() []byte {
	if x != nil {
		return x.ReceiverIdentityPublicKey
	}
	return nil
}

func (x *StartUserSignedTransferRequest) GetExpiryTime() *timestamppb.Timestamp {
	if x != nil {
		return x.ExpiryTime
	}
	return nil
}

type StartTransferRequest struct {
	state                     protoimpl.MessageState    `protogen:"open.v1"`
	TransferId                string                    `protobuf:"bytes,1,opt,name=transfer_id,json=transferId,proto3" json:"transfer_id,omitempty"`
	OwnerIdentityPublicKey    []byte                    `protobuf:"bytes,2,opt,name=owner_identity_public_key,json=ownerIdentityPublicKey,proto3" json:"owner_identity_public_key,omitempty"`
	LeavesToSend              []*LeafRefundTxSigningJob `protobuf:"bytes,3,rep,name=leaves_to_send,json=leavesToSend,proto3" json:"leaves_to_send,omitempty"`
	ReceiverIdentityPublicKey []byte                    `protobuf:"bytes,4,opt,name=receiver_identity_public_key,json=receiverIdentityPublicKey,proto3" json:"receiver_identity_public_key,omitempty"`
	ExpiryTime                *timestamppb.Timestamp    `protobuf:"bytes,5,opt,name=expiry_time,json=expiryTime,proto3" json:"expiry_time,omitempty"`
	KeyTweakProofs            map[string]*SecretProof   `protobuf:"bytes,6,rep,name=key_tweak_proofs,json=keyTweakProofs,proto3" json:"key_tweak_proofs,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
	unknownFields             protoimpl.UnknownFields
	sizeCache                 protoimpl.SizeCache
}

func (x *StartTransferRequest) Reset() {
	*x = StartTransferRequest{}
	mi := &file_spark_proto_msgTypes[55]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *StartTransferRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*StartTransferRequest) ProtoMessage() {}

func (x *StartTransferRequest) ProtoReflect() protoreflect.Message {
	mi := &file_spark_proto_msgTypes[55]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use StartTransferRequest.ProtoReflect.Descriptor instead.
func (*StartTransferRequest) Descriptor() ([]byte, []int) {
	return file_spark_proto_rawDescGZIP(), []int{55}
}

func (x *StartTransferRequest) GetTransferId() string {
	if x != nil {
		return x.TransferId
	}
	return ""
}

func (x *StartTransferRequest) GetOwnerIdentityPublicKey() []byte {
	if x != nil {
		return x.OwnerIdentityPublicKey
	}
	return nil
}

func (x *StartTransferRequest) GetLeavesToSend() []*LeafRefundTxSigningJob {
	if x != nil {
		return x.LeavesToSend
	}
	return nil
}

func (x *StartTransferRequest) GetReceiverIdentityPublicKey() []byte {
	if x != nil {
		return x.ReceiverIdentityPublicKey
	}
	return nil
}

func (x *StartTransferRequest) GetExpiryTime() *timestamppb.Timestamp {
	if x != nil {
		return x.ExpiryTime
	}
	return nil
}

func (x *StartTransferRequest) GetKeyTweakProofs() map[string]*SecretProof {
	if x != nil {
		return x.KeyTweakProofs
	}
	return nil
}

type StartTransferResponse struct {
	state          protoimpl.MessageState       `protogen:"open.v1"`
	Transfer       *Transfer                    `protobuf:"bytes,1,opt,name=transfer,proto3" json:"transfer,omitempty"`
	SigningResults []*LeafRefundTxSigningResult `protobuf:"bytes,2,rep,name=signing_results,json=signingResults,proto3" json:"signing_results,omitempty"`
	unknownFields  protoimpl.UnknownFields
	sizeCache      protoimpl.SizeCache
}

func (x *StartTransferResponse) Reset() {
	*x = StartTransferResponse{}
	mi := &file_spark_proto_msgTypes[56]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *StartTransferResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*StartTransferResponse) ProtoMessage() {}

func (x *StartTransferResponse) ProtoReflect() protoreflect.Message {
	mi := &file_spark_proto_msgTypes[56]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use StartTransferResponse.ProtoReflect.Descriptor instead.
func (*StartTransferResponse) Descriptor() ([]byte, []int) {
	return file_spark_proto_rawDescGZIP(), []int{56}
}

func (x *StartTransferResponse) GetTransfer() *Transfer {
	if x != nil {
		return x.Transfer
	}
	return nil
}

func (x *StartTransferResponse) GetSigningResults() []*LeafRefundTxSigningResult {
	if x != nil {
		return x.SigningResults
	}
	return nil
}

type SendLeafKeyTweak struct {
	state             protoimpl.MessageState `protogen:"open.v1"`
	LeafId            string                 `protobuf:"bytes,1,opt,name=leaf_id,json=leafId,proto3" json:"leaf_id,omitempty"`
	SecretShareTweak  *SecretShare           `protobuf:"bytes,2,opt,name=secret_share_tweak,json=secretShareTweak,proto3" json:"secret_share_tweak,omitempty"`
	PubkeySharesTweak map[string][]byte      `protobuf:"bytes,3,rep,name=pubkey_shares_tweak,json=pubkeySharesTweak,proto3" json:"pubkey_shares_tweak,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
	SecretCipher      []byte                 `protobuf:"bytes,4,opt,name=secret_cipher,json=secretCipher,proto3" json:"secret_cipher,omitempty"`
	// Signature over Sha256(leaf_id||transfer_id||secret_cipher)
	Signature       []byte `protobuf:"bytes,5,opt,name=signature,proto3" json:"signature,omitempty"`
	RefundSignature []byte `protobuf:"bytes,6,opt,name=refund_signature,json=refundSignature,proto3" json:"refund_signature,omitempty"`
	unknownFields   protoimpl.UnknownFields
	sizeCache       protoimpl.SizeCache
}

func (x *SendLeafKeyTweak) Reset() {
	*x = SendLeafKeyTweak{}
	mi := &file_spark_proto_msgTypes[57]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *SendLeafKeyTweak) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*SendLeafKeyTweak) ProtoMessage() {}

func (x *SendLeafKeyTweak) ProtoReflect() protoreflect.Message {
	mi := &file_spark_proto_msgTypes[57]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use SendLeafKeyTweak.ProtoReflect.Descriptor instead.
func (*SendLeafKeyTweak) Descriptor() ([]byte, []int) {
	return file_spark_proto_rawDescGZIP(), []int{57}
}

func (x *SendLeafKeyTweak) GetLeafId() string {
	if x != nil {
		return x.LeafId
	}
	return ""
}

func (x *SendLeafKeyTweak) GetSecretShareTweak() *SecretShare {
	if x != nil {
		return x.SecretShareTweak
	}
	return nil
}

func (x *SendLeafKeyTweak) GetPubkeySharesTweak() map[string][]byte {
	if x != nil {
		return x.PubkeySharesTweak
	}
	return nil
}

func (x *SendLeafKeyTweak) GetSecretCipher() []byte {
	if x != nil {
		return x.SecretCipher
	}
	return nil
}

func (x *SendLeafKeyTweak) GetSignature() []byte {
	if x != nil {
		return x.Signature
	}
	return nil
}

func (x *SendLeafKeyTweak) GetRefundSignature() []byte {
	if x != nil {
		return x.RefundSignature
	}
	return nil
}

type FinalizeTransferRequest struct {
	state                  protoimpl.MessageState `protogen:"open.v1"`
	TransferId             string                 `protobuf:"bytes,1,opt,name=transfer_id,json=transferId,proto3" json:"transfer_id,omitempty"`
	OwnerIdentityPublicKey []byte                 `protobuf:"bytes,2,opt,name=owner_identity_public_key,json=ownerIdentityPublicKey,proto3" json:"owner_identity_public_key,omitempty"`
	LeavesToSend           []*SendLeafKeyTweak    `protobuf:"bytes,3,rep,name=leaves_to_send,json=leavesToSend,proto3" json:"leaves_to_send,omitempty"`
	unknownFields          protoimpl.UnknownFields
	sizeCache              protoimpl.SizeCache
}

func (x *FinalizeTransferRequest) Reset() {
	*x = FinalizeTransferRequest{}
	mi := &file_spark_proto_msgTypes[58]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *FinalizeTransferRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*FinalizeTransferRequest) ProtoMessage() {}

func (x *FinalizeTransferRequest) ProtoReflect() protoreflect.Message {
	mi := &file_spark_proto_msgTypes[58]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use FinalizeTransferRequest.ProtoReflect.Descriptor instead.
func (*FinalizeTransferRequest) Descriptor() ([]byte, []int) {
	return file_spark_proto_rawDescGZIP(), []int{58}
}

func (x *FinalizeTransferRequest) GetTransferId() string {
	if x != nil {
		return x.TransferId
	}
	return ""
}

func (x *FinalizeTransferRequest) GetOwnerIdentityPublicKey() []byte {
	if x != nil {
		return x.OwnerIdentityPublicKey
	}
	return nil
}

func (x *FinalizeTransferRequest) GetLeavesToSend() []*SendLeafKeyTweak {
	if x != nil {
		return x.LeavesToSend
	}
	return nil
}

type FinalizeTransferResponse struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Transfer      *Transfer              `protobuf:"bytes,1,opt,name=transfer,proto3" json:"transfer,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *FinalizeTransferResponse) Reset() {
	*x = FinalizeTransferResponse{}
	mi := &file_spark_proto_msgTypes[59]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *FinalizeTransferResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*FinalizeTransferResponse) ProtoMessage() {}

func (x *FinalizeTransferResponse) ProtoReflect() protoreflect.Message {
	mi := &file_spark_proto_msgTypes[59]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use FinalizeTransferResponse.ProtoReflect.Descriptor instead.
func (*FinalizeTransferResponse) Descriptor() ([]byte, []int) {
	return file_spark_proto_rawDescGZIP(), []int{59}
}

func (x *FinalizeTransferResponse) GetTransfer() *Transfer {
	if x != nil {
		return x.Transfer
	}
	return nil
}

type Transfer struct {
	state                     protoimpl.MessageState `protogen:"open.v1"`
	Id                        string                 `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
	SenderIdentityPublicKey   []byte                 `protobuf:"bytes,2,opt,name=sender_identity_public_key,json=senderIdentityPublicKey,proto3" json:"sender_identity_public_key,omitempty"`
	ReceiverIdentityPublicKey []byte                 `protobuf:"bytes,3,opt,name=receiver_identity_public_key,json=receiverIdentityPublicKey,proto3" json:"receiver_identity_public_key,omitempty"`
	Status                    TransferStatus         `protobuf:"varint,4,opt,name=status,proto3,enum=spark.TransferStatus" json:"status,omitempty"`
	TotalValue                uint64                 `protobuf:"varint,5,opt,name=total_value,json=totalValue,proto3" json:"total_value,omitempty"`
	ExpiryTime                *timestamppb.Timestamp `protobuf:"bytes,6,opt,name=expiry_time,json=expiryTime,proto3" json:"expiry_time,omitempty"`
	Leaves                    []*TransferLeaf        `protobuf:"bytes,7,rep,name=leaves,proto3" json:"leaves,omitempty"`
	CreatedTime               *timestamppb.Timestamp `protobuf:"bytes,8,opt,name=created_time,json=createdTime,proto3" json:"created_time,omitempty"`
	UpdatedTime               *timestamppb.Timestamp `protobuf:"bytes,9,opt,name=updated_time,json=updatedTime,proto3" json:"updated_time,omitempty"`
	Type                      TransferType           `protobuf:"varint,10,opt,name=type,proto3,enum=spark.TransferType" json:"type,omitempty"`
	unknownFields             protoimpl.UnknownFields
	sizeCache                 protoimpl.SizeCache
}

func (x *Transfer) Reset() {
	*x = Transfer{}
	mi := &file_spark_proto_msgTypes[60]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *Transfer) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*Transfer) ProtoMessage() {}

func (x *Transfer) ProtoReflect() protoreflect.Message {
	mi := &file_spark_proto_msgTypes[60]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use Transfer.ProtoReflect.Descriptor instead.
func (*Transfer) Descriptor() ([]byte, []int) {
	return file_spark_proto_rawDescGZIP(), []int{60}
}

func (x *Transfer) GetId() string {
	if x != nil {
		return x.Id
	}
	return ""
}

func (x *Transfer) GetSenderIdentityPublicKey() []byte {
	if x != nil {
		return x.SenderIdentityPublicKey
	}
	return nil
}

func (x *Transfer) GetReceiverIdentityPublicKey() []byte {
	if x != nil {
		return x.ReceiverIdentityPublicKey
	}
	return nil
}

func (x *Transfer) GetStatus() TransferStatus {
	if x != nil {
		return x.Status
	}
	return TransferStatus_TRANSFER_STATUS_SENDER_INITIATED
}

func (x *Transfer) GetTotalValue() uint64 {
	if x != nil {
		return x.TotalValue
	}
	return 0
}

func (x *Transfer) GetExpiryTime() *timestamppb.Timestamp {
	if x != nil {
		return x.ExpiryTime
	}
	return nil
}

func (x *Transfer) GetLeaves() []*TransferLeaf {
	if x != nil {
		return x.Leaves
	}
	return nil
}

func (x *Transfer) GetCreatedTime() *timestamppb.Timestamp {
	if x != nil {
		return x.CreatedTime
	}
	return nil
}

func (x *Transfer) GetUpdatedTime() *timestamppb.Timestamp {
	if x != nil {
		return x.UpdatedTime
	}
	return nil
}

func (x *Transfer) GetType() TransferType {
	if x != nil {
		return x.Type
	}
	return TransferType_PREIMAGE_SWAP
}

type TransferLeaf struct {
	state                protoimpl.MessageState `protogen:"open.v1"`
	Leaf                 *TreeNode              `protobuf:"bytes,1,opt,name=leaf,proto3" json:"leaf,omitempty"`
	SecretCipher         []byte                 `protobuf:"bytes,2,opt,name=secret_cipher,json=secretCipher,proto3" json:"secret_cipher,omitempty"`
	Signature            []byte                 `protobuf:"bytes,3,opt,name=signature,proto3" json:"signature,omitempty"`
	IntermediateRefundTx []byte                 `protobuf:"bytes,4,opt,name=intermediate_refund_tx,json=intermediateRefundTx,proto3" json:"intermediate_refund_tx,omitempty"`
	unknownFields        protoimpl.UnknownFields
	sizeCache            protoimpl.SizeCache
}

func (x *TransferLeaf) Reset() {
	*x = TransferLeaf{}
	mi := &file_spark_proto_msgTypes[61]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *TransferLeaf) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*TransferLeaf) ProtoMessage() {}

func (x *TransferLeaf) ProtoReflect() protoreflect.Message {
	mi := &file_spark_proto_msgTypes[61]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use TransferLeaf.ProtoReflect.Descriptor instead.
func (*TransferLeaf) Descriptor() ([]byte, []int) {
	return file_spark_proto_rawDescGZIP(), []int{61}
}

func (x *TransferLeaf) GetLeaf() *TreeNode {
	if x != nil {
		return x.Leaf
	}
	return nil
}

func (x *TransferLeaf) GetSecretCipher() []byte {
	if x != nil {
		return x.SecretCipher
	}
	return nil
}

func (x *TransferLeaf) GetSignature() []byte {
	if x != nil {
		return x.Signature
	}
	return nil
}

func (x *TransferLeaf) GetIntermediateRefundTx() []byte {
	if x != nil {
		return x.IntermediateRefundTx
	}
	return nil
}

type TransferFilter struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Types that are valid to be assigned to Participant:
	//
	//	*TransferFilter_ReceiverIdentityPublicKey
	//	*TransferFilter_SenderIdentityPublicKey
	//	*TransferFilter_SenderOrReceiverIdentityPublicKey
	Participant   isTransferFilter_Participant `protobuf_oneof:"participant"`
	TransferIds   []string                     `protobuf:"bytes,3,rep,name=transfer_ids,json=transferIds,proto3" json:"transfer_ids,omitempty"`
	Limit         int64                        `protobuf:"varint,40,opt,name=limit,proto3" json:"limit,omitempty"`
	Offset        int64                        `protobuf:"varint,50,opt,name=offset,proto3" json:"offset,omitempty"`
	Types         []TransferType               `protobuf:"varint,70,rep,packed,name=types,proto3,enum=spark.TransferType" json:"types,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *TransferFilter) Reset() {
	*x = TransferFilter{}
	mi := &file_spark_proto_msgTypes[62]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *TransferFilter) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*TransferFilter) ProtoMessage() {}

func (x *TransferFilter) ProtoReflect() protoreflect.Message {
	mi := &file_spark_proto_msgTypes[62]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use TransferFilter.ProtoReflect.Descriptor instead.
func (*TransferFilter) Descriptor() ([]byte, []int) {
	return file_spark_proto_rawDescGZIP(), []int{62}
}

func (x *TransferFilter) GetParticipant() isTransferFilter_Participant {
	if x != nil {
		return x.Participant
	}
	return nil
}

func (x *TransferFilter) GetReceiverIdentityPublicKey() []byte {
	if x != nil {
		if x, ok := x.Participant.(*TransferFilter_ReceiverIdentityPublicKey); ok {
			return x.ReceiverIdentityPublicKey
		}
	}
	return nil
}

func (x *TransferFilter) GetSenderIdentityPublicKey() []byte {
	if x != nil {
		if x, ok := x.Participant.(*TransferFilter_SenderIdentityPublicKey); ok {
			return x.SenderIdentityPublicKey
		}
	}
	return nil
}

func (x *TransferFilter) GetSenderOrReceiverIdentityPublicKey() []byte {
	if x != nil {
		if x, ok := x.Participant.(*TransferFilter_SenderOrReceiverIdentityPublicKey); ok {
			return x.SenderOrReceiverIdentityPublicKey
		}
	}
	return nil
}

func (x *TransferFilter) GetTransferIds() []string {
	if x != nil {
		return x.TransferIds
	}
	return nil
}

func (x *TransferFilter) GetLimit() int64 {
	if x != nil {
		return x.Limit
	}
	return 0
}

func (x *TransferFilter) GetOffset() int64 {
	if x != nil {
		return x.Offset
	}
	return 0
}

func (x *TransferFilter) GetTypes() []TransferType {
	if x != nil {
		return x.Types
	}
	return nil
}

type isTransferFilter_Participant interface {
	isTransferFilter_Participant()
}

type TransferFilter_ReceiverIdentityPublicKey struct {
	ReceiverIdentityPublicKey []byte `protobuf:"bytes,1,opt,name=receiver_identity_public_key,json=receiverIdentityPublicKey,proto3,oneof"`
}

type TransferFilter_SenderIdentityPublicKey struct {
	SenderIdentityPublicKey []byte `protobuf:"bytes,2,opt,name=sender_identity_public_key,json=senderIdentityPublicKey,proto3,oneof"`
}

type TransferFilter_SenderOrReceiverIdentityPublicKey struct {
	// This will include transfers where this public key is the sender or receiver.
	SenderOrReceiverIdentityPublicKey []byte `protobuf:"bytes,60,opt,name=sender_or_receiver_identity_public_key,json=senderOrReceiverIdentityPublicKey,proto3,oneof"`
}

func (*TransferFilter_ReceiverIdentityPublicKey) isTransferFilter_Participant() {}

func (*TransferFilter_SenderIdentityPublicKey) isTransferFilter_Participant() {}

func (*TransferFilter_SenderOrReceiverIdentityPublicKey) isTransferFilter_Participant() {}

type QueryTransfersResponse struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Transfers     []*Transfer            `protobuf:"bytes,1,rep,name=transfers,proto3" json:"transfers,omitempty"`
	Offset        int64                  `protobuf:"varint,2,opt,name=offset,proto3" json:"offset,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *QueryTransfersResponse) Reset() {
	*x = QueryTransfersResponse{}
	mi := &file_spark_proto_msgTypes[63]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *QueryTransfersResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*QueryTransfersResponse) ProtoMessage() {}

func (x *QueryTransfersResponse) ProtoReflect() protoreflect.Message {
	mi := &file_spark_proto_msgTypes[63]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use QueryTransfersResponse.ProtoReflect.Descriptor instead.
func (*QueryTransfersResponse) Descriptor() ([]byte, []int) {
	return file_spark_proto_rawDescGZIP(), []int{63}
}

func (x *QueryTransfersResponse) GetTransfers() []*Transfer {
	if x != nil {
		return x.Transfers
	}
	return nil
}

func (x *QueryTransfersResponse) GetOffset() int64 {
	if x != nil {
		return x.Offset
	}
	return 0
}

type ClaimLeafKeyTweak struct {
	state             protoimpl.MessageState `protogen:"open.v1"`
	LeafId            string                 `protobuf:"bytes,1,opt,name=leaf_id,json=leafId,proto3" json:"leaf_id,omitempty"`
	SecretShareTweak  *SecretShare           `protobuf:"bytes,2,opt,name=secret_share_tweak,json=secretShareTweak,proto3" json:"secret_share_tweak,omitempty"`
	PubkeySharesTweak map[string][]byte      `protobuf:"bytes,3,rep,name=pubkey_shares_tweak,json=pubkeySharesTweak,proto3" json:"pubkey_shares_tweak,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
	unknownFields     protoimpl.UnknownFields
	sizeCache         protoimpl.SizeCache
}

func (x *ClaimLeafKeyTweak) Reset() {
	*x = ClaimLeafKeyTweak{}
	mi := &file_spark_proto_msgTypes[64]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ClaimLeafKeyTweak) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ClaimLeafKeyTweak) ProtoMessage() {}

func (x *ClaimLeafKeyTweak) ProtoReflect() protoreflect.Message {
	mi := &file_spark_proto_msgTypes[64]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ClaimLeafKeyTweak.ProtoReflect.Descriptor instead.
func (*ClaimLeafKeyTweak) Descriptor() ([]byte, []int) {
	return file_spark_proto_rawDescGZIP(), []int{64}
}

func (x *ClaimLeafKeyTweak) GetLeafId() string {
	if x != nil {
		return x.LeafId
	}
	return ""
}

func (x *ClaimLeafKeyTweak) GetSecretShareTweak() *SecretShare {
	if x != nil {
		return x.SecretShareTweak
	}
	return nil
}

func (x *ClaimLeafKeyTweak) GetPubkeySharesTweak() map[string][]byte {
	if x != nil {
		return x.PubkeySharesTweak
	}
	return nil
}

type ClaimTransferTweakKeysRequest struct {
	state                  protoimpl.MessageState `protogen:"open.v1"`
	TransferId             string                 `protobuf:"bytes,1,opt,name=transfer_id,json=transferId,proto3" json:"transfer_id,omitempty"`
	OwnerIdentityPublicKey []byte                 `protobuf:"bytes,2,opt,name=owner_identity_public_key,json=ownerIdentityPublicKey,proto3" json:"owner_identity_public_key,omitempty"`
	LeavesToReceive        []*ClaimLeafKeyTweak   `protobuf:"bytes,3,rep,name=leaves_to_receive,json=leavesToReceive,proto3" json:"leaves_to_receive,omitempty"`
	unknownFields          protoimpl.UnknownFields
	sizeCache              protoimpl.SizeCache
}

func (x *ClaimTransferTweakKeysRequest) Reset() {
	*x = ClaimTransferTweakKeysRequest{}
	mi := &file_spark_proto_msgTypes[65]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ClaimTransferTweakKeysRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ClaimTransferTweakKeysRequest) ProtoMessage() {}

func (x *ClaimTransferTweakKeysRequest) ProtoReflect() protoreflect.Message {
	mi := &file_spark_proto_msgTypes[65]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ClaimTransferTweakKeysRequest.ProtoReflect.Descriptor instead.
func (*ClaimTransferTweakKeysRequest) Descriptor() ([]byte, []int) {
	return file_spark_proto_rawDescGZIP(), []int{65}
}

func (x *ClaimTransferTweakKeysRequest) GetTransferId() string {
	if x != nil {
		return x.TransferId
	}
	return ""
}

func (x *ClaimTransferTweakKeysRequest) GetOwnerIdentityPublicKey() []byte {
	if x != nil {
		return x.OwnerIdentityPublicKey
	}
	return nil
}

func (x *ClaimTransferTweakKeysRequest) GetLeavesToReceive() []*ClaimLeafKeyTweak {
	if x != nil {
		return x.LeavesToReceive
	}
	return nil
}

type ClaimTransferSignRefundsRequest struct {
	state                  protoimpl.MessageState    `protogen:"open.v1"`
	TransferId             string                    `protobuf:"bytes,1,opt,name=transfer_id,json=transferId,proto3" json:"transfer_id,omitempty"`
	OwnerIdentityPublicKey []byte                    `protobuf:"bytes,2,opt,name=owner_identity_public_key,json=ownerIdentityPublicKey,proto3" json:"owner_identity_public_key,omitempty"`
	SigningJobs            []*LeafRefundTxSigningJob `protobuf:"bytes,3,rep,name=signing_jobs,json=signingJobs,proto3" json:"signing_jobs,omitempty"`
	KeyTweakProofs         map[string]*SecretProof   `protobuf:"bytes,4,rep,name=key_tweak_proofs,json=keyTweakProofs,proto3" json:"key_tweak_proofs,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
	unknownFields          protoimpl.UnknownFields
	sizeCache              protoimpl.SizeCache
}

func (x *ClaimTransferSignRefundsRequest) Reset() {
	*x = ClaimTransferSignRefundsRequest{}
	mi := &file_spark_proto_msgTypes[66]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ClaimTransferSignRefundsRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ClaimTransferSignRefundsRequest) ProtoMessage() {}

func (x *ClaimTransferSignRefundsRequest) ProtoReflect() protoreflect.Message {
	mi := &file_spark_proto_msgTypes[66]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ClaimTransferSignRefundsRequest.ProtoReflect.Descriptor instead.
func (*ClaimTransferSignRefundsRequest) Descriptor() ([]byte, []int) {
	return file_spark_proto_rawDescGZIP(), []int{66}
}

func (x *ClaimTransferSignRefundsRequest) GetTransferId() string {
	if x != nil {
		return x.TransferId
	}
	return ""
}

func (x *ClaimTransferSignRefundsRequest) GetOwnerIdentityPublicKey() []byte {
	if x != nil {
		return x.OwnerIdentityPublicKey
	}
	return nil
}

func (x *ClaimTransferSignRefundsRequest) GetSigningJobs() []*LeafRefundTxSigningJob {
	if x != nil {
		return x.SigningJobs
	}
	return nil
}

func (x *ClaimTransferSignRefundsRequest) GetKeyTweakProofs() map[string]*SecretProof {
	if x != nil {
		return x.KeyTweakProofs
	}
	return nil
}

type ClaimTransferSignRefundsResponse struct {
	state          protoimpl.MessageState       `protogen:"open.v1"`
	SigningResults []*LeafRefundTxSigningResult `protobuf:"bytes,1,rep,name=signing_results,json=signingResults,proto3" json:"signing_results,omitempty"`
	unknownFields  protoimpl.UnknownFields
	sizeCache      protoimpl.SizeCache
}

func (x *ClaimTransferSignRefundsResponse) Reset() {
	*x = ClaimTransferSignRefundsResponse{}
	mi := &file_spark_proto_msgTypes[67]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ClaimTransferSignRefundsResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ClaimTransferSignRefundsResponse) ProtoMessage() {}

func (x *ClaimTransferSignRefundsResponse) ProtoReflect() protoreflect.Message {
	mi := &file_spark_proto_msgTypes[67]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ClaimTransferSignRefundsResponse.ProtoReflect.Descriptor instead.
func (*ClaimTransferSignRefundsResponse) Descriptor() ([]byte, []int) {
	return file_spark_proto_rawDescGZIP(), []int{67}
}

func (x *ClaimTransferSignRefundsResponse) GetSigningResults() []*LeafRefundTxSigningResult {
	if x != nil {
		return x.SigningResults
	}
	return nil
}

type AggregateNodesRequest struct {
	state      protoimpl.MessageState `protogen:"open.v1"`
	NodeIds    []string               `protobuf:"bytes,1,rep,name=node_ids,json=nodeIds,proto3" json:"node_ids,omitempty"`
	SigningJob *SigningJob            `protobuf:"bytes,2,opt,name=signing_job,json=signingJob,proto3" json:"signing_job,omitempty"`
	// Serves as a temporary identity public key, this should be get from auth process.
	OwnerIdentityPublicKey []byte `protobuf:"bytes,3,opt,name=owner_identity_public_key,json=ownerIdentityPublicKey,proto3" json:"owner_identity_public_key,omitempty"`
	unknownFields          protoimpl.UnknownFields
	sizeCache              protoimpl.SizeCache
}

func (x *AggregateNodesRequest) Reset() {
	*x = AggregateNodesRequest{}
	mi := &file_spark_proto_msgTypes[68]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *AggregateNodesRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*AggregateNodesRequest) ProtoMessage() {}

func (x *AggregateNodesRequest) ProtoReflect() protoreflect.Message {
	mi := &file_spark_proto_msgTypes[68]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use AggregateNodesRequest.ProtoReflect.Descriptor instead.
func (*AggregateNodesRequest) Descriptor() ([]byte, []int) {
	return file_spark_proto_rawDescGZIP(), []int{68}
}

func (x *AggregateNodesRequest) GetNodeIds() []string {
	if x != nil {
		return x.NodeIds
	}
	return nil
}

func (x *AggregateNodesRequest) GetSigningJob() *SigningJob {
	if x != nil {
		return x.SigningJob
	}
	return nil
}

func (x *AggregateNodesRequest) GetOwnerIdentityPublicKey() []byte {
	if x != nil {
		return x.OwnerIdentityPublicKey
	}
	return nil
}

type AggregateNodesResponse struct {
	state              protoimpl.MessageState `protogen:"open.v1"`
	AggregateSignature *SigningResult         `protobuf:"bytes,1,opt,name=aggregate_signature,json=aggregateSignature,proto3" json:"aggregate_signature,omitempty"`
	VerifyingKey       []byte                 `protobuf:"bytes,2,opt,name=verifying_key,json=verifyingKey,proto3" json:"verifying_key,omitempty"`
	ParentNodeTx       []byte                 `protobuf:"bytes,3,opt,name=parent_node_tx,json=parentNodeTx,proto3" json:"parent_node_tx,omitempty"`
	ParentNodeVout     uint32                 `protobuf:"varint,4,opt,name=parent_node_vout,json=parentNodeVout,proto3" json:"parent_node_vout,omitempty"`
	unknownFields      protoimpl.UnknownFields
	sizeCache          protoimpl.SizeCache
}

func (x *AggregateNodesResponse) Reset() {
	*x = AggregateNodesResponse{}
	mi := &file_spark_proto_msgTypes[69]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *AggregateNodesResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*AggregateNodesResponse) ProtoMessage() {}

func (x *AggregateNodesResponse) ProtoReflect() protoreflect.Message {
	mi := &file_spark_proto_msgTypes[69]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use AggregateNodesResponse.ProtoReflect.Descriptor instead.
func (*AggregateNodesResponse) Descriptor() ([]byte, []int) {
	return file_spark_proto_rawDescGZIP(), []int{69}
}

func (x *AggregateNodesResponse) GetAggregateSignature() *SigningResult {
	if x != nil {
		return x.AggregateSignature
	}
	return nil
}

func (x *AggregateNodesResponse) GetVerifyingKey() []byte {
	if x != nil {
		return x.VerifyingKey
	}
	return nil
}

func (x *AggregateNodesResponse) GetParentNodeTx() []byte {
	if x != nil {
		return x.ParentNodeTx
	}
	return nil
}

func (x *AggregateNodesResponse) GetParentNodeVout() uint32 {
	if x != nil {
		return x.ParentNodeVout
	}
	return 0
}

type StorePreimageShareRequest struct {
	state                 protoimpl.MessageState `protogen:"open.v1"`
	PaymentHash           []byte                 `protobuf:"bytes,1,opt,name=payment_hash,json=paymentHash,proto3" json:"payment_hash,omitempty"`
	PreimageShare         *SecretShare           `protobuf:"bytes,2,opt,name=preimage_share,json=preimageShare,proto3" json:"preimage_share,omitempty"`
	Threshold             uint32                 `protobuf:"varint,3,opt,name=threshold,proto3" json:"threshold,omitempty"`
	InvoiceString         string                 `protobuf:"bytes,4,opt,name=invoice_string,json=invoiceString,proto3" json:"invoice_string,omitempty"`
	UserIdentityPublicKey []byte                 `protobuf:"bytes,5,opt,name=user_identity_public_key,json=userIdentityPublicKey,proto3" json:"user_identity_public_key,omitempty"`
	unknownFields         protoimpl.UnknownFields
	sizeCache             protoimpl.SizeCache
}

func (x *StorePreimageShareRequest) Reset() {
	*x = StorePreimageShareRequest{}
	mi := &file_spark_proto_msgTypes[70]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *StorePreimageShareRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*StorePreimageShareRequest) ProtoMessage() {}

func (x *StorePreimageShareRequest) ProtoReflect() protoreflect.Message {
	mi := &file_spark_proto_msgTypes[70]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use StorePreimageShareRequest.ProtoReflect.Descriptor instead.
func (*StorePreimageShareRequest) Descriptor() ([]byte, []int) {
	return file_spark_proto_rawDescGZIP(), []int{70}
}

func (x *StorePreimageShareRequest) GetPaymentHash() []byte {
	if x != nil {
		return x.PaymentHash
	}
	return nil
}

func (x *StorePreimageShareRequest) GetPreimageShare() *SecretShare {
	if x != nil {
		return x.PreimageShare
	}
	return nil
}

func (x *StorePreimageShareRequest) GetThreshold() uint32 {
	if x != nil {
		return x.Threshold
	}
	return 0
}

func (x *StorePreimageShareRequest) GetInvoiceString() string {
	if x != nil {
		return x.InvoiceString
	}
	return ""
}

func (x *StorePreimageShareRequest) GetUserIdentityPublicKey() []byte {
	if x != nil {
		return x.UserIdentityPublicKey
	}
	return nil
}

type RequestedSigningCommitments struct {
	state                   protoimpl.MessageState               `protogen:"open.v1"`
	SigningNonceCommitments map[string]*common.SigningCommitment `protobuf:"bytes,1,rep,name=signing_nonce_commitments,json=signingNonceCommitments,proto3" json:"signing_nonce_commitments,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
	unknownFields           protoimpl.UnknownFields
	sizeCache               protoimpl.SizeCache
}

func (x *RequestedSigningCommitments) Reset() {
	*x = RequestedSigningCommitments{}
	mi := &file_spark_proto_msgTypes[71]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *RequestedSigningCommitments) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*RequestedSigningCommitments) ProtoMessage() {}

func (x *RequestedSigningCommitments) ProtoReflect() protoreflect.Message {
	mi := &file_spark_proto_msgTypes[71]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use RequestedSigningCommitments.ProtoReflect.Descriptor instead.
func (*RequestedSigningCommitments) Descriptor() ([]byte, []int) {
	return file_spark_proto_rawDescGZIP(), []int{71}
}

func (x *RequestedSigningCommitments) GetSigningNonceCommitments() map[string]*common.SigningCommitment {
	if x != nil {
		return x.SigningNonceCommitments
	}
	return nil
}

type GetSigningCommitmentsRequest struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	NodeIds       []string               `protobuf:"bytes,1,rep,name=node_ids,json=nodeIds,proto3" json:"node_ids,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *GetSigningCommitmentsRequest) Reset() {
	*x = GetSigningCommitmentsRequest{}
	mi := &file_spark_proto_msgTypes[72]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *GetSigningCommitmentsRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*GetSigningCommitmentsRequest) ProtoMessage() {}

func (x *GetSigningCommitmentsRequest) ProtoReflect() protoreflect.Message {
	mi := &file_spark_proto_msgTypes[72]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use GetSigningCommitmentsRequest.ProtoReflect.Descriptor instead.
func (*GetSigningCommitmentsRequest) Descriptor() ([]byte, []int) {
	return file_spark_proto_rawDescGZIP(), []int{72}
}

func (x *GetSigningCommitmentsRequest) GetNodeIds() []string {
	if x != nil {
		return x.NodeIds
	}
	return nil
}

type GetSigningCommitmentsResponse struct {
	state              protoimpl.MessageState         `protogen:"open.v1"`
	SigningCommitments []*RequestedSigningCommitments `protobuf:"bytes,1,rep,name=signing_commitments,json=signingCommitments,proto3" json:"signing_commitments,omitempty"`
	unknownFields      protoimpl.UnknownFields
	sizeCache          protoimpl.SizeCache
}

func (x *GetSigningCommitmentsResponse) Reset() {
	*x = GetSigningCommitmentsResponse{}
	mi := &file_spark_proto_msgTypes[73]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *GetSigningCommitmentsResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*GetSigningCommitmentsResponse) ProtoMessage() {}

func (x *GetSigningCommitmentsResponse) ProtoReflect() protoreflect.Message {
	mi := &file_spark_proto_msgTypes[73]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use GetSigningCommitmentsResponse.ProtoReflect.Descriptor instead.
func (*GetSigningCommitmentsResponse) Descriptor() ([]byte, []int) {
	return file_spark_proto_rawDescGZIP(), []int{73}
}

func (x *GetSigningCommitmentsResponse) GetSigningCommitments() []*RequestedSigningCommitments {
	if x != nil {
		return x.SigningCommitments
	}
	return nil
}

type SigningCommitments struct {
	state              protoimpl.MessageState               `protogen:"open.v1"`
	SigningCommitments map[string]*common.SigningCommitment `protobuf:"bytes,1,rep,name=signing_commitments,json=signingCommitments,proto3" json:"signing_commitments,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
	unknownFields      protoimpl.UnknownFields
	sizeCache          protoimpl.SizeCache
}

func (x *SigningCommitments) Reset() {
	*x = SigningCommitments{}
	mi := &file_spark_proto_msgTypes[74]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *SigningCommitments) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*SigningCommitments) ProtoMessage() {}

func (x *SigningCommitments) ProtoReflect() protoreflect.Message {
	mi := &file_spark_proto_msgTypes[74]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use SigningCommitments.ProtoReflect.Descriptor instead.
func (*SigningCommitments) Descriptor() ([]byte, []int) {
	return file_spark_proto_rawDescGZIP(), []int{74}
}

func (x *SigningCommitments) GetSigningCommitments() map[string]*common.SigningCommitment {
	if x != nil {
		return x.SigningCommitments
	}
	return nil
}

type UserSignedRefund struct {
	state                   protoimpl.MessageState    `protogen:"open.v1"`
	NodeId                  string                    `protobuf:"bytes,1,opt,name=node_id,json=nodeId,proto3" json:"node_id,omitempty"`
	RefundTx                []byte                    `protobuf:"bytes,2,opt,name=refund_tx,json=refundTx,proto3" json:"refund_tx,omitempty"`
	UserSignature           []byte                    `protobuf:"bytes,3,opt,name=user_signature,json=userSignature,proto3" json:"user_signature,omitempty"`
	SigningCommitments      *SigningCommitments       `protobuf:"bytes,4,opt,name=signing_commitments,json=signingCommitments,proto3" json:"signing_commitments,omitempty"`
	UserSignatureCommitment *common.SigningCommitment `protobuf:"bytes,5,opt,name=user_signature_commitment,json=userSignatureCommitment,proto3" json:"user_signature_commitment,omitempty"`
	Network                 Network                   `protobuf:"varint,6,opt,name=network,proto3,enum=spark.Network" json:"network,omitempty"`
	unknownFields           protoimpl.UnknownFields
	sizeCache               protoimpl.SizeCache
}

func (x *UserSignedRefund) Reset() {
	*x = UserSignedRefund{}
	mi := &file_spark_proto_msgTypes[75]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *UserSignedRefund) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*UserSignedRefund) ProtoMessage() {}

func (x *UserSignedRefund) ProtoReflect() protoreflect.Message {
	mi := &file_spark_proto_msgTypes[75]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use UserSignedRefund.ProtoReflect.Descriptor instead.
func (*UserSignedRefund) Descriptor() ([]byte, []int) {
	return file_spark_proto_rawDescGZIP(), []int{75}
}

func (x *UserSignedRefund) GetNodeId() string {
	if x != nil {
		return x.NodeId
	}
	return ""
}

func (x *UserSignedRefund) GetRefundTx() []byte {
	if x != nil {
		return x.RefundTx
	}
	return nil
}

func (x *UserSignedRefund) GetUserSignature() []byte {
	if x != nil {
		return x.UserSignature
	}
	return nil
}

func (x *UserSignedRefund) GetSigningCommitments() *SigningCommitments {
	if x != nil {
		return x.SigningCommitments
	}
	return nil
}

func (x *UserSignedRefund) GetUserSignatureCommitment() *common.SigningCommitment {
	if x != nil {
		return x.UserSignatureCommitment
	}
	return nil
}

func (x *UserSignedRefund) GetNetwork() Network {
	if x != nil {
		return x.Network
	}
	return Network_UNSPECIFIED
}

type InvoiceAmountProof struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Bolt11Invoice string                 `protobuf:"bytes,1,opt,name=bolt11_invoice,json=bolt11Invoice,proto3" json:"bolt11_invoice,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *InvoiceAmountProof) Reset() {
	*x = InvoiceAmountProof{}
	mi := &file_spark_proto_msgTypes[76]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *InvoiceAmountProof) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*InvoiceAmountProof) ProtoMessage() {}

func (x *InvoiceAmountProof) ProtoReflect() protoreflect.Message {
	mi := &file_spark_proto_msgTypes[76]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use InvoiceAmountProof.ProtoReflect.Descriptor instead.
func (*InvoiceAmountProof) Descriptor() ([]byte, []int) {
	return file_spark_proto_rawDescGZIP(), []int{76}
}

func (x *InvoiceAmountProof) GetBolt11Invoice() string {
	if x != nil {
		return x.Bolt11Invoice
	}
	return ""
}

type InvoiceAmount struct {
	state              protoimpl.MessageState `protogen:"open.v1"`
	ValueSats          uint64                 `protobuf:"varint,1,opt,name=value_sats,json=valueSats,proto3" json:"value_sats,omitempty"`
	InvoiceAmountProof *InvoiceAmountProof    `protobuf:"bytes,2,opt,name=invoice_amount_proof,json=invoiceAmountProof,proto3" json:"invoice_amount_proof,omitempty"`
	unknownFields      protoimpl.UnknownFields
	sizeCache          protoimpl.SizeCache
}

func (x *InvoiceAmount) Reset() {
	*x = InvoiceAmount{}
	mi := &file_spark_proto_msgTypes[77]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *InvoiceAmount) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*InvoiceAmount) ProtoMessage() {}

func (x *InvoiceAmount) ProtoReflect() protoreflect.Message {
	mi := &file_spark_proto_msgTypes[77]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use InvoiceAmount.ProtoReflect.Descriptor instead.
func (*InvoiceAmount) Descriptor() ([]byte, []int) {
	return file_spark_proto_rawDescGZIP(), []int{77}
}

func (x *InvoiceAmount) GetValueSats() uint64 {
	if x != nil {
		return x.ValueSats
	}
	return 0
}

func (x *InvoiceAmount) GetInvoiceAmountProof() *InvoiceAmountProof {
	if x != nil {
		return x.InvoiceAmountProof
	}
	return nil
}

type InitiatePreimageSwapRequest struct {
	state                     protoimpl.MessageState             `protogen:"open.v1"`
	PaymentHash               []byte                             `protobuf:"bytes,1,opt,name=payment_hash,json=paymentHash,proto3" json:"payment_hash,omitempty"`
	InvoiceAmount             *InvoiceAmount                     `protobuf:"bytes,2,opt,name=invoice_amount,json=invoiceAmount,proto3" json:"invoice_amount,omitempty"`
	Reason                    InitiatePreimageSwapRequest_Reason `protobuf:"varint,3,opt,name=reason,proto3,enum=spark.InitiatePreimageSwapRequest_Reason" json:"reason,omitempty"`
	Transfer                  *StartUserSignedTransferRequest    `protobuf:"bytes,4,opt,name=transfer,proto3" json:"transfer,omitempty"`
	ReceiverIdentityPublicKey []byte                             `protobuf:"bytes,5,opt,name=receiver_identity_public_key,json=receiverIdentityPublicKey,proto3" json:"receiver_identity_public_key,omitempty"`
	FeeSats                   uint64                             `protobuf:"varint,6,opt,name=fee_sats,json=feeSats,proto3" json:"fee_sats,omitempty"`
	unknownFields             protoimpl.UnknownFields
	sizeCache                 protoimpl.SizeCache
}

func (x *InitiatePreimageSwapRequest) Reset() {
	*x = InitiatePreimageSwapRequest{}
	mi := &file_spark_proto_msgTypes[78]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *InitiatePreimageSwapRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*InitiatePreimageSwapRequest) ProtoMessage() {}

func (x *InitiatePreimageSwapRequest) ProtoReflect() protoreflect.Message {
	mi := &file_spark_proto_msgTypes[78]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use InitiatePreimageSwapRequest.ProtoReflect.Descriptor instead.
func (*InitiatePreimageSwapRequest) Descriptor() ([]byte, []int) {
	return file_spark_proto_rawDescGZIP(), []int{78}
}

func (x *InitiatePreimageSwapRequest) GetPaymentHash() []byte {
	if x != nil {
		return x.PaymentHash
	}
	return nil
}

func (x *InitiatePreimageSwapRequest) GetInvoiceAmount() *InvoiceAmount {
	if x != nil {
		return x.InvoiceAmount
	}
	return nil
}

func (x *InitiatePreimageSwapRequest) GetReason() InitiatePreimageSwapRequest_Reason {
	if x != nil {
		return x.Reason
	}
	return InitiatePreimageSwapRequest_REASON_SEND
}

func (x *InitiatePreimageSwapRequest) GetTransfer() *StartUserSignedTransferRequest {
	if x != nil {
		return x.Transfer
	}
	return nil
}

func (x *InitiatePreimageSwapRequest) GetReceiverIdentityPublicKey() []byte {
	if x != nil {
		return x.ReceiverIdentityPublicKey
	}
	return nil
}

func (x *InitiatePreimageSwapRequest) GetFeeSats() uint64 {
	if x != nil {
		return x.FeeSats
	}
	return 0
}

type InitiatePreimageSwapResponse struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Preimage      []byte                 `protobuf:"bytes,1,opt,name=preimage,proto3" json:"preimage,omitempty"`
	Transfer      *Transfer              `protobuf:"bytes,2,opt,name=transfer,proto3" json:"transfer,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *InitiatePreimageSwapResponse) Reset() {
	*x = InitiatePreimageSwapResponse{}
	mi := &file_spark_proto_msgTypes[79]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *InitiatePreimageSwapResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*InitiatePreimageSwapResponse) ProtoMessage() {}

func (x *InitiatePreimageSwapResponse) ProtoReflect() protoreflect.Message {
	mi := &file_spark_proto_msgTypes[79]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use InitiatePreimageSwapResponse.ProtoReflect.Descriptor instead.
func (*InitiatePreimageSwapResponse) Descriptor() ([]byte, []int) {
	return file_spark_proto_rawDescGZIP(), []int{79}
}

func (x *InitiatePreimageSwapResponse) GetPreimage() []byte {
	if x != nil {
		return x.Preimage
	}
	return nil
}

func (x *InitiatePreimageSwapResponse) GetTransfer() *Transfer {
	if x != nil {
		return x.Transfer
	}
	return nil
}

type OutPoint struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Txid          []byte                 `protobuf:"bytes,1,opt,name=txid,proto3" json:"txid,omitempty"`
	Vout          uint32                 `protobuf:"varint,2,opt,name=vout,proto3" json:"vout,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *OutPoint) Reset() {
	*x = OutPoint{}
	mi := &file_spark_proto_msgTypes[80]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *OutPoint) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*OutPoint) ProtoMessage() {}

func (x *OutPoint) ProtoReflect() protoreflect.Message {
	mi := &file_spark_proto_msgTypes[80]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use OutPoint.ProtoReflect.Descriptor instead.
func (*OutPoint) Descriptor() ([]byte, []int) {
	return file_spark_proto_rawDescGZIP(), []int{80}
}

func (x *OutPoint) GetTxid() []byte {
	if x != nil {
		return x.Txid
	}
	return nil
}

func (x *OutPoint) GetVout() uint32 {
	if x != nil {
		return x.Vout
	}
	return 0
}

type CooperativeExitRequest struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Transfer      *StartTransferRequest  `protobuf:"bytes,1,opt,name=transfer,proto3" json:"transfer,omitempty"`
	ExitId        string                 `protobuf:"bytes,2,opt,name=exit_id,json=exitId,proto3" json:"exit_id,omitempty"`
	ExitTxid      []byte                 `protobuf:"bytes,3,opt,name=exit_txid,json=exitTxid,proto3" json:"exit_txid,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *CooperativeExitRequest) Reset() {
	*x = CooperativeExitRequest{}
	mi := &file_spark_proto_msgTypes[81]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *CooperativeExitRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*CooperativeExitRequest) ProtoMessage() {}

func (x *CooperativeExitRequest) ProtoReflect() protoreflect.Message {
	mi := &file_spark_proto_msgTypes[81]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use CooperativeExitRequest.ProtoReflect.Descriptor instead.
func (*CooperativeExitRequest) Descriptor() ([]byte, []int) {
	return file_spark_proto_rawDescGZIP(), []int{81}
}

func (x *CooperativeExitRequest) GetTransfer() *StartTransferRequest {
	if x != nil {
		return x.Transfer
	}
	return nil
}

func (x *CooperativeExitRequest) GetExitId() string {
	if x != nil {
		return x.ExitId
	}
	return ""
}

func (x *CooperativeExitRequest) GetExitTxid() []byte {
	if x != nil {
		return x.ExitTxid
	}
	return nil
}

type CooperativeExitResponse struct {
	state          protoimpl.MessageState       `protogen:"open.v1"`
	Transfer       *Transfer                    `protobuf:"bytes,1,opt,name=transfer,proto3" json:"transfer,omitempty"`
	SigningResults []*LeafRefundTxSigningResult `protobuf:"bytes,2,rep,name=signing_results,json=signingResults,proto3" json:"signing_results,omitempty"`
	unknownFields  protoimpl.UnknownFields
	sizeCache      protoimpl.SizeCache
}

func (x *CooperativeExitResponse) Reset() {
	*x = CooperativeExitResponse{}
	mi := &file_spark_proto_msgTypes[82]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *CooperativeExitResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*CooperativeExitResponse) ProtoMessage() {}

func (x *CooperativeExitResponse) ProtoReflect() protoreflect.Message {
	mi := &file_spark_proto_msgTypes[82]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use CooperativeExitResponse.ProtoReflect.Descriptor instead.
func (*CooperativeExitResponse) Descriptor() ([]byte, []int) {
	return file_spark_proto_rawDescGZIP(), []int{82}
}

func (x *CooperativeExitResponse) GetTransfer() *Transfer {
	if x != nil {
		return x.Transfer
	}
	return nil
}

func (x *CooperativeExitResponse) GetSigningResults() []*LeafRefundTxSigningResult {
	if x != nil {
		return x.SigningResults
	}
	return nil
}

type CounterLeafSwapRequest struct {
	state            protoimpl.MessageState `protogen:"open.v1"`
	Transfer         *StartTransferRequest  `protobuf:"bytes,1,opt,name=transfer,proto3" json:"transfer,omitempty"`
	SwapId           string                 `protobuf:"bytes,2,opt,name=swap_id,json=swapId,proto3" json:"swap_id,omitempty"`
	AdaptorPublicKey []byte                 `protobuf:"bytes,3,opt,name=adaptor_public_key,json=adaptorPublicKey,proto3" json:"adaptor_public_key,omitempty"`
	unknownFields    protoimpl.UnknownFields
	sizeCache        protoimpl.SizeCache
}

func (x *CounterLeafSwapRequest) Reset() {
	*x = CounterLeafSwapRequest{}
	mi := &file_spark_proto_msgTypes[83]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *CounterLeafSwapRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*CounterLeafSwapRequest) ProtoMessage() {}

func (x *CounterLeafSwapRequest) ProtoReflect() protoreflect.Message {
	mi := &file_spark_proto_msgTypes[83]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use CounterLeafSwapRequest.ProtoReflect.Descriptor instead.
func (*CounterLeafSwapRequest) Descriptor() ([]byte, []int) {
	return file_spark_proto_rawDescGZIP(), []int{83}
}

func (x *CounterLeafSwapRequest) GetTransfer() *StartTransferRequest {
	if x != nil {
		return x.Transfer
	}
	return nil
}

func (x *CounterLeafSwapRequest) GetSwapId() string {
	if x != nil {
		return x.SwapId
	}
	return ""
}

func (x *CounterLeafSwapRequest) GetAdaptorPublicKey() []byte {
	if x != nil {
		return x.AdaptorPublicKey
	}
	return nil
}

type CounterLeafSwapResponse struct {
	state          protoimpl.MessageState       `protogen:"open.v1"`
	Transfer       *Transfer                    `protobuf:"bytes,1,opt,name=transfer,proto3" json:"transfer,omitempty"`
	SigningResults []*LeafRefundTxSigningResult `protobuf:"bytes,2,rep,name=signing_results,json=signingResults,proto3" json:"signing_results,omitempty"`
	unknownFields  protoimpl.UnknownFields
	sizeCache      protoimpl.SizeCache
}

func (x *CounterLeafSwapResponse) Reset() {
	*x = CounterLeafSwapResponse{}
	mi := &file_spark_proto_msgTypes[84]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *CounterLeafSwapResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*CounterLeafSwapResponse) ProtoMessage() {}

func (x *CounterLeafSwapResponse) ProtoReflect() protoreflect.Message {
	mi := &file_spark_proto_msgTypes[84]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use CounterLeafSwapResponse.ProtoReflect.Descriptor instead.
func (*CounterLeafSwapResponse) Descriptor() ([]byte, []int) {
	return file_spark_proto_rawDescGZIP(), []int{84}
}

func (x *CounterLeafSwapResponse) GetTransfer() *Transfer {
	if x != nil {
		return x.Transfer
	}
	return nil
}

func (x *CounterLeafSwapResponse) GetSigningResults() []*LeafRefundTxSigningResult {
	if x != nil {
		return x.SigningResults
	}
	return nil
}

type RefreshTimelockRequest struct {
	state                  protoimpl.MessageState `protogen:"open.v1"`
	LeafId                 string                 `protobuf:"bytes,1,opt,name=leaf_id,json=leafId,proto3" json:"leaf_id,omitempty"`
	OwnerIdentityPublicKey []byte                 `protobuf:"bytes,2,opt,name=owner_identity_public_key,json=ownerIdentityPublicKey,proto3" json:"owner_identity_public_key,omitempty"`
	SigningJobs            []*SigningJob          `protobuf:"bytes,3,rep,name=signing_jobs,json=signingJobs,proto3" json:"signing_jobs,omitempty"`
	unknownFields          protoimpl.UnknownFields
	sizeCache              protoimpl.SizeCache
}

func (x *RefreshTimelockRequest) Reset() {
	*x = RefreshTimelockRequest{}
	mi := &file_spark_proto_msgTypes[85]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *RefreshTimelockRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*RefreshTimelockRequest) ProtoMessage() {}

func (x *RefreshTimelockRequest) ProtoReflect() protoreflect.Message {
	mi := &file_spark_proto_msgTypes[85]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use RefreshTimelockRequest.ProtoReflect.Descriptor instead.
func (*RefreshTimelockRequest) Descriptor() ([]byte, []int) {
	return file_spark_proto_rawDescGZIP(), []int{85}
}

func (x *RefreshTimelockRequest) GetLeafId() string {
	if x != nil {
		return x.LeafId
	}
	return ""
}

func (x *RefreshTimelockRequest) GetOwnerIdentityPublicKey() []byte {
	if x != nil {
		return x.OwnerIdentityPublicKey
	}
	return nil
}

func (x *RefreshTimelockRequest) GetSigningJobs() []*SigningJob {
	if x != nil {
		return x.SigningJobs
	}
	return nil
}

type RefreshTimelockSigningResult struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	SigningResult *SigningResult         `protobuf:"bytes,1,opt,name=signing_result,json=signingResult,proto3" json:"signing_result,omitempty"`
	VerifyingKey  []byte                 `protobuf:"bytes,2,opt,name=verifying_key,json=verifyingKey,proto3" json:"verifying_key,omitempty"` // Should maybe just be a part of SigningResult?
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *RefreshTimelockSigningResult) Reset() {
	*x = RefreshTimelockSigningResult{}
	mi := &file_spark_proto_msgTypes[86]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *RefreshTimelockSigningResult) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*RefreshTimelockSigningResult) ProtoMessage() {}

func (x *RefreshTimelockSigningResult) ProtoReflect() protoreflect.Message {
	mi := &file_spark_proto_msgTypes[86]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use RefreshTimelockSigningResult.ProtoReflect.Descriptor instead.
func (*RefreshTimelockSigningResult) Descriptor() ([]byte, []int) {
	return file_spark_proto_rawDescGZIP(), []int{86}
}

func (x *RefreshTimelockSigningResult) GetSigningResult() *SigningResult {
	if x != nil {
		return x.SigningResult
	}
	return nil
}

func (x *RefreshTimelockSigningResult) GetVerifyingKey() []byte {
	if x != nil {
		return x.VerifyingKey
	}
	return nil
}

type RefreshTimelockResponse struct {
	state          protoimpl.MessageState          `protogen:"open.v1"`
	SigningResults []*RefreshTimelockSigningResult `protobuf:"bytes,1,rep,name=signing_results,json=signingResults,proto3" json:"signing_results,omitempty"`
	unknownFields  protoimpl.UnknownFields
	sizeCache      protoimpl.SizeCache
}

func (x *RefreshTimelockResponse) Reset() {
	*x = RefreshTimelockResponse{}
	mi := &file_spark_proto_msgTypes[87]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *RefreshTimelockResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*RefreshTimelockResponse) ProtoMessage() {}

func (x *RefreshTimelockResponse) ProtoReflect() protoreflect.Message {
	mi := &file_spark_proto_msgTypes[87]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use RefreshTimelockResponse.ProtoReflect.Descriptor instead.
func (*RefreshTimelockResponse) Descriptor() ([]byte, []int) {
	return file_spark_proto_rawDescGZIP(), []int{87}
}

func (x *RefreshTimelockResponse) GetSigningResults() []*RefreshTimelockSigningResult {
	if x != nil {
		return x.SigningResults
	}
	return nil
}

type ExtendLeafRequest struct {
	state                  protoimpl.MessageState `protogen:"open.v1"`
	LeafId                 string                 `protobuf:"bytes,1,opt,name=leaf_id,json=leafId,proto3" json:"leaf_id,omitempty"`
	OwnerIdentityPublicKey []byte                 `protobuf:"bytes,2,opt,name=owner_identity_public_key,json=ownerIdentityPublicKey,proto3" json:"owner_identity_public_key,omitempty"`
	NodeTxSigningJob       *SigningJob            `protobuf:"bytes,3,opt,name=node_tx_signing_job,json=nodeTxSigningJob,proto3" json:"node_tx_signing_job,omitempty"`
	RefundTxSigningJob     *SigningJob            `protobuf:"bytes,4,opt,name=refund_tx_signing_job,json=refundTxSigningJob,proto3" json:"refund_tx_signing_job,omitempty"`
	unknownFields          protoimpl.UnknownFields
	sizeCache              protoimpl.SizeCache
}

func (x *ExtendLeafRequest) Reset() {
	*x = ExtendLeafRequest{}
	mi := &file_spark_proto_msgTypes[88]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ExtendLeafRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ExtendLeafRequest) ProtoMessage() {}

func (x *ExtendLeafRequest) ProtoReflect() protoreflect.Message {
	mi := &file_spark_proto_msgTypes[88]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ExtendLeafRequest.ProtoReflect.Descriptor instead.
func (*ExtendLeafRequest) Descriptor() ([]byte, []int) {
	return file_spark_proto_rawDescGZIP(), []int{88}
}

func (x *ExtendLeafRequest) GetLeafId() string {
	if x != nil {
		return x.LeafId
	}
	return ""
}

func (x *ExtendLeafRequest) GetOwnerIdentityPublicKey() []byte {
	if x != nil {
		return x.OwnerIdentityPublicKey
	}
	return nil
}

func (x *ExtendLeafRequest) GetNodeTxSigningJob() *SigningJob {
	if x != nil {
		return x.NodeTxSigningJob
	}
	return nil
}

func (x *ExtendLeafRequest) GetRefundTxSigningJob() *SigningJob {
	if x != nil {
		return x.RefundTxSigningJob
	}
	return nil
}

type ExtendLeafSigningResult struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	SigningResult *SigningResult         `protobuf:"bytes,1,opt,name=signing_result,json=signingResult,proto3" json:"signing_result,omitempty"`
	VerifyingKey  []byte                 `protobuf:"bytes,2,opt,name=verifying_key,json=verifyingKey,proto3" json:"verifying_key,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *ExtendLeafSigningResult) Reset() {
	*x = ExtendLeafSigningResult{}
	mi := &file_spark_proto_msgTypes[89]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ExtendLeafSigningResult) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ExtendLeafSigningResult) ProtoMessage() {}

func (x *ExtendLeafSigningResult) ProtoReflect() protoreflect.Message {
	mi := &file_spark_proto_msgTypes[89]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ExtendLeafSigningResult.ProtoReflect.Descriptor instead.
func (*ExtendLeafSigningResult) Descriptor() ([]byte, []int) {
	return file_spark_proto_rawDescGZIP(), []int{89}
}

func (x *ExtendLeafSigningResult) GetSigningResult() *SigningResult {
	if x != nil {
		return x.SigningResult
	}
	return nil
}

func (x *ExtendLeafSigningResult) GetVerifyingKey() []byte {
	if x != nil {
		return x.VerifyingKey
	}
	return nil
}

type ExtendLeafResponse struct {
	state                 protoimpl.MessageState   `protogen:"open.v1"`
	LeafId                string                   `protobuf:"bytes,1,opt,name=leaf_id,json=leafId,proto3" json:"leaf_id,omitempty"`
	NodeTxSigningResult   *ExtendLeafSigningResult `protobuf:"bytes,2,opt,name=node_tx_signing_result,json=nodeTxSigningResult,proto3" json:"node_tx_signing_result,omitempty"`
	RefundTxSigningResult *ExtendLeafSigningResult `protobuf:"bytes,3,opt,name=refund_tx_signing_result,json=refundTxSigningResult,proto3" json:"refund_tx_signing_result,omitempty"`
	unknownFields         protoimpl.UnknownFields
	sizeCache             protoimpl.SizeCache
}

func (x *ExtendLeafResponse) Reset() {
	*x = ExtendLeafResponse{}
	mi := &file_spark_proto_msgTypes[90]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ExtendLeafResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ExtendLeafResponse) ProtoMessage() {}

func (x *ExtendLeafResponse) ProtoReflect() protoreflect.Message {
	mi := &file_spark_proto_msgTypes[90]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ExtendLeafResponse.ProtoReflect.Descriptor instead.
func (*ExtendLeafResponse) Descriptor() ([]byte, []int) {
	return file_spark_proto_rawDescGZIP(), []int{90}
}

func (x *ExtendLeafResponse) GetLeafId() string {
	if x != nil {
		return x.LeafId
	}
	return ""
}

func (x *ExtendLeafResponse) GetNodeTxSigningResult() *ExtendLeafSigningResult {
	if x != nil {
		return x.NodeTxSigningResult
	}
	return nil
}

func (x *ExtendLeafResponse) GetRefundTxSigningResult() *ExtendLeafSigningResult {
	if x != nil {
		return x.RefundTxSigningResult
	}
	return nil
}

type AddressRequestNode struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	UserPublicKey []byte                 `protobuf:"bytes,1,opt,name=user_public_key,json=userPublicKey,proto3" json:"user_public_key,omitempty"`
	Children      []*AddressRequestNode  `protobuf:"bytes,2,rep,name=children,proto3" json:"children,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *AddressRequestNode) Reset() {
	*x = AddressRequestNode{}
	mi := &file_spark_proto_msgTypes[91]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *AddressRequestNode) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*AddressRequestNode) ProtoMessage() {}

func (x *AddressRequestNode) ProtoReflect() protoreflect.Message {
	mi := &file_spark_proto_msgTypes[91]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use AddressRequestNode.ProtoReflect.Descriptor instead.
func (*AddressRequestNode) Descriptor() ([]byte, []int) {
	return file_spark_proto_rawDescGZIP(), []int{91}
}

func (x *AddressRequestNode) GetUserPublicKey() []byte {
	if x != nil {
		return x.UserPublicKey
	}
	return nil
}

func (x *AddressRequestNode) GetChildren() []*AddressRequestNode {
	if x != nil {
		return x.Children
	}
	return nil
}

type PrepareTreeAddressRequest struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Types that are valid to be assigned to Source:
	//
	//	*PrepareTreeAddressRequest_ParentNodeOutput
	//	*PrepareTreeAddressRequest_OnChainUtxo
	Source isPrepareTreeAddressRequest_Source `protobuf_oneof:"source"`
	// The tx on this node is to spend the source's utxo.
	// The user's public key should already be registered with the SE for the root node.
	Node                  *AddressRequestNode `protobuf:"bytes,3,opt,name=node,proto3" json:"node,omitempty"`
	UserIdentityPublicKey []byte              `protobuf:"bytes,4,opt,name=user_identity_public_key,json=userIdentityPublicKey,proto3" json:"user_identity_public_key,omitempty"`
	unknownFields         protoimpl.UnknownFields
	sizeCache             protoimpl.SizeCache
}

func (x *PrepareTreeAddressRequest) Reset() {
	*x = PrepareTreeAddressRequest{}
	mi := &file_spark_proto_msgTypes[92]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *PrepareTreeAddressRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*PrepareTreeAddressRequest) ProtoMessage() {}

func (x *PrepareTreeAddressRequest) ProtoReflect() protoreflect.Message {
	mi := &file_spark_proto_msgTypes[92]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use PrepareTreeAddressRequest.ProtoReflect.Descriptor instead.
func (*PrepareTreeAddressRequest) Descriptor() ([]byte, []int) {
	return file_spark_proto_rawDescGZIP(), []int{92}
}

func (x *PrepareTreeAddressRequest) GetSource() isPrepareTreeAddressRequest_Source {
	if x != nil {
		return x.Source
	}
	return nil
}

func (x *PrepareTreeAddressRequest) GetParentNodeOutput() *NodeOutput {
	if x != nil {
		if x, ok := x.Source.(*PrepareTreeAddressRequest_ParentNodeOutput); ok {
			return x.ParentNodeOutput
		}
	}
	return nil
}

func (x *PrepareTreeAddressRequest) GetOnChainUtxo() *UTXO {
	if x != nil {
		if x, ok := x.Source.(*PrepareTreeAddressRequest_OnChainUtxo); ok {
			return x.OnChainUtxo
		}
	}
	return nil
}

func (x *PrepareTreeAddressRequest) GetNode() *AddressRequestNode {
	if x != nil {
		return x.Node
	}
	return nil
}

func (x *PrepareTreeAddressRequest) GetUserIdentityPublicKey() []byte {
	if x != nil {
		return x.UserIdentityPublicKey
	}
	return nil
}

type isPrepareTreeAddressRequest_Source interface {
	isPrepareTreeAddressRequest_Source()
}

type PrepareTreeAddressRequest_ParentNodeOutput struct {
	ParentNodeOutput *NodeOutput `protobuf:"bytes,1,opt,name=parent_node_output,json=parentNodeOutput,proto3,oneof"`
}

type PrepareTreeAddressRequest_OnChainUtxo struct {
	OnChainUtxo *UTXO `protobuf:"bytes,2,opt,name=on_chain_utxo,json=onChainUtxo,proto3,oneof"`
}

func (*PrepareTreeAddressRequest_ParentNodeOutput) isPrepareTreeAddressRequest_Source() {}

func (*PrepareTreeAddressRequest_OnChainUtxo) isPrepareTreeAddressRequest_Source() {}

type AddressNode struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Address       *Address               `protobuf:"bytes,1,opt,name=address,proto3" json:"address,omitempty"`
	Children      []*AddressNode         `protobuf:"bytes,2,rep,name=children,proto3" json:"children,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *AddressNode) Reset() {
	*x = AddressNode{}
	mi := &file_spark_proto_msgTypes[93]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *AddressNode) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*AddressNode) ProtoMessage() {}

func (x *AddressNode) ProtoReflect() protoreflect.Message {
	mi := &file_spark_proto_msgTypes[93]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use AddressNode.ProtoReflect.Descriptor instead.
func (*AddressNode) Descriptor() ([]byte, []int) {
	return file_spark_proto_rawDescGZIP(), []int{93}
}

func (x *AddressNode) GetAddress() *Address {
	if x != nil {
		return x.Address
	}
	return nil
}

func (x *AddressNode) GetChildren() []*AddressNode {
	if x != nil {
		return x.Children
	}
	return nil
}

type PrepareTreeAddressResponse struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Node          *AddressNode           `protobuf:"bytes,1,opt,name=node,proto3" json:"node,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *PrepareTreeAddressResponse) Reset() {
	*x = PrepareTreeAddressResponse{}
	mi := &file_spark_proto_msgTypes[94]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *PrepareTreeAddressResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*PrepareTreeAddressResponse) ProtoMessage() {}

func (x *PrepareTreeAddressResponse) ProtoReflect() protoreflect.Message {
	mi := &file_spark_proto_msgTypes[94]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use PrepareTreeAddressResponse.ProtoReflect.Descriptor instead.
func (*PrepareTreeAddressResponse) Descriptor() ([]byte, []int) {
	return file_spark_proto_rawDescGZIP(), []int{94}
}

func (x *PrepareTreeAddressResponse) GetNode() *AddressNode {
	if x != nil {
		return x.Node
	}
	return nil
}

type CreationNode struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// This is the tx that spends the parent node's output.
	NodeTxSigningJob *SigningJob `protobuf:"bytes,1,opt,name=node_tx_signing_job,json=nodeTxSigningJob,proto3" json:"node_tx_signing_job,omitempty"`
	// The refund tx can only exist if there's no children.
	RefundTxSigningJob *SigningJob `protobuf:"bytes,2,opt,name=refund_tx_signing_job,json=refundTxSigningJob,proto3" json:"refund_tx_signing_job,omitempty"`
	// The children will spend the output of the node's tx. Vout is the index of the child.
	Children      []*CreationNode `protobuf:"bytes,3,rep,name=children,proto3" json:"children,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *CreationNode) Reset() {
	*x = CreationNode{}
	mi := &file_spark_proto_msgTypes[95]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *CreationNode) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*CreationNode) ProtoMessage() {}

func (x *CreationNode) ProtoReflect() protoreflect.Message {
	mi := &file_spark_proto_msgTypes[95]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use CreationNode.ProtoReflect.Descriptor instead.
func (*CreationNode) Descriptor() ([]byte, []int) {
	return file_spark_proto_rawDescGZIP(), []int{95}
}

func (x *CreationNode) GetNodeTxSigningJob() *SigningJob {
	if x != nil {
		return x.NodeTxSigningJob
	}
	return nil
}

func (x *CreationNode) GetRefundTxSigningJob() *SigningJob {
	if x != nil {
		return x.RefundTxSigningJob
	}
	return nil
}

func (x *CreationNode) GetChildren() []*CreationNode {
	if x != nil {
		return x.Children
	}
	return nil
}

type CreateTreeRequest struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Types that are valid to be assigned to Source:
	//
	//	*CreateTreeRequest_ParentNodeOutput
	//	*CreateTreeRequest_OnChainUtxo
	Source isCreateTreeRequest_Source `protobuf_oneof:"source"`
	// The node should contain the tx that spends the source's utxo.
	Node *CreationNode `protobuf:"bytes,3,opt,name=node,proto3" json:"node,omitempty"`
	// The owner of the tree.
	UserIdentityPublicKey []byte `protobuf:"bytes,4,opt,name=user_identity_public_key,json=userIdentityPublicKey,proto3" json:"user_identity_public_key,omitempty"`
	unknownFields         protoimpl.UnknownFields
	sizeCache             protoimpl.SizeCache
}

func (x *CreateTreeRequest) Reset() {
	*x = CreateTreeRequest{}
	mi := &file_spark_proto_msgTypes[96]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *CreateTreeRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*CreateTreeRequest) ProtoMessage() {}

func (x *CreateTreeRequest) ProtoReflect() protoreflect.Message {
	mi := &file_spark_proto_msgTypes[96]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use CreateTreeRequest.ProtoReflect.Descriptor instead.
func (*CreateTreeRequest) Descriptor() ([]byte, []int) {
	return file_spark_proto_rawDescGZIP(), []int{96}
}

func (x *CreateTreeRequest) GetSource() isCreateTreeRequest_Source {
	if x != nil {
		return x.Source
	}
	return nil
}

func (x *CreateTreeRequest) GetParentNodeOutput() *NodeOutput {
	if x != nil {
		if x, ok := x.Source.(*CreateTreeRequest_ParentNodeOutput); ok {
			return x.ParentNodeOutput
		}
	}
	return nil
}

func (x *CreateTreeRequest) GetOnChainUtxo() *UTXO {
	if x != nil {
		if x, ok := x.Source.(*CreateTreeRequest_OnChainUtxo); ok {
			return x.OnChainUtxo
		}
	}
	return nil
}

func (x *CreateTreeRequest) GetNode() *CreationNode {
	if x != nil {
		return x.Node
	}
	return nil
}

func (x *CreateTreeRequest) GetUserIdentityPublicKey() []byte {
	if x != nil {
		return x.UserIdentityPublicKey
	}
	return nil
}

type isCreateTreeRequest_Source interface {
	isCreateTreeRequest_Source()
}

type CreateTreeRequest_ParentNodeOutput struct {
	ParentNodeOutput *NodeOutput `protobuf:"bytes,1,opt,name=parent_node_output,json=parentNodeOutput,proto3,oneof"`
}

type CreateTreeRequest_OnChainUtxo struct {
	OnChainUtxo *UTXO `protobuf:"bytes,2,opt,name=on_chain_utxo,json=onChainUtxo,proto3,oneof"`
}

func (*CreateTreeRequest_ParentNodeOutput) isCreateTreeRequest_Source() {}

func (*CreateTreeRequest_OnChainUtxo) isCreateTreeRequest_Source() {}

type CreationResponseNode struct {
	state                 protoimpl.MessageState  `protogen:"open.v1"`
	NodeId                string                  `protobuf:"bytes,1,opt,name=node_id,json=nodeId,proto3" json:"node_id,omitempty"`
	NodeTxSigningResult   *SigningResult          `protobuf:"bytes,2,opt,name=node_tx_signing_result,json=nodeTxSigningResult,proto3" json:"node_tx_signing_result,omitempty"`
	RefundTxSigningResult *SigningResult          `protobuf:"bytes,3,opt,name=refund_tx_signing_result,json=refundTxSigningResult,proto3" json:"refund_tx_signing_result,omitempty"`
	Children              []*CreationResponseNode `protobuf:"bytes,4,rep,name=children,proto3" json:"children,omitempty"`
	unknownFields         protoimpl.UnknownFields
	sizeCache             protoimpl.SizeCache
}

func (x *CreationResponseNode) Reset() {
	*x = CreationResponseNode{}
	mi := &file_spark_proto_msgTypes[97]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *CreationResponseNode) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*CreationResponseNode) ProtoMessage() {}

func (x *CreationResponseNode) ProtoReflect() protoreflect.Message {
	mi := &file_spark_proto_msgTypes[97]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use CreationResponseNode.ProtoReflect.Descriptor instead.
func (*CreationResponseNode) Descriptor() ([]byte, []int) {
	return file_spark_proto_rawDescGZIP(), []int{97}
}

func (x *CreationResponseNode) GetNodeId() string {
	if x != nil {
		return x.NodeId
	}
	return ""
}

func (x *CreationResponseNode) GetNodeTxSigningResult() *SigningResult {
	if x != nil {
		return x.NodeTxSigningResult
	}
	return nil
}

func (x *CreationResponseNode) GetRefundTxSigningResult() *SigningResult {
	if x != nil {
		return x.RefundTxSigningResult
	}
	return nil
}

func (x *CreationResponseNode) GetChildren() []*CreationResponseNode {
	if x != nil {
		return x.Children
	}
	return nil
}

type CreateTreeResponse struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Node          *CreationResponseNode  `protobuf:"bytes,1,opt,name=node,proto3" json:"node,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *CreateTreeResponse) Reset() {
	*x = CreateTreeResponse{}
	mi := &file_spark_proto_msgTypes[98]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *CreateTreeResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*CreateTreeResponse) ProtoMessage() {}

func (x *CreateTreeResponse) ProtoReflect() protoreflect.Message {
	mi := &file_spark_proto_msgTypes[98]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use CreateTreeResponse.ProtoReflect.Descriptor instead.
func (*CreateTreeResponse) Descriptor() ([]byte, []int) {
	return file_spark_proto_rawDescGZIP(), []int{98}
}

func (x *CreateTreeResponse) GetNode() *CreationResponseNode {
	if x != nil {
		return x.Node
	}
	return nil
}

type SigningOperatorInfo struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Index         uint64                 `protobuf:"varint,1,opt,name=index,proto3" json:"index,omitempty"`
	Identifier    string                 `protobuf:"bytes,2,opt,name=identifier,proto3" json:"identifier,omitempty"`
	PublicKey     []byte                 `protobuf:"bytes,3,opt,name=public_key,json=publicKey,proto3" json:"public_key,omitempty"`
	Address       string                 `protobuf:"bytes,4,opt,name=address,proto3" json:"address,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *SigningOperatorInfo) Reset() {
	*x = SigningOperatorInfo{}
	mi := &file_spark_proto_msgTypes[99]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *SigningOperatorInfo) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*SigningOperatorInfo) ProtoMessage() {}

func (x *SigningOperatorInfo) ProtoReflect() protoreflect.Message {
	mi := &file_spark_proto_msgTypes[99]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use SigningOperatorInfo.ProtoReflect.Descriptor instead.
func (*SigningOperatorInfo) Descriptor() ([]byte, []int) {
	return file_spark_proto_rawDescGZIP(), []int{99}
}

func (x *SigningOperatorInfo) GetIndex() uint64 {
	if x != nil {
		return x.Index
	}
	return 0
}

func (x *SigningOperatorInfo) GetIdentifier() string {
	if x != nil {
		return x.Identifier
	}
	return ""
}

func (x *SigningOperatorInfo) GetPublicKey() []byte {
	if x != nil {
		return x.PublicKey
	}
	return nil
}

func (x *SigningOperatorInfo) GetAddress() string {
	if x != nil {
		return x.Address
	}
	return ""
}

type GetSigningOperatorListResponse struct {
	state            protoimpl.MessageState          `protogen:"open.v1"`
	SigningOperators map[string]*SigningOperatorInfo `protobuf:"bytes,1,rep,name=signing_operators,json=signingOperators,proto3" json:"signing_operators,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
	unknownFields    protoimpl.UnknownFields
	sizeCache        protoimpl.SizeCache
}

func (x *GetSigningOperatorListResponse) Reset() {
	*x = GetSigningOperatorListResponse{}
	mi := &file_spark_proto_msgTypes[100]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *GetSigningOperatorListResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*GetSigningOperatorListResponse) ProtoMessage() {}

func (x *GetSigningOperatorListResponse) ProtoReflect() protoreflect.Message {
	mi := &file_spark_proto_msgTypes[100]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use GetSigningOperatorListResponse.ProtoReflect.Descriptor instead.
func (*GetSigningOperatorListResponse) Descriptor() ([]byte, []int) {
	return file_spark_proto_rawDescGZIP(), []int{100}
}

func (x *GetSigningOperatorListResponse) GetSigningOperators() map[string]*SigningOperatorInfo {
	if x != nil {
		return x.SigningOperators
	}
	return nil
}

type QueryUserSignedRefundsRequest struct {
	state             protoimpl.MessageState `protogen:"open.v1"`
	PaymentHash       []byte                 `protobuf:"bytes,1,opt,name=payment_hash,json=paymentHash,proto3" json:"payment_hash,omitempty"`
	IdentityPublicKey []byte                 `protobuf:"bytes,2,opt,name=identity_public_key,json=identityPublicKey,proto3" json:"identity_public_key,omitempty"`
	unknownFields     protoimpl.UnknownFields
	sizeCache         protoimpl.SizeCache
}

func (x *QueryUserSignedRefundsRequest) Reset() {
	*x = QueryUserSignedRefundsRequest{}
	mi := &file_spark_proto_msgTypes[101]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *QueryUserSignedRefundsRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*QueryUserSignedRefundsRequest) ProtoMessage() {}

func (x *QueryUserSignedRefundsRequest) ProtoReflect() protoreflect.Message {
	mi := &file_spark_proto_msgTypes[101]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use QueryUserSignedRefundsRequest.ProtoReflect.Descriptor instead.
func (*QueryUserSignedRefundsRequest) Descriptor() ([]byte, []int) {
	return file_spark_proto_rawDescGZIP(), []int{101}
}

func (x *QueryUserSignedRefundsRequest) GetPaymentHash() []byte {
	if x != nil {
		return x.PaymentHash
	}
	return nil
}

func (x *QueryUserSignedRefundsRequest) GetIdentityPublicKey() []byte {
	if x != nil {
		return x.IdentityPublicKey
	}
	return nil
}

type QueryUserSignedRefundsResponse struct {
	state             protoimpl.MessageState `protogen:"open.v1"`
	UserSignedRefunds []*UserSignedRefund    `protobuf:"bytes,1,rep,name=user_signed_refunds,json=userSignedRefunds,proto3" json:"user_signed_refunds,omitempty"`
	unknownFields     protoimpl.UnknownFields
	sizeCache         protoimpl.SizeCache
}

func (x *QueryUserSignedRefundsResponse) Reset() {
	*x = QueryUserSignedRefundsResponse{}
	mi := &file_spark_proto_msgTypes[102]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *QueryUserSignedRefundsResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*QueryUserSignedRefundsResponse) ProtoMessage() {}

func (x *QueryUserSignedRefundsResponse) ProtoReflect() protoreflect.Message {
	mi := &file_spark_proto_msgTypes[102]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use QueryUserSignedRefundsResponse.ProtoReflect.Descriptor instead.
func (*QueryUserSignedRefundsResponse) Descriptor() ([]byte, []int) {
	return file_spark_proto_rawDescGZIP(), []int{102}
}

func (x *QueryUserSignedRefundsResponse) GetUserSignedRefunds() []*UserSignedRefund {
	if x != nil {
		return x.UserSignedRefunds
	}
	return nil
}

type ProvidePreimageRequest struct {
	state             protoimpl.MessageState `protogen:"open.v1"`
	PaymentHash       []byte                 `protobuf:"bytes,1,opt,name=payment_hash,json=paymentHash,proto3" json:"payment_hash,omitempty"`
	Preimage          []byte                 `protobuf:"bytes,2,opt,name=preimage,proto3" json:"preimage,omitempty"`
	IdentityPublicKey []byte                 `protobuf:"bytes,3,opt,name=identity_public_key,json=identityPublicKey,proto3" json:"identity_public_key,omitempty"`
	unknownFields     protoimpl.UnknownFields
	sizeCache         protoimpl.SizeCache
}

func (x *ProvidePreimageRequest) Reset() {
	*x = ProvidePreimageRequest{}
	mi := &file_spark_proto_msgTypes[103]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ProvidePreimageRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ProvidePreimageRequest) ProtoMessage() {}

func (x *ProvidePreimageRequest) ProtoReflect() protoreflect.Message {
	mi := &file_spark_proto_msgTypes[103]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ProvidePreimageRequest.ProtoReflect.Descriptor instead.
func (*ProvidePreimageRequest) Descriptor() ([]byte, []int) {
	return file_spark_proto_rawDescGZIP(), []int{103}
}

func (x *ProvidePreimageRequest) GetPaymentHash() []byte {
	if x != nil {
		return x.PaymentHash
	}
	return nil
}

func (x *ProvidePreimageRequest) GetPreimage() []byte {
	if x != nil {
		return x.Preimage
	}
	return nil
}

func (x *ProvidePreimageRequest) GetIdentityPublicKey() []byte {
	if x != nil {
		return x.IdentityPublicKey
	}
	return nil
}

type ProvidePreimageResponse struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Transfer      *Transfer              `protobuf:"bytes,1,opt,name=transfer,proto3" json:"transfer,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *ProvidePreimageResponse) Reset() {
	*x = ProvidePreimageResponse{}
	mi := &file_spark_proto_msgTypes[104]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ProvidePreimageResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ProvidePreimageResponse) ProtoMessage() {}

func (x *ProvidePreimageResponse) ProtoReflect() protoreflect.Message {
	mi := &file_spark_proto_msgTypes[104]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ProvidePreimageResponse.ProtoReflect.Descriptor instead.
func (*ProvidePreimageResponse) Descriptor() ([]byte, []int) {
	return file_spark_proto_rawDescGZIP(), []int{104}
}

func (x *ProvidePreimageResponse) GetTransfer() *Transfer {
	if x != nil {
		return x.Transfer
	}
	return nil
}

type ReturnLightningPaymentRequest struct {
	state                 protoimpl.MessageState `protogen:"open.v1"`
	PaymentHash           []byte                 `protobuf:"bytes,1,opt,name=payment_hash,json=paymentHash,proto3" json:"payment_hash,omitempty"`
	UserIdentityPublicKey []byte                 `protobuf:"bytes,2,opt,name=user_identity_public_key,json=userIdentityPublicKey,proto3" json:"user_identity_public_key,omitempty"`
	unknownFields         protoimpl.UnknownFields
	sizeCache             protoimpl.SizeCache
}

func (x *ReturnLightningPaymentRequest) Reset() {
	*x = ReturnLightningPaymentRequest{}
	mi := &file_spark_proto_msgTypes[105]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ReturnLightningPaymentRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ReturnLightningPaymentRequest) ProtoMessage() {}

func (x *ReturnLightningPaymentRequest) ProtoReflect() protoreflect.Message {
	mi := &file_spark_proto_msgTypes[105]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ReturnLightningPaymentRequest.ProtoReflect.Descriptor instead.
func (*ReturnLightningPaymentRequest) Descriptor() ([]byte, []int) {
	return file_spark_proto_rawDescGZIP(), []int{105}
}

func (x *ReturnLightningPaymentRequest) GetPaymentHash() []byte {
	if x != nil {
		return x.PaymentHash
	}
	return nil
}

func (x *ReturnLightningPaymentRequest) GetUserIdentityPublicKey() []byte {
	if x != nil {
		return x.UserIdentityPublicKey
	}
	return nil
}

type TreeNodeIds struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	NodeIds       []string               `protobuf:"bytes,1,rep,name=node_ids,json=nodeIds,proto3" json:"node_ids,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *TreeNodeIds) Reset() {
	*x = TreeNodeIds{}
	mi := &file_spark_proto_msgTypes[106]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *TreeNodeIds) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*TreeNodeIds) ProtoMessage() {}

func (x *TreeNodeIds) ProtoReflect() protoreflect.Message {
	mi := &file_spark_proto_msgTypes[106]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use TreeNodeIds.ProtoReflect.Descriptor instead.
func (*TreeNodeIds) Descriptor() ([]byte, []int) {
	return file_spark_proto_rawDescGZIP(), []int{106}
}

func (x *TreeNodeIds) GetNodeIds() []string {
	if x != nil {
		return x.NodeIds
	}
	return nil
}

type QueryNodesRequest struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Types that are valid to be assigned to Source:
	//
	//	*QueryNodesRequest_OwnerIdentityPubkey
	//	*QueryNodesRequest_NodeIds
	Source         isQueryNodesRequest_Source `protobuf_oneof:"source"`
	IncludeParents bool                       `protobuf:"varint,3,opt,name=include_parents,json=includeParents,proto3" json:"include_parents,omitempty"`
	unknownFields  protoimpl.UnknownFields
	sizeCache      protoimpl.SizeCache
}

func (x *QueryNodesRequest) Reset() {
	*x = QueryNodesRequest{}
	mi := &file_spark_proto_msgTypes[107]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *QueryNodesRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*QueryNodesRequest) ProtoMessage() {}

func (x *QueryNodesRequest) ProtoReflect() protoreflect.Message {
	mi := &file_spark_proto_msgTypes[107]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use QueryNodesRequest.ProtoReflect.Descriptor instead.
func (*QueryNodesRequest) Descriptor() ([]byte, []int) {
	return file_spark_proto_rawDescGZIP(), []int{107}
}

func (x *QueryNodesRequest) GetSource() isQueryNodesRequest_Source {
	if x != nil {
		return x.Source
	}
	return nil
}

func (x *QueryNodesRequest) GetOwnerIdentityPubkey() []byte {
	if x != nil {
		if x, ok := x.Source.(*QueryNodesRequest_OwnerIdentityPubkey); ok {
			return x.OwnerIdentityPubkey
		}
	}
	return nil
}

func (x *QueryNodesRequest) GetNodeIds() *TreeNodeIds {
	if x != nil {
		if x, ok := x.Source.(*QueryNodesRequest_NodeIds); ok {
			return x.NodeIds
		}
	}
	return nil
}

func (x *QueryNodesRequest) GetIncludeParents() bool {
	if x != nil {
		return x.IncludeParents
	}
	return false
}

type isQueryNodesRequest_Source interface {
	isQueryNodesRequest_Source()
}

type QueryNodesRequest_OwnerIdentityPubkey struct {
	OwnerIdentityPubkey []byte `protobuf:"bytes,1,opt,name=owner_identity_pubkey,json=ownerIdentityPubkey,proto3,oneof"`
}

type QueryNodesRequest_NodeIds struct {
	NodeIds *TreeNodeIds `protobuf:"bytes,2,opt,name=node_ids,json=nodeIds,proto3,oneof"`
}

func (*QueryNodesRequest_OwnerIdentityPubkey) isQueryNodesRequest_Source() {}

func (*QueryNodesRequest_NodeIds) isQueryNodesRequest_Source() {}

type QueryNodesResponse struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Nodes         map[string]*TreeNode   `protobuf:"bytes,1,rep,name=nodes,proto3" json:"nodes,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *QueryNodesResponse) Reset() {
	*x = QueryNodesResponse{}
	mi := &file_spark_proto_msgTypes[108]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *QueryNodesResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*QueryNodesResponse) ProtoMessage() {}

func (x *QueryNodesResponse) ProtoReflect() protoreflect.Message {
	mi := &file_spark_proto_msgTypes[108]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use QueryNodesResponse.ProtoReflect.Descriptor instead.
func (*QueryNodesResponse) Descriptor() ([]byte, []int) {
	return file_spark_proto_rawDescGZIP(), []int{108}
}

func (x *QueryNodesResponse) GetNodes() map[string]*TreeNode {
	if x != nil {
		return x.Nodes
	}
	return nil
}

type CancelTransferRequest struct {
	state                   protoimpl.MessageState `protogen:"open.v1"`
	TransferId              string                 `protobuf:"bytes,1,opt,name=transfer_id,json=transferId,proto3" json:"transfer_id,omitempty"`
	SenderIdentityPublicKey []byte                 `protobuf:"bytes,2,opt,name=sender_identity_public_key,json=senderIdentityPublicKey,proto3" json:"sender_identity_public_key,omitempty"`
	unknownFields           protoimpl.UnknownFields
	sizeCache               protoimpl.SizeCache
}

func (x *CancelTransferRequest) Reset() {
	*x = CancelTransferRequest{}
	mi := &file_spark_proto_msgTypes[109]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *CancelTransferRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*CancelTransferRequest) ProtoMessage() {}

func (x *CancelTransferRequest) ProtoReflect() protoreflect.Message {
	mi := &file_spark_proto_msgTypes[109]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use CancelTransferRequest.ProtoReflect.Descriptor instead.
func (*CancelTransferRequest) Descriptor() ([]byte, []int) {
	return file_spark_proto_rawDescGZIP(), []int{109}
}

func (x *CancelTransferRequest) GetTransferId() string {
	if x != nil {
		return x.TransferId
	}
	return ""
}

func (x *CancelTransferRequest) GetSenderIdentityPublicKey() []byte {
	if x != nil {
		return x.SenderIdentityPublicKey
	}
	return nil
}

type CancelTransferResponse struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Transfer      *Transfer              `protobuf:"bytes,1,opt,name=transfer,proto3" json:"transfer,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *CancelTransferResponse) Reset() {
	*x = CancelTransferResponse{}
	mi := &file_spark_proto_msgTypes[110]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *CancelTransferResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*CancelTransferResponse) ProtoMessage() {}

func (x *CancelTransferResponse) ProtoReflect() protoreflect.Message {
	mi := &file_spark_proto_msgTypes[110]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use CancelTransferResponse.ProtoReflect.Descriptor instead.
func (*CancelTransferResponse) Descriptor() ([]byte, []int) {
	return file_spark_proto_rawDescGZIP(), []int{110}
}

func (x *CancelTransferResponse) GetTransfer() *Transfer {
	if x != nil {
		return x.Transfer
	}
	return nil
}

// *
// Returns a list of addresses that can be used in express deposit flow.
// Excludes static deposit addresses.
type QueryUnusedDepositAddressesRequest struct {
	state             protoimpl.MessageState `protogen:"open.v1"`
	IdentityPublicKey []byte                 `protobuf:"bytes,1,opt,name=identity_public_key,json=identityPublicKey,proto3" json:"identity_public_key,omitempty"`
	unknownFields     protoimpl.UnknownFields
	sizeCache         protoimpl.SizeCache
}

func (x *QueryUnusedDepositAddressesRequest) Reset() {
	*x = QueryUnusedDepositAddressesRequest{}
	mi := &file_spark_proto_msgTypes[111]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *QueryUnusedDepositAddressesRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*QueryUnusedDepositAddressesRequest) ProtoMessage() {}

func (x *QueryUnusedDepositAddressesRequest) ProtoReflect() protoreflect.Message {
	mi := &file_spark_proto_msgTypes[111]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use QueryUnusedDepositAddressesRequest.ProtoReflect.Descriptor instead.
func (*QueryUnusedDepositAddressesRequest) Descriptor() ([]byte, []int) {
	return file_spark_proto_rawDescGZIP(), []int{111}
}

func (x *QueryUnusedDepositAddressesRequest) GetIdentityPublicKey() []byte {
	if x != nil {
		return x.IdentityPublicKey
	}
	return nil
}

type DepositAddressQueryResult struct {
	state                protoimpl.MessageState `protogen:"open.v1"`
	DepositAddress       string                 `protobuf:"bytes,1,opt,name=deposit_address,json=depositAddress,proto3" json:"deposit_address,omitempty"`
	UserSigningPublicKey []byte                 `protobuf:"bytes,2,opt,name=user_signing_public_key,json=userSigningPublicKey,proto3" json:"user_signing_public_key,omitempty"`
	VerifyingPublicKey   []byte                 `protobuf:"bytes,3,opt,name=verifying_public_key,json=verifyingPublicKey,proto3" json:"verifying_public_key,omitempty"`
	LeafId               *string                `protobuf:"bytes,4,opt,name=leaf_id,json=leafId,proto3,oneof" json:"leaf_id,omitempty"`
	unknownFields        protoimpl.UnknownFields
	sizeCache            protoimpl.SizeCache
}

func (x *DepositAddressQueryResult) Reset() {
	*x = DepositAddressQueryResult{}
	mi := &file_spark_proto_msgTypes[112]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *DepositAddressQueryResult) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*DepositAddressQueryResult) ProtoMessage() {}

func (x *DepositAddressQueryResult) ProtoReflect() protoreflect.Message {
	mi := &file_spark_proto_msgTypes[112]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use DepositAddressQueryResult.ProtoReflect.Descriptor instead.
func (*DepositAddressQueryResult) Descriptor() ([]byte, []int) {
	return file_spark_proto_rawDescGZIP(), []int{112}
}

func (x *DepositAddressQueryResult) GetDepositAddress() string {
	if x != nil {
		return x.DepositAddress
	}
	return ""
}

func (x *DepositAddressQueryResult) GetUserSigningPublicKey() []byte {
	if x != nil {
		return x.UserSigningPublicKey
	}
	return nil
}

func (x *DepositAddressQueryResult) GetVerifyingPublicKey() []byte {
	if x != nil {
		return x.VerifyingPublicKey
	}
	return nil
}

func (x *DepositAddressQueryResult) GetLeafId() string {
	if x != nil && x.LeafId != nil {
		return *x.LeafId
	}
	return ""
}

type QueryUnusedDepositAddressesResponse struct {
	state            protoimpl.MessageState       `protogen:"open.v1"`
	DepositAddresses []*DepositAddressQueryResult `protobuf:"bytes,1,rep,name=deposit_addresses,json=depositAddresses,proto3" json:"deposit_addresses,omitempty"`
	unknownFields    protoimpl.UnknownFields
	sizeCache        protoimpl.SizeCache
}

func (x *QueryUnusedDepositAddressesResponse) Reset() {
	*x = QueryUnusedDepositAddressesResponse{}
	mi := &file_spark_proto_msgTypes[113]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *QueryUnusedDepositAddressesResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*QueryUnusedDepositAddressesResponse) ProtoMessage() {}

func (x *QueryUnusedDepositAddressesResponse) ProtoReflect() protoreflect.Message {
	mi := &file_spark_proto_msgTypes[113]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use QueryUnusedDepositAddressesResponse.ProtoReflect.Descriptor instead.
func (*QueryUnusedDepositAddressesResponse) Descriptor() ([]byte, []int) {
	return file_spark_proto_rawDescGZIP(), []int{113}
}

func (x *QueryUnusedDepositAddressesResponse) GetDepositAddresses() []*DepositAddressQueryResult {
	if x != nil {
		return x.DepositAddresses
	}
	return nil
}

type QueryBalanceRequest struct {
	state             protoimpl.MessageState `protogen:"open.v1"`
	IdentityPublicKey []byte                 `protobuf:"bytes,1,opt,name=identity_public_key,json=identityPublicKey,proto3" json:"identity_public_key,omitempty"`
	unknownFields     protoimpl.UnknownFields
	sizeCache         protoimpl.SizeCache
}

func (x *QueryBalanceRequest) Reset() {
	*x = QueryBalanceRequest{}
	mi := &file_spark_proto_msgTypes[114]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *QueryBalanceRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*QueryBalanceRequest) ProtoMessage() {}

func (x *QueryBalanceRequest) ProtoReflect() protoreflect.Message {
	mi := &file_spark_proto_msgTypes[114]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use QueryBalanceRequest.ProtoReflect.Descriptor instead.
func (*QueryBalanceRequest) Descriptor() ([]byte, []int) {
	return file_spark_proto_rawDescGZIP(), []int{114}
}

func (x *QueryBalanceRequest) GetIdentityPublicKey() []byte {
	if x != nil {
		return x.IdentityPublicKey
	}
	return nil
}

type QueryBalanceResponse struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Balance       uint64                 `protobuf:"varint,1,opt,name=balance,proto3" json:"balance,omitempty"`
	NodeBalances  map[string]uint64      `protobuf:"bytes,2,rep,name=node_balances,json=nodeBalances,proto3" json:"node_balances,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"varint,2,opt,name=value"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *QueryBalanceResponse) Reset() {
	*x = QueryBalanceResponse{}
	mi := &file_spark_proto_msgTypes[115]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *QueryBalanceResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*QueryBalanceResponse) ProtoMessage() {}

func (x *QueryBalanceResponse) ProtoReflect() protoreflect.Message {
	mi := &file_spark_proto_msgTypes[115]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use QueryBalanceResponse.ProtoReflect.Descriptor instead.
func (*QueryBalanceResponse) Descriptor() ([]byte, []int) {
	return file_spark_proto_rawDescGZIP(), []int{115}
}

func (x *QueryBalanceResponse) GetBalance() uint64 {
	if x != nil {
		return x.Balance
	}
	return 0
}

func (x *QueryBalanceResponse) GetNodeBalances() map[string]uint64 {
	if x != nil {
		return x.NodeBalances
	}
	return nil
}

type SparkAddress struct {
	state             protoimpl.MessageState `protogen:"open.v1"`
	IdentityPublicKey []byte                 `protobuf:"bytes,1,opt,name=identity_public_key,json=identityPublicKey,proto3" json:"identity_public_key,omitempty"`
	unknownFields     protoimpl.UnknownFields
	sizeCache         protoimpl.SizeCache
}

func (x *SparkAddress) Reset() {
	*x = SparkAddress{}
	mi := &file_spark_proto_msgTypes[116]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *SparkAddress) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*SparkAddress) ProtoMessage() {}

func (x *SparkAddress) ProtoReflect() protoreflect.Message {
	mi := &file_spark_proto_msgTypes[116]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use SparkAddress.ProtoReflect.Descriptor instead.
func (*SparkAddress) Descriptor() ([]byte, []int) {
	return file_spark_proto_rawDescGZIP(), []int{116}
}

func (x *SparkAddress) GetIdentityPublicKey() []byte {
	if x != nil {
		return x.IdentityPublicKey
	}
	return nil
}

var File_spark_proto protoreflect.FileDescriptor

const file_spark_proto_rawDesc = "" +
	"\n" +
	"\vspark.proto\x12\x05spark\x1a\x1fgoogle/protobuf/timestamp.proto\x1a\x1bgoogle/protobuf/empty.proto\x1a\x17validate/validate.proto\x1a\fcommon.proto\"J\n" +
	"\x18SubscribeToEventsRequest\x12.\n" +
	"\x13identity_public_key\x18\n" +
	" \x01(\fR\x11identityPublicKey\"\xc0\x01\n" +
	"\x19SubscribeToEventsResponse\x122\n" +
	"\btransfer\x18\x01 \x01(\v2\x14.spark.TransferEventH\x00R\btransfer\x12/\n" +
	"\adeposit\x18\x02 \x01(\v2\x13.spark.DepositEventH\x00R\adeposit\x125\n" +
	"\tconnected\x18\x03 \x01(\v2\x15.spark.ConnectedEventH\x00R\tconnectedB\a\n" +
	"\x05event\"\x10\n" +
	"\x0eConnectedEvent\"<\n" +
	"\rTransferEvent\x12+\n" +
	"\btransfer\x18\n" +
	" \x01(\v2\x0f.spark.TransferR\btransfer\"9\n" +
	"\fDepositEvent\x12)\n" +
	"\adeposit\x18\n" +
	" \x01(\v2\x0f.spark.TreeNodeR\adeposit\"\x80\x02\n" +
	"\x13DepositAddressProof\x12`\n" +
	"\x12address_signatures\x18\x01 \x03(\v21.spark.DepositAddressProof.AddressSignaturesEntryR\x11addressSignatures\x12A\n" +
	"\x1dproof_of_possession_signature\x18\x02 \x01(\fR\x1aproofOfPossessionSignature\x1aD\n" +
	"\x16AddressSignaturesEntry\x12\x10\n" +
	"\x03key\x18\x01 \x01(\tR\x03key\x12\x14\n" +
	"\x05value\x18\x02 \x01(\fR\x05value:\x028\x01\"\x95\x02\n" +
	"\x1dGenerateDepositAddressRequest\x12,\n" +
	"\x12signing_public_key\x18\x01 \x01(\fR\x10signingPublicKey\x12.\n" +
	"\x13identity_public_key\x18\x02 \x01(\fR\x11identityPublicKey\x122\n" +
	"\anetwork\x18\x03 \x01(\x0e2\x0e.spark.NetworkB\b\xfaB\x05\x82\x01\x02 \x00R\anetwork\x12&\n" +
	"\aleaf_id\x18\x04 \x01(\tB\b\xfaB\x05r\x03\xb0\x01\x01H\x00R\x06leafId\x88\x01\x01\x12 \n" +
	"\tis_static\x18\x05 \x01(\bH\x01R\bisStatic\x88\x01\x01B\n" +
	"\n" +
	"\b_leaf_idB\f\n" +
	"\n" +
	"_is_static\"\xb5\x01\n" +
	"\aAddress\x12\x18\n" +
	"\aaddress\x18\x01 \x01(\tR\aaddress\x12#\n" +
	"\rverifying_key\x18\x02 \x01(\fR\fverifyingKey\x12N\n" +
	"\x15deposit_address_proof\x18\x03 \x01(\v2\x1a.spark.DepositAddressProofR\x13depositAddressProof\x12\x1b\n" +
	"\tis_static\x18\x05 \x01(\bR\bisStatic\"Y\n" +
	"\x1eGenerateDepositAddressResponse\x127\n" +
	"\x0fdeposit_address\x18\x01 \x01(\v2\x0e.spark.AddressR\x0edepositAddress\"e\n" +
	"\x04UTXO\x12\x15\n" +
	"\x06raw_tx\x18\x01 \x01(\fR\x05rawTx\x12\x12\n" +
	"\x04vout\x18\x02 \x01(\rR\x04vout\x122\n" +
	"\anetwork\x18\x03 \x01(\x0e2\x0e.spark.NetworkB\b\xfaB\x05\x82\x01\x02 \x00R\anetwork\"9\n" +
	"\n" +
	"NodeOutput\x12\x17\n" +
	"\anode_id\x18\x01 \x01(\tR\x06nodeId\x12\x12\n" +
	"\x04vout\x18\x02 \x01(\rR\x04vout\"\xa6\x01\n" +
	"\n" +
	"SigningJob\x12,\n" +
	"\x12signing_public_key\x18\x01 \x01(\fR\x10signingPublicKey\x12\x15\n" +
	"\x06raw_tx\x18\x02 \x01(\fR\x05rawTx\x12S\n" +
	"\x18signing_nonce_commitment\x18\x03 \x01(\v2\x19.common.SigningCommitmentR\x16signingNonceCommitment\"\\\n" +
	"\x0fSigningKeyshare\x12+\n" +
	"\x11owner_identifiers\x18\x01 \x03(\tR\x10ownerIdentifiers\x12\x1c\n" +
	"\tthreshold\x18\x02 \x01(\rR\tthreshold\"\xc8\x04\n" +
	"\rSigningResult\x12E\n" +
	"\vpublic_keys\x18\x01 \x03(\v2$.spark.SigningResult.PublicKeysEntryR\n" +
	"publicKeys\x12m\n" +
	"\x19signing_nonce_commitments\x18\x02 \x03(\v21.spark.SigningResult.SigningNonceCommitmentsEntryR\x17signingNonceCommitments\x12T\n" +
	"\x10signature_shares\x18\x03 \x03(\v2).spark.SigningResult.SignatureSharesEntryR\x0fsignatureShares\x12A\n" +
	"\x10signing_keyshare\x18\x04 \x01(\v2\x16.spark.SigningKeyshareR\x0fsigningKeyshare\x1a=\n" +
	"\x0fPublicKeysEntry\x12\x10\n" +
	"\x03key\x18\x01 \x01(\tR\x03key\x12\x14\n" +
	"\x05value\x18\x02 \x01(\fR\x05value:\x028\x01\x1ae\n" +
	"\x1cSigningNonceCommitmentsEntry\x12\x10\n" +
	"\x03key\x18\x01 \x01(\tR\x03key\x12/\n" +
	"\x05value\x18\x02 \x01(\v2\x19.common.SigningCommitmentR\x05value:\x028\x01\x1aB\n" +
	"\x14SignatureSharesEntry\x12\x10\n" +
	"\x03key\x18\x01 \x01(\tR\x03key\x12\x14\n" +
	"\x05value\x18\x02 \x01(\fR\x05value:\x028\x01\"\xed\x01\n" +
	"\x13NodeSignatureShares\x12\x17\n" +
	"\anode_id\x18\x01 \x01(\tR\x06nodeId\x12I\n" +
	"\x16node_tx_signing_result\x18\x02 \x01(\v2\x14.spark.SigningResultR\x13nodeTxSigningResult\x12M\n" +
	"\x18refund_tx_signing_result\x18\x03 \x01(\v2\x14.spark.SigningResultR\x15refundTxSigningResult\x12#\n" +
	"\rverifying_key\x18\x04 \x01(\fR\fverifyingKey\"\x85\x01\n" +
	"\x0eNodeSignatures\x12\x17\n" +
	"\anode_id\x18\x01 \x01(\tR\x06nodeId\x12*\n" +
	"\x11node_tx_signature\x18\x02 \x01(\fR\x0fnodeTxSignature\x12.\n" +
	"\x13refund_tx_signature\x18\x03 \x01(\fR\x11refundTxSignature\"\x83\x02\n" +
	"\x18StartTreeCreationRequest\x12.\n" +
	"\x13identity_public_key\x18\x01 \x01(\fR\x11identityPublicKey\x12/\n" +
	"\ron_chain_utxo\x18\x02 \x01(\v2\v.spark.UTXOR\vonChainUtxo\x12@\n" +
	"\x13root_tx_signing_job\x18\x03 \x01(\v2\x11.spark.SigningJobR\x10rootTxSigningJob\x12D\n" +
	"\x15refund_tx_signing_job\x18\x04 \x01(\v2\x11.spark.SigningJobR\x12refundTxSigningJob\"\x8d\x01\n" +
	"\x19StartTreeCreationResponse\x12\x17\n" +
	"\atree_id\x18\x01 \x01(\tR\x06treeId\x12W\n" +
	"\x1aroot_node_signature_shares\x18\x02 \x01(\v2\x1a.spark.NodeSignatureSharesR\x17rootNodeSignatureShares\"\x8a\x02\n" +
	"\x1fStartDepositTreeCreationRequest\x12.\n" +
	"\x13identity_public_key\x18\x01 \x01(\fR\x11identityPublicKey\x12/\n" +
	"\ron_chain_utxo\x18\x02 \x01(\v2\v.spark.UTXOR\vonChainUtxo\x12@\n" +
	"\x13root_tx_signing_job\x18\x03 \x01(\v2\x11.spark.SigningJobR\x10rootTxSigningJob\x12D\n" +
	"\x15refund_tx_signing_job\x18\x04 \x01(\v2\x11.spark.SigningJobR\x12refundTxSigningJob\"\x94\x01\n" +
	" StartDepositTreeCreationResponse\x12\x17\n" +
	"\atree_id\x18\x01 \x01(\tR\x06treeId\x12W\n" +
	"\x1aroot_node_signature_shares\x18\x02 \x01(\v2\x1a.spark.NodeSignatureSharesR\x17rootNodeSignatureShares\"\x9b\x01\n" +
	"\x12TokenOutputToSpend\x12F\n" +
	"\x1bprev_token_transaction_hash\x18\x01 \x01(\fB\a\xfaB\x04z\x02h R\x18prevTokenTransactionHash\x12=\n" +
	"\x1bprev_token_transaction_vout\x18\x02 \x01(\rR\x18prevTokenTransactionVout\"Y\n" +
	"\x12TokenTransferInput\x12C\n" +
	"\x10outputs_to_spend\x18\x01 \x03(\v2\x19.spark.TokenOutputToSpendR\x0eoutputsToSpend\"\x81\x01\n" +
	"\x0eTokenMintInput\x123\n" +
	"\x11issuer_public_key\x18\x01 \x01(\fB\a\xfaB\x04z\x02h!R\x0fissuerPublicKey\x12:\n" +
	"\x19issuer_provided_timestamp\x18\x02 \x01(\x04R\x17issuerProvidedTimestamp\"\xdf\x03\n" +
	"\vTokenOutput\x12\x1d\n" +
	"\x02id\x18\x01 \x01(\tB\b\xfaB\x05r\x03\xb0\x01\x01H\x00R\x02id\x88\x01\x01\x121\n" +
	"\x10owner_public_key\x18\x02 \x01(\fB\a\xfaB\x04z\x02h!R\x0eownerPublicKey\x12A\n" +
	"\x15revocation_commitment\x18\x03 \x01(\fB\a\xfaB\x04z\x02h!H\x01R\x14revocationCommitment\x88\x01\x01\x121\n" +
	"\x12withdraw_bond_sats\x18\x04 \x01(\x04H\x02R\x10withdrawBondSats\x88\x01\x01\x12L\n" +
	" withdraw_relative_block_locktime\x18\x05 \x01(\x04H\x03R\x1dwithdrawRelativeBlockLocktime\x88\x01\x01\x121\n" +
	"\x10token_public_key\x18\x06 \x01(\fB\a\xfaB\x04z\x02h!R\x0etokenPublicKey\x12*\n" +
	"\ftoken_amount\x18\a \x01(\fB\a\xfaB\x04z\x02h\x10R\vtokenAmountB\x05\n" +
	"\x03_idB\x18\n" +
	"\x16_revocation_commitmentB\x15\n" +
	"\x13_withdraw_bond_satsB#\n" +
	"!_withdraw_relative_block_locktime\"\xe7\x02\n" +
	"\x10TokenTransaction\x126\n" +
	"\n" +
	"mint_input\x18\x01 \x01(\v2\x15.spark.TokenMintInputH\x00R\tmintInput\x12B\n" +
	"\x0etransfer_input\x18\x02 \x01(\v2\x19.spark.TokenTransferInputH\x00R\rtransferInput\x127\n" +
	"\rtoken_outputs\x18\x03 \x03(\v2\x12.spark.TokenOutputR\ftokenOutputs\x12Z\n" +
	"#spark_operator_identity_public_keys\x18\x04 \x03(\fB\f\xfaB\t\x92\x01\x06\"\x04z\x02h!R\x1fsparkOperatorIdentityPublicKeys\x122\n" +
	"\anetwork\x18\n" +
	" \x01(\x0e2\x0e.spark.NetworkB\b\xfaB\x05\x82\x01\x02 \x00R\anetworkB\x0e\n" +
	"\ftoken_inputs\"\x99\x01\n" +
	"\x1aTokenTransactionWithStatus\x12D\n" +
	"\x11token_transaction\x18\x01 \x01(\v2\x17.spark.TokenTransactionR\x10tokenTransaction\x125\n" +
	"\x06status\x18\x02 \x01(\x0e2\x1d.spark.TokenTransactionStatusR\x06status\"^\n" +
	"\x12SignatureWithIndex\x12'\n" +
	"\tsignature\x18\x01 \x01(\fB\t\xfaB\x06z\x04\x10@\x18IR\tsignature\x12\x1f\n" +
	"\vinput_index\x18\x02 \x01(\rR\n" +
	"inputIndex\"b\n" +
	"\x1aTokenTransactionSignatures\x12D\n" +
	"\x10owner_signatures\x18\x01 \x03(\v2\x19.spark.SignatureWithIndexR\x0fownerSignatures\"\x91\x02\n" +
	"\x1cStartTokenTransactionRequest\x127\n" +
	"\x13identity_public_key\x18\x01 \x01(\fB\a\xfaB\x04z\x02h!R\x11identityPublicKey\x12S\n" +
	"\x19partial_token_transaction\x18\x02 \x01(\v2\x17.spark.TokenTransactionR\x17partialTokenTransaction\x12c\n" +
	"\x1ctoken_transaction_signatures\x18\x03 \x01(\v2!.spark.TokenTransactionSignaturesR\x1atokenTransactionSignatures\"\xad\x01\n" +
	"\x1dStartTokenTransactionResponse\x12O\n" +
	"\x17final_token_transaction\x18\x01 \x01(\v2\x17.spark.TokenTransactionR\x15finalTokenTransaction\x12;\n" +
	"\rkeyshare_info\x18\x02 \x01(\v2\x16.spark.SigningKeyshareR\fkeyshareInfo\"\xc5\x01\n" +
	"/OperatorSpecificTokenTransactionSignablePayload\x12H\n" +
	"\x1cfinal_token_transaction_hash\x18\x01 \x01(\fB\a\xfaB\x04z\x02h R\x19finalTokenTransactionHash\x12H\n" +
	"\x1coperator_identity_public_key\x18\x02 \x01(\fB\a\xfaB\x04z\x02h!R\x19operatorIdentityPublicKey\"\xb6\x01\n" +
	"\x1eOperatorSpecificOwnerSignature\x12B\n" +
	"\x0fowner_signature\x18\x01 \x01(\v2\x19.spark.SignatureWithIndexR\x0eownerSignature\x12P\n" +
	"\apayload\x18\x02 \x01(\v26.spark.OperatorSpecificTokenTransactionSignablePayloadR\apayload\"\x90\x02\n" +
	"\x1bSignTokenTransactionRequest\x12O\n" +
	"\x17final_token_transaction\x18\x01 \x01(\v2\x17.spark.TokenTransactionR\x15finalTokenTransaction\x12g\n" +
	"\x1coperator_specific_signatures\x18\x02 \x03(\v2%.spark.OperatorSpecificOwnerSignatureR\x1aoperatorSpecificSignatures\x127\n" +
	"\x13identity_public_key\x18\x03 \x01(\fB\a\xfaB\x04z\x02h!R\x11identityPublicKey\"Y\n" +
	"\x11KeyshareWithIndex\x12\x1f\n" +
	"\vinput_index\x18\x01 \x01(\rR\n" +
	"inputIndex\x12#\n" +
	"\bkeyshare\x18\x02 \x01(\fB\a\xfaB\x04z\x02h R\bkeyshare\"\xb0\x01\n" +
	"\x1cSignTokenTransactionResponse\x12C\n" +
	"\x18spark_operator_signature\x18\x01 \x01(\fB\t\xfaB\x06z\x04\x10@\x18IR\x16sparkOperatorSignature\x12K\n" +
	"\x14revocation_keyshares\x18\x02 \x03(\v2\x18.spark.KeyshareWithIndexR\x13revocationKeyshares\"r\n" +
	"\x19RevocationSecretWithIndex\x12\x1f\n" +
	"\vinput_index\x18\x01 \x01(\rR\n" +
	"inputIndex\x124\n" +
	"\x11revocation_secret\x18\x02 \x01(\fB\a\xfaB\x04z\x02h R\x10revocationSecret\"\xfc\x01\n" +
	"\x1fFinalizeTokenTransactionRequest\x12O\n" +
	"\x17final_token_transaction\x18\x01 \x01(\v2\x17.spark.TokenTransactionR\x15finalTokenTransaction\x12O\n" +
	"\x12revocation_secrets\x18\x02 \x03(\v2 .spark.RevocationSecretWithIndexR\x11revocationSecrets\x127\n" +
	"\x13identity_public_key\x18\x03 \x01(\fB\a\xfaB\x04z\x02h!R\x11identityPublicKey\"\xaa\x02\n" +
	"\x13FreezeTokensPayload\x121\n" +
	"\x10owner_public_key\x18\x01 \x01(\fB\a\xfaB\x04z\x02h!R\x0eownerPublicKey\x121\n" +
	"\x10token_public_key\x18\x02 \x01(\fB\a\xfaB\x04z\x02h!R\x0etokenPublicKey\x12:\n" +
	"\x19issuer_provided_timestamp\x18\x03 \x01(\x04R\x17issuerProvidedTimestamp\x12H\n" +
	"\x1coperator_identity_public_key\x18\x04 \x01(\fB\a\xfaB\x04z\x02h!R\x19operatorIdentityPublicKey\x12'\n" +
	"\x0fshould_unfreeze\x18\x05 \x01(\bR\x0eshouldUnfreeze\"\x9b\x01\n" +
	"\x13FreezeTokensRequest\x12N\n" +
	"\x15freeze_tokens_payload\x18\x01 \x01(\v2\x1a.spark.FreezeTokensPayloadR\x13freezeTokensPayload\x124\n" +
	"\x10issuer_signature\x18\x02 \x01(\fB\t\xfaB\x06z\x04\x10@\x18IR\x0fissuerSignature\"\x89\x01\n" +
	"\x14FreezeTokensResponse\x12=\n" +
	"\x13impacted_output_ids\x18\x01 \x03(\tB\r\xfaB\n" +
	"\x92\x01\a\"\x05r\x03\xb0\x01\x01R\x11impactedOutputIds\x122\n" +
	"\x15impacted_token_amount\x18\x02 \x01(\fR\x13impactedTokenAmount\"\x8e\x01\n" +
	"\x18QueryTokenOutputsRequest\x128\n" +
	"\x11owner_public_keys\x18\x01 \x03(\fB\f\xfaB\t\x92\x01\x06\"\x04z\x02h!R\x0fownerPublicKeys\x128\n" +
	"\x11token_public_keys\x18\x02 \x03(\fB\f\xfaB\t\x92\x01\x06\"\x04z\x02h!R\x0ftokenPublicKeys\"\xb7\x02\n" +
	"\x1dQueryTokenTransactionsRequest\x12,\n" +
	"\n" +
	"output_ids\x18\x01 \x03(\tB\r\xfaB\n" +
	"\x92\x01\a\"\x05r\x03\xb0\x01\x01R\toutputIds\x128\n" +
	"\x11owner_public_keys\x18\x02 \x03(\fB\f\xfaB\t\x92\x01\x06\"\x04z\x02h!R\x0fownerPublicKeys\x128\n" +
	"\x11token_public_keys\x18\x03 \x03(\fB\f\xfaB\t\x92\x01\x06\"\x04z\x02h!R\x0ftokenPublicKeys\x12F\n" +
	"\x18token_transaction_hashes\x18\x04 \x03(\fB\f\xfaB\t\x92\x01\x06\"\x04z\x02h R\x16tokenTransactionHashes\x12\x14\n" +
	"\x05limit\x18\x05 \x01(\x03R\x05limit\x12\x16\n" +
	"\x06offset\x18\x06 \x01(\x03R\x06offset\"\xa0\x01\n" +
	"\x1eQueryTokenTransactionsResponse\x12f\n" +
	"\x1etoken_transactions_with_status\x18\x01 \x03(\v2!.spark.TokenTransactionWithStatusR\x1btokenTransactionsWithStatus\x12\x16\n" +
	"\x06offset\x18\x02 \x01(\x03R\x06offset\"\xd0\x01\n" +
	"!OutputWithPreviousTransactionData\x12*\n" +
	"\x06output\x18\x01 \x01(\v2\x12.spark.TokenOutputR\x06output\x12C\n" +
	"\x19previous_transaction_hash\x18\x02 \x01(\fB\a\xfaB\x04z\x02h R\x17previousTransactionHash\x12:\n" +
	"\x19previous_transaction_vout\x18\x03 \x01(\rR\x17previousTransactionVout\"\x99\x01\n" +
	"\x19QueryTokenOutputsResponse\x12|\n" +
	"&outputs_with_previous_transaction_data\x18\x01 \x03(\v2(.spark.OutputWithPreviousTransactionDataR\"outputsWithPreviousTransactionData\"\xbc\x01\n" +
	"#CancelSignedTokenTransactionRequest\x12O\n" +
	"\x17final_token_transaction\x18\x01 \x01(\v2\x17.spark.TokenTransactionR\x15finalTokenTransaction\x12D\n" +
	"\x1asender_identity_public_key\x18\x02 \x01(\fB\a\xfaB\x04z\x02h!R\x17senderIdentityPublicKey\"\xc3\x03\n" +
	"\bTreeNode\x12\x0e\n" +
	"\x02id\x18\x01 \x01(\tR\x02id\x12\x17\n" +
	"\atree_id\x18\x02 \x01(\tR\x06treeId\x12\x14\n" +
	"\x05value\x18\x03 \x01(\x04R\x05value\x12)\n" +
	"\x0eparent_node_id\x18\x04 \x01(\tH\x00R\fparentNodeId\x88\x01\x01\x12\x17\n" +
	"\anode_tx\x18\x05 \x01(\fR\x06nodeTx\x12\x1b\n" +
	"\trefund_tx\x18\x06 \x01(\fR\brefundTx\x12\x12\n" +
	"\x04vout\x18\a \x01(\rR\x04vout\x120\n" +
	"\x14verifying_public_key\x18\b \x01(\fR\x12verifyingPublicKey\x129\n" +
	"\x19owner_identity_public_key\x18\t \x01(\fR\x16ownerIdentityPublicKey\x12A\n" +
	"\x10signing_keyshare\x18\n" +
	" \x01(\v2\x16.spark.SigningKeyshareR\x0fsigningKeyshare\x12\x16\n" +
	"\x06status\x18\v \x01(\tR\x06status\x12(\n" +
	"\anetwork\x18\f \x01(\x0e2\x0e.spark.NetworkR\anetworkB\x11\n" +
	"\x0f_parent_node_id\"\x90\x01\n" +
	"\x1dFinalizeNodeSignaturesRequest\x12/\n" +
	"\x06intent\x18\x01 \x01(\x0e2\x17.common.SignatureIntentR\x06intent\x12>\n" +
	"\x0fnode_signatures\x18\x02 \x03(\v2\x15.spark.NodeSignaturesR\x0enodeSignatures\"G\n" +
	"\x1eFinalizeNodeSignaturesResponse\x12%\n" +
	"\x05nodes\x18\x01 \x03(\v2\x0f.spark.TreeNodeR\x05nodes\"H\n" +
	"\vSecretShare\x12!\n" +
	"\fsecret_share\x18\x01 \x01(\fR\vsecretShare\x12\x16\n" +
	"\x06proofs\x18\x02 \x03(\fR\x06proofs\"%\n" +
	"\vSecretProof\x12\x16\n" +
	"\x06proofs\x18\x01 \x03(\fR\x06proofs\"w\n" +
	"\x16LeafRefundTxSigningJob\x12\x17\n" +
	"\aleaf_id\x18\x01 \x01(\tR\x06leafId\x12D\n" +
	"\x15refund_tx_signing_job\x18\x02 \x01(\v2\x11.spark.SigningJobR\x12refundTxSigningJob\"\xbe\x02\n" +
	"\x16UserSignedTxSigningJob\x12\x17\n" +
	"\aleaf_id\x18\x01 \x01(\tR\x06leafId\x12,\n" +
	"\x12signing_public_key\x18\x02 \x01(\fR\x10signingPublicKey\x12\x15\n" +
	"\x06raw_tx\x18\x03 \x01(\fR\x05rawTx\x12S\n" +
	"\x18signing_nonce_commitment\x18\x04 \x01(\v2\x19.common.SigningCommitmentR\x16signingNonceCommitment\x12%\n" +
	"\x0euser_signature\x18\x05 \x01(\fR\ruserSignature\x12J\n" +
	"\x13signing_commitments\x18\x06 \x01(\v2\x19.spark.SigningCommitmentsR\x12signingCommitments\"\xa8\x01\n" +
	"\x19LeafRefundTxSigningResult\x12\x17\n" +
	"\aleaf_id\x18\x01 \x01(\tR\x06leafId\x12M\n" +
	"\x18refund_tx_signing_result\x18\x02 \x01(\v2\x14.spark.SigningResultR\x15refundTxSigningResult\x12#\n" +
	"\rverifying_key\x18\x03 \x01(\fR\fverifyingKey\"\xbf\x02\n" +
	"\x1eStartUserSignedTransferRequest\x12\x1f\n" +
	"\vtransfer_id\x18\x01 \x01(\tR\n" +
	"transferId\x129\n" +
	"\x19owner_identity_public_key\x18\x02 \x01(\fR\x16ownerIdentityPublicKey\x12C\n" +
	"\x0eleaves_to_send\x18\x03 \x03(\v2\x1d.spark.UserSignedTxSigningJobR\fleavesToSend\x12?\n" +
	"\x1creceiver_identity_public_key\x18\x04 \x01(\fR\x19receiverIdentityPublicKey\x12;\n" +
	"\vexpiry_time\x18\x05 \x01(\v2\x1a.google.protobuf.TimestampR\n" +
	"expiryTime\"\xe7\x03\n" +
	"\x14StartTransferRequest\x12\x1f\n" +
	"\vtransfer_id\x18\x01 \x01(\tR\n" +
	"transferId\x129\n" +
	"\x19owner_identity_public_key\x18\x02 \x01(\fR\x16ownerIdentityPublicKey\x12C\n" +
	"\x0eleaves_to_send\x18\x03 \x03(\v2\x1d.spark.LeafRefundTxSigningJobR\fleavesToSend\x12?\n" +
	"\x1creceiver_identity_public_key\x18\x04 \x01(\fR\x19receiverIdentityPublicKey\x12;\n" +
	"\vexpiry_time\x18\x05 \x01(\v2\x1a.google.protobuf.TimestampR\n" +
	"expiryTime\x12Y\n" +
	"\x10key_tweak_proofs\x18\x06 \x03(\v2/.spark.StartTransferRequest.KeyTweakProofsEntryR\x0ekeyTweakProofs\x1aU\n" +
	"\x13KeyTweakProofsEntry\x12\x10\n" +
	"\x03key\x18\x01 \x01(\tR\x03key\x12(\n" +
	"\x05value\x18\x02 \x01(\v2\x12.spark.SecretProofR\x05value:\x028\x01\"\x8f\x01\n" +
	"\x15StartTransferResponse\x12+\n" +
	"\btransfer\x18\x01 \x01(\v2\x0f.spark.TransferR\btransfer\x12I\n" +
	"\x0fsigning_results\x18\x02 \x03(\v2 .spark.LeafRefundTxSigningResultR\x0esigningResults\"\x81\x03\n" +
	"\x10SendLeafKeyTweak\x12\x17\n" +
	"\aleaf_id\x18\x01 \x01(\tR\x06leafId\x12@\n" +
	"\x12secret_share_tweak\x18\x02 \x01(\v2\x12.spark.SecretShareR\x10secretShareTweak\x12^\n" +
	"\x13pubkey_shares_tweak\x18\x03 \x03(\v2..spark.SendLeafKeyTweak.PubkeySharesTweakEntryR\x11pubkeySharesTweak\x12#\n" +
	"\rsecret_cipher\x18\x04 \x01(\fR\fsecretCipher\x12\x1c\n" +
	"\tsignature\x18\x05 \x01(\fR\tsignature\x12)\n" +
	"\x10refund_signature\x18\x06 \x01(\fR\x0frefundSignature\x1aD\n" +
	"\x16PubkeySharesTweakEntry\x12\x10\n" +
	"\x03key\x18\x01 \x01(\tR\x03key\x12\x14\n" +
	"\x05value\x18\x02 \x01(\fR\x05value:\x028\x01\"\xb4\x01\n" +
	"\x17FinalizeTransferRequest\x12\x1f\n" +
	"\vtransfer_id\x18\x01 \x01(\tR\n" +
	"transferId\x129\n" +
	"\x19owner_identity_public_key\x18\x02 \x01(\fR\x16ownerIdentityPublicKey\x12=\n" +
	"\x0eleaves_to_send\x18\x03 \x03(\v2\x17.spark.SendLeafKeyTweakR\fleavesToSend\"G\n" +
	"\x18FinalizeTransferResponse\x12+\n" +
	"\btransfer\x18\x01 \x01(\v2\x0f.spark.TransferR\btransfer\"\xf9\x03\n" +
	"\bTransfer\x12\x0e\n" +
	"\x02id\x18\x01 \x01(\tR\x02id\x12;\n" +
	"\x1asender_identity_public_key\x18\x02 \x01(\fR\x17senderIdentityPublicKey\x12?\n" +
	"\x1creceiver_identity_public_key\x18\x03 \x01(\fR\x19receiverIdentityPublicKey\x12-\n" +
	"\x06status\x18\x04 \x01(\x0e2\x15.spark.TransferStatusR\x06status\x12\x1f\n" +
	"\vtotal_value\x18\x05 \x01(\x04R\n" +
	"totalValue\x12;\n" +
	"\vexpiry_time\x18\x06 \x01(\v2\x1a.google.protobuf.TimestampR\n" +
	"expiryTime\x12+\n" +
	"\x06leaves\x18\a \x03(\v2\x13.spark.TransferLeafR\x06leaves\x12=\n" +
	"\fcreated_time\x18\b \x01(\v2\x1a.google.protobuf.TimestampR\vcreatedTime\x12=\n" +
	"\fupdated_time\x18\t \x01(\v2\x1a.google.protobuf.TimestampR\vupdatedTime\x12'\n" +
	"\x04type\x18\n" +
	" \x01(\x0e2\x13.spark.TransferTypeR\x04type\"\xac\x01\n" +
	"\fTransferLeaf\x12#\n" +
	"\x04leaf\x18\x01 \x01(\v2\x0f.spark.TreeNodeR\x04leaf\x12#\n" +
	"\rsecret_cipher\x18\x02 \x01(\fR\fsecretCipher\x12\x1c\n" +
	"\tsignature\x18\x03 \x01(\fR\tsignature\x124\n" +
	"\x16intermediate_refund_tx\x18\x04 \x01(\fR\x14intermediateRefundTx\"\xf2\x02\n" +
	"\x0eTransferFilter\x12A\n" +
	"\x1creceiver_identity_public_key\x18\x01 \x01(\fH\x00R\x19receiverIdentityPublicKey\x12=\n" +
	"\x1asender_identity_public_key\x18\x02 \x01(\fH\x00R\x17senderIdentityPublicKey\x12S\n" +
	"&sender_or_receiver_identity_public_key\x18< \x01(\fH\x00R!senderOrReceiverIdentityPublicKey\x12!\n" +
	"\ftransfer_ids\x18\x03 \x03(\tR\vtransferIds\x12\x14\n" +
	"\x05limit\x18( \x01(\x03R\x05limit\x12\x16\n" +
	"\x06offset\x182 \x01(\x03R\x06offset\x12)\n" +
	"\x05types\x18F \x03(\x0e2\x13.spark.TransferTypeR\x05typesB\r\n" +
	"\vparticipant\"_\n" +
	"\x16QueryTransfersResponse\x12-\n" +
	"\ttransfers\x18\x01 \x03(\v2\x0f.spark.TransferR\ttransfers\x12\x16\n" +
	"\x06offset\x18\x02 \x01(\x03R\x06offset\"\x95\x02\n" +
	"\x11ClaimLeafKeyTweak\x12\x17\n" +
	"\aleaf_id\x18\x01 \x01(\tR\x06leafId\x12@\n" +
	"\x12secret_share_tweak\x18\x02 \x01(\v2\x12.spark.SecretShareR\x10secretShareTweak\x12_\n" +
	"\x13pubkey_shares_tweak\x18\x03 \x03(\v2/.spark.ClaimLeafKeyTweak.PubkeySharesTweakEntryR\x11pubkeySharesTweak\x1aD\n" +
	"\x16PubkeySharesTweakEntry\x12\x10\n" +
	"\x03key\x18\x01 \x01(\tR\x03key\x12\x14\n" +
	"\x05value\x18\x02 \x01(\fR\x05value:\x028\x01\"\xc1\x01\n" +
	"\x1dClaimTransferTweakKeysRequest\x12\x1f\n" +
	"\vtransfer_id\x18\x01 \x01(\tR\n" +
	"transferId\x129\n" +
	"\x19owner_identity_public_key\x18\x02 \x01(\fR\x16ownerIdentityPublicKey\x12D\n" +
	"\x11leaves_to_receive\x18\x03 \x03(\v2\x18.spark.ClaimLeafKeyTweakR\x0fleavesToReceive\"\xfc\x02\n" +
	"\x1fClaimTransferSignRefundsRequest\x12\x1f\n" +
	"\vtransfer_id\x18\x01 \x01(\tR\n" +
	"transferId\x129\n" +
	"\x19owner_identity_public_key\x18\x02 \x01(\fR\x16ownerIdentityPublicKey\x12@\n" +
	"\fsigning_jobs\x18\x03 \x03(\v2\x1d.spark.LeafRefundTxSigningJobR\vsigningJobs\x12d\n" +
	"\x10key_tweak_proofs\x18\x04 \x03(\v2:.spark.ClaimTransferSignRefundsRequest.KeyTweakProofsEntryR\x0ekeyTweakProofs\x1aU\n" +
	"\x13KeyTweakProofsEntry\x12\x10\n" +
	"\x03key\x18\x01 \x01(\tR\x03key\x12(\n" +
	"\x05value\x18\x02 \x01(\v2\x12.spark.SecretProofR\x05value:\x028\x01\"m\n" +
	" ClaimTransferSignRefundsResponse\x12I\n" +
	"\x0fsigning_results\x18\x01 \x03(\v2 .spark.LeafRefundTxSigningResultR\x0esigningResults\"\xa1\x01\n" +
	"\x15AggregateNodesRequest\x12\x19\n" +
	"\bnode_ids\x18\x01 \x03(\tR\anodeIds\x122\n" +
	"\vsigning_job\x18\x02 \x01(\v2\x11.spark.SigningJobR\n" +
	"signingJob\x129\n" +
	"\x19owner_identity_public_key\x18\x03 \x01(\fR\x16ownerIdentityPublicKey\"\xd4\x01\n" +
	"\x16AggregateNodesResponse\x12E\n" +
	"\x13aggregate_signature\x18\x01 \x01(\v2\x14.spark.SigningResultR\x12aggregateSignature\x12#\n" +
	"\rverifying_key\x18\x02 \x01(\fR\fverifyingKey\x12$\n" +
	"\x0eparent_node_tx\x18\x03 \x01(\fR\fparentNodeTx\x12(\n" +
	"\x10parent_node_vout\x18\x04 \x01(\rR\x0eparentNodeVout\"\xf7\x01\n" +
	"\x19StorePreimageShareRequest\x12!\n" +
	"\fpayment_hash\x18\x01 \x01(\fR\vpaymentHash\x129\n" +
	"\x0epreimage_share\x18\x02 \x01(\v2\x12.spark.SecretShareR\rpreimageShare\x12\x1c\n" +
	"\tthreshold\x18\x03 \x01(\rR\tthreshold\x12%\n" +
	"\x0einvoice_string\x18\x04 \x01(\tR\rinvoiceString\x127\n" +
	"\x18user_identity_public_key\x18\x05 \x01(\fR\x15userIdentityPublicKey\"\x81\x02\n" +
	"\x1bRequestedSigningCommitments\x12{\n" +
	"\x19signing_nonce_commitments\x18\x01 \x03(\v2?.spark.RequestedSigningCommitments.SigningNonceCommitmentsEntryR\x17signingNonceCommitments\x1ae\n" +
	"\x1cSigningNonceCommitmentsEntry\x12\x10\n" +
	"\x03key\x18\x01 \x01(\tR\x03key\x12/\n" +
	"\x05value\x18\x02 \x01(\v2\x19.common.SigningCommitmentR\x05value:\x028\x01\"9\n" +
	"\x1cGetSigningCommitmentsRequest\x12\x19\n" +
	"\bnode_ids\x18\x01 \x03(\tR\anodeIds\"t\n" +
	"\x1dGetSigningCommitmentsResponse\x12S\n" +
	"\x13signing_commitments\x18\x01 \x03(\v2\".spark.RequestedSigningCommitmentsR\x12signingCommitments\"\xda\x01\n" +
	"\x12SigningCommitments\x12b\n" +
	"\x13signing_commitments\x18\x01 \x03(\v21.spark.SigningCommitments.SigningCommitmentsEntryR\x12signingCommitments\x1a`\n" +
	"\x17SigningCommitmentsEntry\x12\x10\n" +
	"\x03key\x18\x01 \x01(\tR\x03key\x12/\n" +
	"\x05value\x18\x02 \x01(\v2\x19.common.SigningCommitmentR\x05value:\x028\x01\"\xc6\x02\n" +
	"\x10UserSignedRefund\x12\x17\n" +
	"\anode_id\x18\x01 \x01(\tR\x06nodeId\x12\x1b\n" +
	"\trefund_tx\x18\x02 \x01(\fR\brefundTx\x12%\n" +
	"\x0euser_signature\x18\x03 \x01(\fR\ruserSignature\x12J\n" +
	"\x13signing_commitments\x18\x04 \x01(\v2\x19.spark.SigningCommitmentsR\x12signingCommitments\x12U\n" +
	"\x19user_signature_commitment\x18\x05 \x01(\v2\x19.common.SigningCommitmentR\x17userSignatureCommitment\x122\n" +
	"\anetwork\x18\x06 \x01(\x0e2\x0e.spark.NetworkB\b\xfaB\x05\x82\x01\x02 \x00R\anetwork\";\n" +
	"\x12InvoiceAmountProof\x12%\n" +
	"\x0ebolt11_invoice\x18\x01 \x01(\tR\rbolt11Invoice\"{\n" +
	"\rInvoiceAmount\x12\x1d\n" +
	"\n" +
	"value_sats\x18\x01 \x01(\x04R\tvalueSats\x12K\n" +
	"\x14invoice_amount_proof\x18\x02 \x01(\v2\x19.spark.InvoiceAmountProofR\x12invoiceAmountProof\"\x8e\x03\n" +
	"\x1bInitiatePreimageSwapRequest\x12!\n" +
	"\fpayment_hash\x18\x01 \x01(\fR\vpaymentHash\x12;\n" +
	"\x0einvoice_amount\x18\x02 \x01(\v2\x14.spark.InvoiceAmountR\rinvoiceAmount\x12A\n" +
	"\x06reason\x18\x03 \x01(\x0e2).spark.InitiatePreimageSwapRequest.ReasonR\x06reason\x12A\n" +
	"\btransfer\x18\x04 \x01(\v2%.spark.StartUserSignedTransferRequestR\btransfer\x12?\n" +
	"\x1creceiver_identity_public_key\x18\x05 \x01(\fR\x19receiverIdentityPublicKey\x12\x19\n" +
	"\bfee_sats\x18\x06 \x01(\x04R\afeeSats\"-\n" +
	"\x06Reason\x12\x0f\n" +
	"\vREASON_SEND\x10\x00\x12\x12\n" +
	"\x0eREASON_RECEIVE\x10\x01\"g\n" +
	"\x1cInitiatePreimageSwapResponse\x12\x1a\n" +
	"\bpreimage\x18\x01 \x01(\fR\bpreimage\x12+\n" +
	"\btransfer\x18\x02 \x01(\v2\x0f.spark.TransferR\btransfer\"2\n" +
	"\bOutPoint\x12\x12\n" +
	"\x04txid\x18\x01 \x01(\fR\x04txid\x12\x12\n" +
	"\x04vout\x18\x02 \x01(\rR\x04vout\"\x87\x01\n" +
	"\x16CooperativeExitRequest\x127\n" +
	"\btransfer\x18\x01 \x01(\v2\x1b.spark.StartTransferRequestR\btransfer\x12\x17\n" +
	"\aexit_id\x18\x02 \x01(\tR\x06exitId\x12\x1b\n" +
	"\texit_txid\x18\x03 \x01(\fR\bexitTxid\"\x91\x01\n" +
	"\x17CooperativeExitResponse\x12+\n" +
	"\btransfer\x18\x01 \x01(\v2\x0f.spark.TransferR\btransfer\x12I\n" +
	"\x0fsigning_results\x18\x02 \x03(\v2 .spark.LeafRefundTxSigningResultR\x0esigningResults\"\x98\x01\n" +
	"\x16CounterLeafSwapRequest\x127\n" +
	"\btransfer\x18\x01 \x01(\v2\x1b.spark.StartTransferRequestR\btransfer\x12\x17\n" +
	"\aswap_id\x18\x02 \x01(\tR\x06swapId\x12,\n" +
	"\x12adaptor_public_key\x18\x03 \x01(\fR\x10adaptorPublicKey\"\x91\x01\n" +
	"\x17CounterLeafSwapResponse\x12+\n" +
	"\btransfer\x18\x01 \x01(\v2\x0f.spark.TransferR\btransfer\x12I\n" +
	"\x0fsigning_results\x18\x02 \x03(\v2 .spark.LeafRefundTxSigningResultR\x0esigningResults\"\xa2\x01\n" +
	"\x16RefreshTimelockRequest\x12\x17\n" +
	"\aleaf_id\x18\x01 \x01(\tR\x06leafId\x129\n" +
	"\x19owner_identity_public_key\x18\x02 \x01(\fR\x16ownerIdentityPublicKey\x124\n" +
	"\fsigning_jobs\x18\x03 \x03(\v2\x11.spark.SigningJobR\vsigningJobs\"\x80\x01\n" +
	"\x1cRefreshTimelockSigningResult\x12;\n" +
	"\x0esigning_result\x18\x01 \x01(\v2\x14.spark.SigningResultR\rsigningResult\x12#\n" +
	"\rverifying_key\x18\x02 \x01(\fR\fverifyingKey\"g\n" +
	"\x17RefreshTimelockResponse\x12L\n" +
	"\x0fsigning_results\x18\x01 \x03(\v2#.spark.RefreshTimelockSigningResultR\x0esigningResults\"\xef\x01\n" +
	"\x11ExtendLeafRequest\x12\x17\n" +
	"\aleaf_id\x18\x01 \x01(\tR\x06leafId\x129\n" +
	"\x19owner_identity_public_key\x18\x02 \x01(\fR\x16ownerIdentityPublicKey\x12@\n" +
	"\x13node_tx_signing_job\x18\x03 \x01(\v2\x11.spark.SigningJobR\x10nodeTxSigningJob\x12D\n" +
	"\x15refund_tx_signing_job\x18\x04 \x01(\v2\x11.spark.SigningJobR\x12refundTxSigningJob\"{\n" +
	"\x17ExtendLeafSigningResult\x12;\n" +
	"\x0esigning_result\x18\x01 \x01(\v2\x14.spark.SigningResultR\rsigningResult\x12#\n" +
	"\rverifying_key\x18\x02 \x01(\fR\fverifyingKey\"\xdb\x01\n" +
	"\x12ExtendLeafResponse\x12\x17\n" +
	"\aleaf_id\x18\x01 \x01(\tR\x06leafId\x12S\n" +
	"\x16node_tx_signing_result\x18\x02 \x01(\v2\x1e.spark.ExtendLeafSigningResultR\x13nodeTxSigningResult\x12W\n" +
	"\x18refund_tx_signing_result\x18\x03 \x01(\v2\x1e.spark.ExtendLeafSigningResultR\x15refundTxSigningResult\"s\n" +
	"\x12AddressRequestNode\x12&\n" +
	"\x0fuser_public_key\x18\x01 \x01(\fR\ruserPublicKey\x125\n" +
	"\bchildren\x18\x02 \x03(\v2\x19.spark.AddressRequestNodeR\bchildren\"\x83\x02\n" +
	"\x19PrepareTreeAddressRequest\x12A\n" +
	"\x12parent_node_output\x18\x01 \x01(\v2\x11.spark.NodeOutputH\x00R\x10parentNodeOutput\x121\n" +
	"\ron_chain_utxo\x18\x02 \x01(\v2\v.spark.UTXOH\x00R\vonChainUtxo\x12-\n" +
	"\x04node\x18\x03 \x01(\v2\x19.spark.AddressRequestNodeR\x04node\x127\n" +
	"\x18user_identity_public_key\x18\x04 \x01(\fR\x15userIdentityPublicKeyB\b\n" +
	"\x06source\"g\n" +
	"\vAddressNode\x12(\n" +
	"\aaddress\x18\x01 \x01(\v2\x0e.spark.AddressR\aaddress\x12.\n" +
	"\bchildren\x18\x02 \x03(\v2\x12.spark.AddressNodeR\bchildren\"D\n" +
	"\x1aPrepareTreeAddressResponse\x12&\n" +
	"\x04node\x18\x01 \x01(\v2\x12.spark.AddressNodeR\x04node\"\xc7\x01\n" +
	"\fCreationNode\x12@\n" +
	"\x13node_tx_signing_job\x18\x01 \x01(\v2\x11.spark.SigningJobR\x10nodeTxSigningJob\x12D\n" +
	"\x15refund_tx_signing_job\x18\x02 \x01(\v2\x11.spark.SigningJobR\x12refundTxSigningJob\x12/\n" +
	"\bchildren\x18\x03 \x03(\v2\x13.spark.CreationNodeR\bchildren\"\xf5\x01\n" +
	"\x11CreateTreeRequest\x12A\n" +
	"\x12parent_node_output\x18\x01 \x01(\v2\x11.spark.NodeOutputH\x00R\x10parentNodeOutput\x121\n" +
	"\ron_chain_utxo\x18\x02 \x01(\v2\v.spark.UTXOH\x00R\vonChainUtxo\x12'\n" +
	"\x04node\x18\x03 \x01(\v2\x13.spark.CreationNodeR\x04node\x127\n" +
	"\x18user_identity_public_key\x18\x04 \x01(\fR\x15userIdentityPublicKeyB\b\n" +
	"\x06source\"\x82\x02\n" +
	"\x14CreationResponseNode\x12\x17\n" +
	"\anode_id\x18\x01 \x01(\tR\x06nodeId\x12I\n" +
	"\x16node_tx_signing_result\x18\x02 \x01(\v2\x14.spark.SigningResultR\x13nodeTxSigningResult\x12M\n" +
	"\x18refund_tx_signing_result\x18\x03 \x01(\v2\x14.spark.SigningResultR\x15refundTxSigningResult\x127\n" +
	"\bchildren\x18\x04 \x03(\v2\x1b.spark.CreationResponseNodeR\bchildren\"E\n" +
	"\x12CreateTreeResponse\x12/\n" +
	"\x04node\x18\x01 \x01(\v2\x1b.spark.CreationResponseNodeR\x04node\"\x84\x01\n" +
	"\x13SigningOperatorInfo\x12\x14\n" +
	"\x05index\x18\x01 \x01(\x04R\x05index\x12\x1e\n" +
	"\n" +
	"identifier\x18\x02 \x01(\tR\n" +
	"identifier\x12\x1d\n" +
	"\n" +
	"public_key\x18\x03 \x01(\fR\tpublicKey\x12\x18\n" +
	"\aaddress\x18\x04 \x01(\tR\aaddress\"\xeb\x01\n" +
	"\x1eGetSigningOperatorListResponse\x12h\n" +
	"\x11signing_operators\x18\x01 \x03(\v2;.spark.GetSigningOperatorListResponse.SigningOperatorsEntryR\x10signingOperators\x1a_\n" +
	"\x15SigningOperatorsEntry\x12\x10\n" +
	"\x03key\x18\x01 \x01(\tR\x03key\x120\n" +
	"\x05value\x18\x02 \x01(\v2\x1a.spark.SigningOperatorInfoR\x05value:\x028\x01\"r\n" +
	"\x1dQueryUserSignedRefundsRequest\x12!\n" +
	"\fpayment_hash\x18\x01 \x01(\fR\vpaymentHash\x12.\n" +
	"\x13identity_public_key\x18\x02 \x01(\fR\x11identityPublicKey\"i\n" +
	"\x1eQueryUserSignedRefundsResponse\x12G\n" +
	"\x13user_signed_refunds\x18\x01 \x03(\v2\x17.spark.UserSignedRefundR\x11userSignedRefunds\"\x87\x01\n" +
	"\x16ProvidePreimageRequest\x12!\n" +
	"\fpayment_hash\x18\x01 \x01(\fR\vpaymentHash\x12\x1a\n" +
	"\bpreimage\x18\x02 \x01(\fR\bpreimage\x12.\n" +
	"\x13identity_public_key\x18\x03 \x01(\fR\x11identityPublicKey\"F\n" +
	"\x17ProvidePreimageResponse\x12+\n" +
	"\btransfer\x18\x01 \x01(\v2\x0f.spark.TransferR\btransfer\"{\n" +
	"\x1dReturnLightningPaymentRequest\x12!\n" +
	"\fpayment_hash\x18\x01 \x01(\fR\vpaymentHash\x127\n" +
	"\x18user_identity_public_key\x18\x02 \x01(\fR\x15userIdentityPublicKey\"(\n" +
	"\vTreeNodeIds\x12\x19\n" +
	"\bnode_ids\x18\x01 \x03(\tR\anodeIds\"\xad\x01\n" +
	"\x11QueryNodesRequest\x124\n" +
	"\x15owner_identity_pubkey\x18\x01 \x01(\fH\x00R\x13ownerIdentityPubkey\x12/\n" +
	"\bnode_ids\x18\x02 \x01(\v2\x12.spark.TreeNodeIdsH\x00R\anodeIds\x12'\n" +
	"\x0finclude_parents\x18\x03 \x01(\bR\x0eincludeParentsB\b\n" +
	"\x06source\"\x9b\x01\n" +
	"\x12QueryNodesResponse\x12:\n" +
	"\x05nodes\x18\x01 \x03(\v2$.spark.QueryNodesResponse.NodesEntryR\x05nodes\x1aI\n" +
	"\n" +
	"NodesEntry\x12\x10\n" +
	"\x03key\x18\x01 \x01(\tR\x03key\x12%\n" +
	"\x05value\x18\x02 \x01(\v2\x0f.spark.TreeNodeR\x05value:\x028\x01\"u\n" +
	"\x15CancelTransferRequest\x12\x1f\n" +
	"\vtransfer_id\x18\x01 \x01(\tR\n" +
	"transferId\x12;\n" +
	"\x1asender_identity_public_key\x18\x02 \x01(\fR\x17senderIdentityPublicKey\"E\n" +
	"\x16CancelTransferResponse\x12+\n" +
	"\btransfer\x18\x01 \x01(\v2\x0f.spark.TransferR\btransfer\"T\n" +
	"\"QueryUnusedDepositAddressesRequest\x12.\n" +
	"\x13identity_public_key\x18\x01 \x01(\fR\x11identityPublicKey\"\xe1\x01\n" +
	"\x19DepositAddressQueryResult\x12'\n" +
	"\x0fdeposit_address\x18\x01 \x01(\tR\x0edepositAddress\x125\n" +
	"\x17user_signing_public_key\x18\x02 \x01(\fR\x14userSigningPublicKey\x120\n" +
	"\x14verifying_public_key\x18\x03 \x01(\fR\x12verifyingPublicKey\x12&\n" +
	"\aleaf_id\x18\x04 \x01(\tB\b\xfaB\x05r\x03\xb0\x01\x01H\x00R\x06leafId\x88\x01\x01B\n" +
	"\n" +
	"\b_leaf_id\"t\n" +
	"#QueryUnusedDepositAddressesResponse\x12M\n" +
	"\x11deposit_addresses\x18\x01 \x03(\v2 .spark.DepositAddressQueryResultR\x10depositAddresses\"E\n" +
	"\x13QueryBalanceRequest\x12.\n" +
	"\x13identity_public_key\x18\x01 \x01(\fR\x11identityPublicKey\"\xc5\x01\n" +
	"\x14QueryBalanceResponse\x12\x18\n" +
	"\abalance\x18\x01 \x01(\x04R\abalance\x12R\n" +
	"\rnode_balances\x18\x02 \x03(\v2-.spark.QueryBalanceResponse.NodeBalancesEntryR\fnodeBalances\x1a?\n" +
	"\x11NodeBalancesEntry\x12\x10\n" +
	"\x03key\x18\x01 \x01(\tR\x03key\x12\x14\n" +
	"\x05value\x18\x02 \x01(\x04R\x05value:\x028\x01\">\n" +
	"\fSparkAddress\x12.\n" +
	"\x13identity_public_key\x18\x01 \x01(\fR\x11identityPublicKey*M\n" +
	"\aNetwork\x12\x0f\n" +
	"\vUNSPECIFIED\x10\x00\x12\v\n" +
	"\aMAINNET\x10\x01\x12\v\n" +
	"\aREGTEST\x10\x02\x12\v\n" +
	"\aTESTNET\x10\x03\x12\n" +
	"\n" +
	"\x06SIGNET\x10\x04*v\n" +
	"\x16TokenTransactionStatus\x12\x1d\n" +
	"\x19TOKEN_TRANSACTION_STARTED\x10\x00\x12\x1c\n" +
	"\x18TOKEN_TRANSACTION_SIGNED\x10\x01\x12\x1f\n" +
	"\x1bTOKEN_TRANSACTION_FINALIZED\x10\x02*\xbd\x02\n" +
	"\x0eTransferStatus\x12$\n" +
	" TRANSFER_STATUS_SENDER_INITIATED\x10\x00\x12,\n" +
	"(TRANSFER_STATUS_SENDER_KEY_TWEAK_PENDING\x10\x01\x12&\n" +
	"\"TRANSFER_STATUS_SENDER_KEY_TWEAKED\x10\x02\x12(\n" +
	"$TRANSFER_STATUS_RECEIVER_KEY_TWEAKED\x10\x03\x12+\n" +
	"'TRANSFER_STATUSR_RECEIVER_REFUND_SIGNED\x10\x04\x12\x1d\n" +
	"\x19TRANSFER_STATUS_COMPLETED\x10\x05\x12\x1b\n" +
	"\x17TRANSFER_STATUS_EXPIRED\x10\x06\x12\x1c\n" +
	"\x18TRANSFER_STATUS_RETURNED\x10\a*a\n" +
	"\fTransferType\x12\x11\n" +
	"\rPREIMAGE_SWAP\x10\x00\x12\x14\n" +
	"\x10COOPERATIVE_EXIT\x10\x01\x12\f\n" +
	"\bTRANSFER\x10\x02\x12\b\n" +
	"\x04SWAP\x10\x1e\x12\x10\n" +
	"\fCOUNTER_SWAP\x10(2\xad\x1b\n" +
	"\fSparkService\x12i\n" +
	"\x18generate_deposit_address\x12$.spark.GenerateDepositAddressRequest\x1a%.spark.GenerateDepositAddressResponse\"\x00\x12p\n" +
	"\x1bstart_deposit_tree_creation\x12&.spark.StartDepositTreeCreationRequest\x1a'.spark.StartDepositTreeCreationResponse\"\x00\x12]\n" +
	"\x13start_tree_creation\x12\x1f.spark.StartTreeCreationRequest\x1a .spark.StartTreeCreationResponse\"\x03\x88\x02\x01\x12i\n" +
	"\x18finalize_node_signatures\x12$.spark.FinalizeNodeSignaturesRequest\x1a%.spark.FinalizeNodeSignaturesResponse\"\x00\x12M\n" +
	"\x0estart_transfer\x12\x1b.spark.StartTransferRequest\x1a\x1c.spark.StartTransferResponse\"\x00\x12V\n" +
	"\x11finalize_transfer\x12\x1e.spark.FinalizeTransferRequest\x1a\x1f.spark.FinalizeTransferResponse\"\x00\x12P\n" +
	"\x0fcancel_transfer\x12\x1c.spark.CancelTransferRequest\x1a\x1d.spark.CancelTransferResponse\"\x00\x12Q\n" +
	"\x17query_pending_transfers\x12\x15.spark.TransferFilter\x1a\x1d.spark.QueryTransfersResponse\"\x00\x12M\n" +
	"\x13query_all_transfers\x12\x15.spark.TransferFilter\x1a\x1d.spark.QueryTransfersResponse\"\x00\x12[\n" +
	"\x19claim_transfer_tweak_keys\x12$.spark.ClaimTransferTweakKeysRequest\x1a\x16.google.protobuf.Empty\"\x00\x12p\n" +
	"\x1bclaim_transfer_sign_refunds\x12&.spark.ClaimTransferSignRefundsRequest\x1a'.spark.ClaimTransferSignRefundsResponse\"\x00\x12P\n" +
	"\x0faggregate_nodes\x12\x1c.spark.AggregateNodesRequest\x1a\x1d.spark.AggregateNodesResponse\"\x00\x12R\n" +
	"\x14store_preimage_share\x12 .spark.StorePreimageShareRequest\x1a\x16.google.protobuf.Empty\"\x00\x12f\n" +
	"\x17get_signing_commitments\x12#.spark.GetSigningCommitmentsRequest\x1a$.spark.GetSigningCommitmentsResponse\"\x00\x12S\n" +
	"\x10cooperative_exit\x12\x1d.spark.CooperativeExitRequest\x1a\x1e.spark.CooperativeExitResponse\"\x00\x12c\n" +
	"\x16initiate_preimage_swap\x12\".spark.InitiatePreimageSwapRequest\x1a#.spark.InitiatePreimageSwapResponse\"\x00\x12S\n" +
	"\x10provide_preimage\x12\x1d.spark.ProvidePreimageRequest\x1a\x1e.spark.ProvidePreimageResponse\"\x00\x12N\n" +
	"\x0fstart_leaf_swap\x12\x1b.spark.StartTransferRequest\x1a\x1c.spark.StartTransferResponse\"\x00\x12O\n" +
	"\tleaf_swap\x12\x1d.spark.CounterLeafSwapRequest\x1a\x1e.spark.CounterLeafSwapResponse\"\x03\x88\x02\x01\x12T\n" +
	"\x11counter_leaf_swap\x12\x1d.spark.CounterLeafSwapRequest\x1a\x1e.spark.CounterLeafSwapResponse\"\x00\x12S\n" +
	"\x10refresh_timelock\x12\x1d.spark.RefreshTimelockRequest\x1a\x1e.spark.RefreshTimelockResponse\"\x00\x12D\n" +
	"\vextend_leaf\x12\x18.spark.ExtendLeafRequest\x1a\x19.spark.ExtendLeafResponse\"\x00\x12]\n" +
	"\x14prepare_tree_address\x12 .spark.PrepareTreeAddressRequest\x1a!.spark.PrepareTreeAddressResponse\"\x00\x12D\n" +
	"\vcreate_tree\x12\x18.spark.CreateTreeRequest\x1a\x19.spark.CreateTreeResponse\"\x00\x12\\\n" +
	"\x19get_signing_operator_list\x12\x16.google.protobuf.Empty\x1a%.spark.GetSigningOperatorListResponse\"\x00\x12D\n" +
	"\vquery_nodes\x12\x18.spark.QueryNodesRequest\x1a\x19.spark.QueryNodesResponse\"\x00\x12J\n" +
	"\rquery_balance\x12\x1a.spark.QueryBalanceRequest\x1a\x1b.spark.QueryBalanceResponse\"\x00\x12j\n" +
	"\x19query_user_signed_refunds\x12$.spark.QueryUserSignedRefundsRequest\x1a%.spark.QueryUserSignedRefundsResponse\"\x00\x12f\n" +
	"\x17start_token_transaction\x12#.spark.StartTokenTransactionRequest\x1a$.spark.StartTokenTransactionResponse\"\x00\x12c\n" +
	"\x16sign_token_transaction\x12\".spark.SignTokenTransactionRequest\x1a#.spark.SignTokenTransactionResponse\"\x00\x12^\n" +
	"\x1afinalize_token_transaction\x12&.spark.FinalizeTokenTransactionRequest\x1a\x16.google.protobuf.Empty\"\x00\x12J\n" +
	"\rfreeze_tokens\x12\x1a.spark.FreezeTokensRequest\x1a\x1b.spark.FreezeTokensResponse\"\x00\x12Z\n" +
	"\x13query_token_outputs\x12\x1f.spark.QueryTokenOutputsRequest\x1a .spark.QueryTokenOutputsResponse\"\x00\x12i\n" +
	"\x18query_token_transactions\x12$.spark.QueryTokenTransactionsRequest\x1a%.spark.QueryTokenTransactionsResponse\"\x00\x12g\n" +
	"\x1fcancel_signed_token_transaction\x12*.spark.CancelSignedTokenTransactionRequest\x1a\x16.google.protobuf.Empty\"\x00\x12Z\n" +
	"\x18return_lightning_payment\x12$.spark.ReturnLightningPaymentRequest\x1a\x16.google.protobuf.Empty\"\x00\x12y\n" +
	"\x1equery_unused_deposit_addresses\x12).spark.QueryUnusedDepositAddressesRequest\x1a*.spark.QueryUnusedDepositAddressesResponse\"\x00\x12\\\n" +
	"\x13subscribe_to_events\x12\x1f.spark.SubscribeToEventsRequest\x1a .spark.SubscribeToEventsResponse\"\x000\x01B,Z*github.com/lightsparkdev/spark/proto/sparkb\x06proto3"

var (
	file_spark_proto_rawDescOnce sync.Once
	file_spark_proto_rawDescData []byte
)

func file_spark_proto_rawDescGZIP() []byte {
	file_spark_proto_rawDescOnce.Do(func() {
		file_spark_proto_rawDescData = protoimpl.X.CompressGZIP(unsafe.Slice(unsafe.StringData(file_spark_proto_rawDesc), len(file_spark_proto_rawDesc)))
	})
	return file_spark_proto_rawDescData
}

var file_spark_proto_enumTypes = make([]protoimpl.EnumInfo, 5)
var file_spark_proto_msgTypes = make([]protoimpl.MessageInfo, 130)
var file_spark_proto_goTypes = []any{
	(Network)(0),                                            // 0: spark.Network
	(TokenTransactionStatus)(0),                             // 1: spark.TokenTransactionStatus
	(TransferStatus)(0),                                     // 2: spark.TransferStatus
	(TransferType)(0),                                       // 3: spark.TransferType
	(InitiatePreimageSwapRequest_Reason)(0),                 // 4: spark.InitiatePreimageSwapRequest.Reason
	(*SubscribeToEventsRequest)(nil),                        // 5: spark.SubscribeToEventsRequest
	(*SubscribeToEventsResponse)(nil),                       // 6: spark.SubscribeToEventsResponse
	(*ConnectedEvent)(nil),                                  // 7: spark.ConnectedEvent
	(*TransferEvent)(nil),                                   // 8: spark.TransferEvent
	(*DepositEvent)(nil),                                    // 9: spark.DepositEvent
	(*DepositAddressProof)(nil),                             // 10: spark.DepositAddressProof
	(*GenerateDepositAddressRequest)(nil),                   // 11: spark.GenerateDepositAddressRequest
	(*Address)(nil),                                         // 12: spark.Address
	(*GenerateDepositAddressResponse)(nil),                  // 13: spark.GenerateDepositAddressResponse
	(*UTXO)(nil),                                            // 14: spark.UTXO
	(*NodeOutput)(nil),                                      // 15: spark.NodeOutput
	(*SigningJob)(nil),                                      // 16: spark.SigningJob
	(*SigningKeyshare)(nil),                                 // 17: spark.SigningKeyshare
	(*SigningResult)(nil),                                   // 18: spark.SigningResult
	(*NodeSignatureShares)(nil),                             // 19: spark.NodeSignatureShares
	(*NodeSignatures)(nil),                                  // 20: spark.NodeSignatures
	(*StartTreeCreationRequest)(nil),                        // 21: spark.StartTreeCreationRequest
	(*StartTreeCreationResponse)(nil),                       // 22: spark.StartTreeCreationResponse
	(*StartDepositTreeCreationRequest)(nil),                 // 23: spark.StartDepositTreeCreationRequest
	(*StartDepositTreeCreationResponse)(nil),                // 24: spark.StartDepositTreeCreationResponse
	(*TokenOutputToSpend)(nil),                              // 25: spark.TokenOutputToSpend
	(*TokenTransferInput)(nil),                              // 26: spark.TokenTransferInput
	(*TokenMintInput)(nil),                                  // 27: spark.TokenMintInput
	(*TokenOutput)(nil),                                     // 28: spark.TokenOutput
	(*TokenTransaction)(nil),                                // 29: spark.TokenTransaction
	(*TokenTransactionWithStatus)(nil),                      // 30: spark.TokenTransactionWithStatus
	(*SignatureWithIndex)(nil),                              // 31: spark.SignatureWithIndex
	(*TokenTransactionSignatures)(nil),                      // 32: spark.TokenTransactionSignatures
	(*StartTokenTransactionRequest)(nil),                    // 33: spark.StartTokenTransactionRequest
	(*StartTokenTransactionResponse)(nil),                   // 34: spark.StartTokenTransactionResponse
	(*OperatorSpecificTokenTransactionSignablePayload)(nil), // 35: spark.OperatorSpecificTokenTransactionSignablePayload
	(*OperatorSpecificOwnerSignature)(nil),                  // 36: spark.OperatorSpecificOwnerSignature
	(*SignTokenTransactionRequest)(nil),                     // 37: spark.SignTokenTransactionRequest
	(*KeyshareWithIndex)(nil),                               // 38: spark.KeyshareWithIndex
	(*SignTokenTransactionResponse)(nil),                    // 39: spark.SignTokenTransactionResponse
	(*RevocationSecretWithIndex)(nil),                       // 40: spark.RevocationSecretWithIndex
	(*FinalizeTokenTransactionRequest)(nil),                 // 41: spark.FinalizeTokenTransactionRequest
	(*FreezeTokensPayload)(nil),                             // 42: spark.FreezeTokensPayload
	(*FreezeTokensRequest)(nil),                             // 43: spark.FreezeTokensRequest
	(*FreezeTokensResponse)(nil),                            // 44: spark.FreezeTokensResponse
	(*QueryTokenOutputsRequest)(nil),                        // 45: spark.QueryTokenOutputsRequest
	(*QueryTokenTransactionsRequest)(nil),                   // 46: spark.QueryTokenTransactionsRequest
	(*QueryTokenTransactionsResponse)(nil),                  // 47: spark.QueryTokenTransactionsResponse
	(*OutputWithPreviousTransactionData)(nil),               // 48: spark.OutputWithPreviousTransactionData
	(*QueryTokenOutputsResponse)(nil),                       // 49: spark.QueryTokenOutputsResponse
	(*CancelSignedTokenTransactionRequest)(nil),             // 50: spark.CancelSignedTokenTransactionRequest
	(*TreeNode)(nil),                                        // 51: spark.TreeNode
	(*FinalizeNodeSignaturesRequest)(nil),                   // 52: spark.FinalizeNodeSignaturesRequest
	(*FinalizeNodeSignaturesResponse)(nil),                  // 53: spark.FinalizeNodeSignaturesResponse
	(*SecretShare)(nil),                                     // 54: spark.SecretShare
	(*SecretProof)(nil),                                     // 55: spark.SecretProof
	(*LeafRefundTxSigningJob)(nil),                          // 56: spark.LeafRefundTxSigningJob
	(*UserSignedTxSigningJob)(nil),                          // 57: spark.UserSignedTxSigningJob
	(*LeafRefundTxSigningResult)(nil),                       // 58: spark.LeafRefundTxSigningResult
	(*StartUserSignedTransferRequest)(nil),                  // 59: spark.StartUserSignedTransferRequest
	(*StartTransferRequest)(nil),                            // 60: spark.StartTransferRequest
	(*StartTransferResponse)(nil),                           // 61: spark.StartTransferResponse
	(*SendLeafKeyTweak)(nil),                                // 62: spark.SendLeafKeyTweak
	(*FinalizeTransferRequest)(nil),                         // 63: spark.FinalizeTransferRequest
	(*FinalizeTransferResponse)(nil),                        // 64: spark.FinalizeTransferResponse
	(*Transfer)(nil),                                        // 65: spark.Transfer
	(*TransferLeaf)(nil),                                    // 66: spark.TransferLeaf
	(*TransferFilter)(nil),                                  // 67: spark.TransferFilter
	(*QueryTransfersResponse)(nil),                          // 68: spark.QueryTransfersResponse
	(*ClaimLeafKeyTweak)(nil),                               // 69: spark.ClaimLeafKeyTweak
	(*ClaimTransferTweakKeysRequest)(nil),                   // 70: spark.ClaimTransferTweakKeysRequest
	(*ClaimTransferSignRefundsRequest)(nil),                 // 71: spark.ClaimTransferSignRefundsRequest
	(*ClaimTransferSignRefundsResponse)(nil),                // 72: spark.ClaimTransferSignRefundsResponse
	(*AggregateNodesRequest)(nil),                           // 73: spark.AggregateNodesRequest
	(*AggregateNodesResponse)(nil),                          // 74: spark.AggregateNodesResponse
	(*StorePreimageShareRequest)(nil),                       // 75: spark.StorePreimageShareRequest
	(*RequestedSigningCommitments)(nil),                     // 76: spark.RequestedSigningCommitments
	(*GetSigningCommitmentsRequest)(nil),                    // 77: spark.GetSigningCommitmentsRequest
	(*GetSigningCommitmentsResponse)(nil),                   // 78: spark.GetSigningCommitmentsResponse
	(*SigningCommitments)(nil),                              // 79: spark.SigningCommitments
	(*UserSignedRefund)(nil),                                // 80: spark.UserSignedRefund
	(*InvoiceAmountProof)(nil),                              // 81: spark.InvoiceAmountProof
	(*InvoiceAmount)(nil),                                   // 82: spark.InvoiceAmount
	(*InitiatePreimageSwapRequest)(nil),                     // 83: spark.InitiatePreimageSwapRequest
	(*InitiatePreimageSwapResponse)(nil),                    // 84: spark.InitiatePreimageSwapResponse
	(*OutPoint)(nil),                                        // 85: spark.OutPoint
	(*CooperativeExitRequest)(nil),                          // 86: spark.CooperativeExitRequest
	(*CooperativeExitResponse)(nil),                         // 87: spark.CooperativeExitResponse
	(*CounterLeafSwapRequest)(nil),                          // 88: spark.CounterLeafSwapRequest
	(*CounterLeafSwapResponse)(nil),                         // 89: spark.CounterLeafSwapResponse
	(*RefreshTimelockRequest)(nil),                          // 90: spark.RefreshTimelockRequest
	(*RefreshTimelockSigningResult)(nil),                    // 91: spark.RefreshTimelockSigningResult
	(*RefreshTimelockResponse)(nil),                         // 92: spark.RefreshTimelockResponse
	(*ExtendLeafRequest)(nil),                               // 93: spark.ExtendLeafRequest
	(*ExtendLeafSigningResult)(nil),                         // 94: spark.ExtendLeafSigningResult
	(*ExtendLeafResponse)(nil),                              // 95: spark.ExtendLeafResponse
	(*AddressRequestNode)(nil),                              // 96: spark.AddressRequestNode
	(*PrepareTreeAddressRequest)(nil),                       // 97: spark.PrepareTreeAddressRequest
	(*AddressNode)(nil),                                     // 98: spark.AddressNode
	(*PrepareTreeAddressResponse)(nil),                      // 99: spark.PrepareTreeAddressResponse
	(*CreationNode)(nil),                                    // 100: spark.CreationNode
	(*CreateTreeRequest)(nil),                               // 101: spark.CreateTreeRequest
	(*CreationResponseNode)(nil),                            // 102: spark.CreationResponseNode
	(*CreateTreeResponse)(nil),                              // 103: spark.CreateTreeResponse
	(*SigningOperatorInfo)(nil),                             // 104: spark.SigningOperatorInfo
	(*GetSigningOperatorListResponse)(nil),                  // 105: spark.GetSigningOperatorListResponse
	(*QueryUserSignedRefundsRequest)(nil),                   // 106: spark.QueryUserSignedRefundsRequest
	(*QueryUserSignedRefundsResponse)(nil),                  // 107: spark.QueryUserSignedRefundsResponse
	(*ProvidePreimageRequest)(nil),                          // 108: spark.ProvidePreimageRequest
	(*ProvidePreimageResponse)(nil),                         // 109: spark.ProvidePreimageResponse
	(*ReturnLightningPaymentRequest)(nil),                   // 110: spark.ReturnLightningPaymentRequest
	(*TreeNodeIds)(nil),                                     // 111: spark.TreeNodeIds
	(*QueryNodesRequest)(nil),                               // 112: spark.QueryNodesRequest
	(*QueryNodesResponse)(nil),                              // 113: spark.QueryNodesResponse
	(*CancelTransferRequest)(nil),                           // 114: spark.CancelTransferRequest
	(*CancelTransferResponse)(nil),                          // 115: spark.CancelTransferResponse
	(*QueryUnusedDepositAddressesRequest)(nil),              // 116: spark.QueryUnusedDepositAddressesRequest
	(*DepositAddressQueryResult)(nil),                       // 117: spark.DepositAddressQueryResult
	(*QueryUnusedDepositAddressesResponse)(nil),             // 118: spark.QueryUnusedDepositAddressesResponse
	(*QueryBalanceRequest)(nil),                             // 119: spark.QueryBalanceRequest
	(*QueryBalanceResponse)(nil),                            // 120: spark.QueryBalanceResponse
	(*SparkAddress)(nil),                                    // 121: spark.SparkAddress
	nil,                                                     // 122: spark.DepositAddressProof.AddressSignaturesEntry
	nil,                                                     // 123: spark.SigningResult.PublicKeysEntry
	nil,                                                     // 124: spark.SigningResult.SigningNonceCommitmentsEntry
	nil,                                                     // 125: spark.SigningResult.SignatureSharesEntry
	nil,                                                     // 126: spark.StartTransferRequest.KeyTweakProofsEntry
	nil,                                                     // 127: spark.SendLeafKeyTweak.PubkeySharesTweakEntry
	nil,                                                     // 128: spark.ClaimLeafKeyTweak.PubkeySharesTweakEntry
	nil,                                                     // 129: spark.ClaimTransferSignRefundsRequest.KeyTweakProofsEntry
	nil,                                                     // 130: spark.RequestedSigningCommitments.SigningNonceCommitmentsEntry
	nil,                                                     // 131: spark.SigningCommitments.SigningCommitmentsEntry
	nil,                                                     // 132: spark.GetSigningOperatorListResponse.SigningOperatorsEntry
	nil,                                                     // 133: spark.QueryNodesResponse.NodesEntry
	nil,                                                     // 134: spark.QueryBalanceResponse.NodeBalancesEntry
	(*common.SigningCommitment)(nil),                        // 135: common.SigningCommitment
	(common.SignatureIntent)(0),                             // 136: common.SignatureIntent
	(*timestamppb.Timestamp)(nil),                           // 137: google.protobuf.Timestamp
	(*emptypb.Empty)(nil),                                   // 138: google.protobuf.Empty
}
var file_spark_proto_depIdxs = []int32{
	8,   // 0: spark.SubscribeToEventsResponse.transfer:type_name -> spark.TransferEvent
	9,   // 1: spark.SubscribeToEventsResponse.deposit:type_name -> spark.DepositEvent
	7,   // 2: spark.SubscribeToEventsResponse.connected:type_name -> spark.ConnectedEvent
	65,  // 3: spark.TransferEvent.transfer:type_name -> spark.Transfer
	51,  // 4: spark.DepositEvent.deposit:type_name -> spark.TreeNode
	122, // 5: spark.DepositAddressProof.address_signatures:type_name -> spark.DepositAddressProof.AddressSignaturesEntry
	0,   // 6: spark.GenerateDepositAddressRequest.network:type_name -> spark.Network
	10,  // 7: spark.Address.deposit_address_proof:type_name -> spark.DepositAddressProof
	12,  // 8: spark.GenerateDepositAddressResponse.deposit_address:type_name -> spark.Address
	0,   // 9: spark.UTXO.network:type_name -> spark.Network
	135, // 10: spark.SigningJob.signing_nonce_commitment:type_name -> common.SigningCommitment
	123, // 11: spark.SigningResult.public_keys:type_name -> spark.SigningResult.PublicKeysEntry
	124, // 12: spark.SigningResult.signing_nonce_commitments:type_name -> spark.SigningResult.SigningNonceCommitmentsEntry
	125, // 13: spark.SigningResult.signature_shares:type_name -> spark.SigningResult.SignatureSharesEntry
	17,  // 14: spark.SigningResult.signing_keyshare:type_name -> spark.SigningKeyshare
	18,  // 15: spark.NodeSignatureShares.node_tx_signing_result:type_name -> spark.SigningResult
	18,  // 16: spark.NodeSignatureShares.refund_tx_signing_result:type_name -> spark.SigningResult
	14,  // 17: spark.StartTreeCreationRequest.on_chain_utxo:type_name -> spark.UTXO
	16,  // 18: spark.StartTreeCreationRequest.root_tx_signing_job:type_name -> spark.SigningJob
	16,  // 19: spark.StartTreeCreationRequest.refund_tx_signing_job:type_name -> spark.SigningJob
	19,  // 20: spark.StartTreeCreationResponse.root_node_signature_shares:type_name -> spark.NodeSignatureShares
	14,  // 21: spark.StartDepositTreeCreationRequest.on_chain_utxo:type_name -> spark.UTXO
	16,  // 22: spark.StartDepositTreeCreationRequest.root_tx_signing_job:type_name -> spark.SigningJob
	16,  // 23: spark.StartDepositTreeCreationRequest.refund_tx_signing_job:type_name -> spark.SigningJob
	19,  // 24: spark.StartDepositTreeCreationResponse.root_node_signature_shares:type_name -> spark.NodeSignatureShares
	25,  // 25: spark.TokenTransferInput.outputs_to_spend:type_name -> spark.TokenOutputToSpend
	27,  // 26: spark.TokenTransaction.mint_input:type_name -> spark.TokenMintInput
	26,  // 27: spark.TokenTransaction.transfer_input:type_name -> spark.TokenTransferInput
	28,  // 28: spark.TokenTransaction.token_outputs:type_name -> spark.TokenOutput
	0,   // 29: spark.TokenTransaction.network:type_name -> spark.Network
	29,  // 30: spark.TokenTransactionWithStatus.token_transaction:type_name -> spark.TokenTransaction
	1,   // 31: spark.TokenTransactionWithStatus.status:type_name -> spark.TokenTransactionStatus
	31,  // 32: spark.TokenTransactionSignatures.owner_signatures:type_name -> spark.SignatureWithIndex
	29,  // 33: spark.StartTokenTransactionRequest.partial_token_transaction:type_name -> spark.TokenTransaction
	32,  // 34: spark.StartTokenTransactionRequest.token_transaction_signatures:type_name -> spark.TokenTransactionSignatures
	29,  // 35: spark.StartTokenTransactionResponse.final_token_transaction:type_name -> spark.TokenTransaction
	17,  // 36: spark.StartTokenTransactionResponse.keyshare_info:type_name -> spark.SigningKeyshare
	31,  // 37: spark.OperatorSpecificOwnerSignature.owner_signature:type_name -> spark.SignatureWithIndex
	35,  // 38: spark.OperatorSpecificOwnerSignature.payload:type_name -> spark.OperatorSpecificTokenTransactionSignablePayload
	29,  // 39: spark.SignTokenTransactionRequest.final_token_transaction:type_name -> spark.TokenTransaction
	36,  // 40: spark.SignTokenTransactionRequest.operator_specific_signatures:type_name -> spark.OperatorSpecificOwnerSignature
	38,  // 41: spark.SignTokenTransactionResponse.revocation_keyshares:type_name -> spark.KeyshareWithIndex
	29,  // 42: spark.FinalizeTokenTransactionRequest.final_token_transaction:type_name -> spark.TokenTransaction
	40,  // 43: spark.FinalizeTokenTransactionRequest.revocation_secrets:type_name -> spark.RevocationSecretWithIndex
	42,  // 44: spark.FreezeTokensRequest.freeze_tokens_payload:type_name -> spark.FreezeTokensPayload
	30,  // 45: spark.QueryTokenTransactionsResponse.token_transactions_with_status:type_name -> spark.TokenTransactionWithStatus
	28,  // 46: spark.OutputWithPreviousTransactionData.output:type_name -> spark.TokenOutput
	48,  // 47: spark.QueryTokenOutputsResponse.outputs_with_previous_transaction_data:type_name -> spark.OutputWithPreviousTransactionData
	29,  // 48: spark.CancelSignedTokenTransactionRequest.final_token_transaction:type_name -> spark.TokenTransaction
	17,  // 49: spark.TreeNode.signing_keyshare:type_name -> spark.SigningKeyshare
	0,   // 50: spark.TreeNode.network:type_name -> spark.Network
	136, // 51: spark.FinalizeNodeSignaturesRequest.intent:type_name -> common.SignatureIntent
	20,  // 52: spark.FinalizeNodeSignaturesRequest.node_signatures:type_name -> spark.NodeSignatures
	51,  // 53: spark.FinalizeNodeSignaturesResponse.nodes:type_name -> spark.TreeNode
	16,  // 54: spark.LeafRefundTxSigningJob.refund_tx_signing_job:type_name -> spark.SigningJob
	135, // 55: spark.UserSignedTxSigningJob.signing_nonce_commitment:type_name -> common.SigningCommitment
	79,  // 56: spark.UserSignedTxSigningJob.signing_commitments:type_name -> spark.SigningCommitments
	18,  // 57: spark.LeafRefundTxSigningResult.refund_tx_signing_result:type_name -> spark.SigningResult
	57,  // 58: spark.StartUserSignedTransferRequest.leaves_to_send:type_name -> spark.UserSignedTxSigningJob
	137, // 59: spark.StartUserSignedTransferRequest.expiry_time:type_name -> google.protobuf.Timestamp
	56,  // 60: spark.StartTransferRequest.leaves_to_send:type_name -> spark.LeafRefundTxSigningJob
	137, // 61: spark.StartTransferRequest.expiry_time:type_name -> google.protobuf.Timestamp
	126, // 62: spark.StartTransferRequest.key_tweak_proofs:type_name -> spark.StartTransferRequest.KeyTweakProofsEntry
	65,  // 63: spark.StartTransferResponse.transfer:type_name -> spark.Transfer
	58,  // 64: spark.StartTransferResponse.signing_results:type_name -> spark.LeafRefundTxSigningResult
	54,  // 65: spark.SendLeafKeyTweak.secret_share_tweak:type_name -> spark.SecretShare
	127, // 66: spark.SendLeafKeyTweak.pubkey_shares_tweak:type_name -> spark.SendLeafKeyTweak.PubkeySharesTweakEntry
	62,  // 67: spark.FinalizeTransferRequest.leaves_to_send:type_name -> spark.SendLeafKeyTweak
	65,  // 68: spark.FinalizeTransferResponse.transfer:type_name -> spark.Transfer
	2,   // 69: spark.Transfer.status:type_name -> spark.TransferStatus
	137, // 70: spark.Transfer.expiry_time:type_name -> google.protobuf.Timestamp
	66,  // 71: spark.Transfer.leaves:type_name -> spark.TransferLeaf
	137, // 72: spark.Transfer.created_time:type_name -> google.protobuf.Timestamp
	137, // 73: spark.Transfer.updated_time:type_name -> google.protobuf.Timestamp
	3,   // 74: spark.Transfer.type:type_name -> spark.TransferType
	51,  // 75: spark.TransferLeaf.leaf:type_name -> spark.TreeNode
	3,   // 76: spark.TransferFilter.types:type_name -> spark.TransferType
	65,  // 77: spark.QueryTransfersResponse.transfers:type_name -> spark.Transfer
	54,  // 78: spark.ClaimLeafKeyTweak.secret_share_tweak:type_name -> spark.SecretShare
	128, // 79: spark.ClaimLeafKeyTweak.pubkey_shares_tweak:type_name -> spark.ClaimLeafKeyTweak.PubkeySharesTweakEntry
	69,  // 80: spark.ClaimTransferTweakKeysRequest.leaves_to_receive:type_name -> spark.ClaimLeafKeyTweak
	56,  // 81: spark.ClaimTransferSignRefundsRequest.signing_jobs:type_name -> spark.LeafRefundTxSigningJob
	129, // 82: spark.ClaimTransferSignRefundsRequest.key_tweak_proofs:type_name -> spark.ClaimTransferSignRefundsRequest.KeyTweakProofsEntry
	58,  // 83: spark.ClaimTransferSignRefundsResponse.signing_results:type_name -> spark.LeafRefundTxSigningResult
	16,  // 84: spark.AggregateNodesRequest.signing_job:type_name -> spark.SigningJob
	18,  // 85: spark.AggregateNodesResponse.aggregate_signature:type_name -> spark.SigningResult
	54,  // 86: spark.StorePreimageShareRequest.preimage_share:type_name -> spark.SecretShare
	130, // 87: spark.RequestedSigningCommitments.signing_nonce_commitments:type_name -> spark.RequestedSigningCommitments.SigningNonceCommitmentsEntry
	76,  // 88: spark.GetSigningCommitmentsResponse.signing_commitments:type_name -> spark.RequestedSigningCommitments
	131, // 89: spark.SigningCommitments.signing_commitments:type_name -> spark.SigningCommitments.SigningCommitmentsEntry
	79,  // 90: spark.UserSignedRefund.signing_commitments:type_name -> spark.SigningCommitments
	135, // 91: spark.UserSignedRefund.user_signature_commitment:type_name -> common.SigningCommitment
	0,   // 92: spark.UserSignedRefund.network:type_name -> spark.Network
	81,  // 93: spark.InvoiceAmount.invoice_amount_proof:type_name -> spark.InvoiceAmountProof
	82,  // 94: spark.InitiatePreimageSwapRequest.invoice_amount:type_name -> spark.InvoiceAmount
	4,   // 95: spark.InitiatePreimageSwapRequest.reason:type_name -> spark.InitiatePreimageSwapRequest.Reason
	59,  // 96: spark.InitiatePreimageSwapRequest.transfer:type_name -> spark.StartUserSignedTransferRequest
	65,  // 97: spark.InitiatePreimageSwapResponse.transfer:type_name -> spark.Transfer
	60,  // 98: spark.CooperativeExitRequest.transfer:type_name -> spark.StartTransferRequest
	65,  // 99: spark.CooperativeExitResponse.transfer:type_name -> spark.Transfer
	58,  // 100: spark.CooperativeExitResponse.signing_results:type_name -> spark.LeafRefundTxSigningResult
	60,  // 101: spark.CounterLeafSwapRequest.transfer:type_name -> spark.StartTransferRequest
	65,  // 102: spark.CounterLeafSwapResponse.transfer:type_name -> spark.Transfer
	58,  // 103: spark.CounterLeafSwapResponse.signing_results:type_name -> spark.LeafRefundTxSigningResult
	16,  // 104: spark.RefreshTimelockRequest.signing_jobs:type_name -> spark.SigningJob
	18,  // 105: spark.RefreshTimelockSigningResult.signing_result:type_name -> spark.SigningResult
	91,  // 106: spark.RefreshTimelockResponse.signing_results:type_name -> spark.RefreshTimelockSigningResult
	16,  // 107: spark.ExtendLeafRequest.node_tx_signing_job:type_name -> spark.SigningJob
	16,  // 108: spark.ExtendLeafRequest.refund_tx_signing_job:type_name -> spark.SigningJob
	18,  // 109: spark.ExtendLeafSigningResult.signing_result:type_name -> spark.SigningResult
	94,  // 110: spark.ExtendLeafResponse.node_tx_signing_result:type_name -> spark.ExtendLeafSigningResult
	94,  // 111: spark.ExtendLeafResponse.refund_tx_signing_result:type_name -> spark.ExtendLeafSigningResult
	96,  // 112: spark.AddressRequestNode.children:type_name -> spark.AddressRequestNode
	15,  // 113: spark.PrepareTreeAddressRequest.parent_node_output:type_name -> spark.NodeOutput
	14,  // 114: spark.PrepareTreeAddressRequest.on_chain_utxo:type_name -> spark.UTXO
	96,  // 115: spark.PrepareTreeAddressRequest.node:type_name -> spark.AddressRequestNode
	12,  // 116: spark.AddressNode.address:type_name -> spark.Address
	98,  // 117: spark.AddressNode.children:type_name -> spark.AddressNode
	98,  // 118: spark.PrepareTreeAddressResponse.node:type_name -> spark.AddressNode
	16,  // 119: spark.CreationNode.node_tx_signing_job:type_name -> spark.SigningJob
	16,  // 120: spark.CreationNode.refund_tx_signing_job:type_name -> spark.SigningJob
	100, // 121: spark.CreationNode.children:type_name -> spark.CreationNode
	15,  // 122: spark.CreateTreeRequest.parent_node_output:type_name -> spark.NodeOutput
	14,  // 123: spark.CreateTreeRequest.on_chain_utxo:type_name -> spark.UTXO
	100, // 124: spark.CreateTreeRequest.node:type_name -> spark.CreationNode
	18,  // 125: spark.CreationResponseNode.node_tx_signing_result:type_name -> spark.SigningResult
	18,  // 126: spark.CreationResponseNode.refund_tx_signing_result:type_name -> spark.SigningResult
	102, // 127: spark.CreationResponseNode.children:type_name -> spark.CreationResponseNode
	102, // 128: spark.CreateTreeResponse.node:type_name -> spark.CreationResponseNode
	132, // 129: spark.GetSigningOperatorListResponse.signing_operators:type_name -> spark.GetSigningOperatorListResponse.SigningOperatorsEntry
	80,  // 130: spark.QueryUserSignedRefundsResponse.user_signed_refunds:type_name -> spark.UserSignedRefund
	65,  // 131: spark.ProvidePreimageResponse.transfer:type_name -> spark.Transfer
	111, // 132: spark.QueryNodesRequest.node_ids:type_name -> spark.TreeNodeIds
	133, // 133: spark.QueryNodesResponse.nodes:type_name -> spark.QueryNodesResponse.NodesEntry
	65,  // 134: spark.CancelTransferResponse.transfer:type_name -> spark.Transfer
	117, // 135: spark.QueryUnusedDepositAddressesResponse.deposit_addresses:type_name -> spark.DepositAddressQueryResult
	134, // 136: spark.QueryBalanceResponse.node_balances:type_name -> spark.QueryBalanceResponse.NodeBalancesEntry
	135, // 137: spark.SigningResult.SigningNonceCommitmentsEntry.value:type_name -> common.SigningCommitment
	55,  // 138: spark.StartTransferRequest.KeyTweakProofsEntry.value:type_name -> spark.SecretProof
	55,  // 139: spark.ClaimTransferSignRefundsRequest.KeyTweakProofsEntry.value:type_name -> spark.SecretProof
	135, // 140: spark.RequestedSigningCommitments.SigningNonceCommitmentsEntry.value:type_name -> common.SigningCommitment
	135, // 141: spark.SigningCommitments.SigningCommitmentsEntry.value:type_name -> common.SigningCommitment
	104, // 142: spark.GetSigningOperatorListResponse.SigningOperatorsEntry.value:type_name -> spark.SigningOperatorInfo
	51,  // 143: spark.QueryNodesResponse.NodesEntry.value:type_name -> spark.TreeNode
	11,  // 144: spark.SparkService.generate_deposit_address:input_type -> spark.GenerateDepositAddressRequest
	23,  // 145: spark.SparkService.start_deposit_tree_creation:input_type -> spark.StartDepositTreeCreationRequest
	21,  // 146: spark.SparkService.start_tree_creation:input_type -> spark.StartTreeCreationRequest
	52,  // 147: spark.SparkService.finalize_node_signatures:input_type -> spark.FinalizeNodeSignaturesRequest
	60,  // 148: spark.SparkService.start_transfer:input_type -> spark.StartTransferRequest
	63,  // 149: spark.SparkService.finalize_transfer:input_type -> spark.FinalizeTransferRequest
	114, // 150: spark.SparkService.cancel_transfer:input_type -> spark.CancelTransferRequest
	67,  // 151: spark.SparkService.query_pending_transfers:input_type -> spark.TransferFilter
	67,  // 152: spark.SparkService.query_all_transfers:input_type -> spark.TransferFilter
	70,  // 153: spark.SparkService.claim_transfer_tweak_keys:input_type -> spark.ClaimTransferTweakKeysRequest
	71,  // 154: spark.SparkService.claim_transfer_sign_refunds:input_type -> spark.ClaimTransferSignRefundsRequest
	73,  // 155: spark.SparkService.aggregate_nodes:input_type -> spark.AggregateNodesRequest
	75,  // 156: spark.SparkService.store_preimage_share:input_type -> spark.StorePreimageShareRequest
	77,  // 157: spark.SparkService.get_signing_commitments:input_type -> spark.GetSigningCommitmentsRequest
	86,  // 158: spark.SparkService.cooperative_exit:input_type -> spark.CooperativeExitRequest
	83,  // 159: spark.SparkService.initiate_preimage_swap:input_type -> spark.InitiatePreimageSwapRequest
	108, // 160: spark.SparkService.provide_preimage:input_type -> spark.ProvidePreimageRequest
	60,  // 161: spark.SparkService.start_leaf_swap:input_type -> spark.StartTransferRequest
	88,  // 162: spark.SparkService.leaf_swap:input_type -> spark.CounterLeafSwapRequest
	88,  // 163: spark.SparkService.counter_leaf_swap:input_type -> spark.CounterLeafSwapRequest
	90,  // 164: spark.SparkService.refresh_timelock:input_type -> spark.RefreshTimelockRequest
	93,  // 165: spark.SparkService.extend_leaf:input_type -> spark.ExtendLeafRequest
	97,  // 166: spark.SparkService.prepare_tree_address:input_type -> spark.PrepareTreeAddressRequest
	101, // 167: spark.SparkService.create_tree:input_type -> spark.CreateTreeRequest
	138, // 168: spark.SparkService.get_signing_operator_list:input_type -> google.protobuf.Empty
	112, // 169: spark.SparkService.query_nodes:input_type -> spark.QueryNodesRequest
	119, // 170: spark.SparkService.query_balance:input_type -> spark.QueryBalanceRequest
	106, // 171: spark.SparkService.query_user_signed_refunds:input_type -> spark.QueryUserSignedRefundsRequest
	33,  // 172: spark.SparkService.start_token_transaction:input_type -> spark.StartTokenTransactionRequest
	37,  // 173: spark.SparkService.sign_token_transaction:input_type -> spark.SignTokenTransactionRequest
	41,  // 174: spark.SparkService.finalize_token_transaction:input_type -> spark.FinalizeTokenTransactionRequest
	43,  // 175: spark.SparkService.freeze_tokens:input_type -> spark.FreezeTokensRequest
	45,  // 176: spark.SparkService.query_token_outputs:input_type -> spark.QueryTokenOutputsRequest
	46,  // 177: spark.SparkService.query_token_transactions:input_type -> spark.QueryTokenTransactionsRequest
	50,  // 178: spark.SparkService.cancel_signed_token_transaction:input_type -> spark.CancelSignedTokenTransactionRequest
	110, // 179: spark.SparkService.return_lightning_payment:input_type -> spark.ReturnLightningPaymentRequest
	116, // 180: spark.SparkService.query_unused_deposit_addresses:input_type -> spark.QueryUnusedDepositAddressesRequest
	5,   // 181: spark.SparkService.subscribe_to_events:input_type -> spark.SubscribeToEventsRequest
	13,  // 182: spark.SparkService.generate_deposit_address:output_type -> spark.GenerateDepositAddressResponse
	24,  // 183: spark.SparkService.start_deposit_tree_creation:output_type -> spark.StartDepositTreeCreationResponse
	22,  // 184: spark.SparkService.start_tree_creation:output_type -> spark.StartTreeCreationResponse
	53,  // 185: spark.SparkService.finalize_node_signatures:output_type -> spark.FinalizeNodeSignaturesResponse
	61,  // 186: spark.SparkService.start_transfer:output_type -> spark.StartTransferResponse
	64,  // 187: spark.SparkService.finalize_transfer:output_type -> spark.FinalizeTransferResponse
	115, // 188: spark.SparkService.cancel_transfer:output_type -> spark.CancelTransferResponse
	68,  // 189: spark.SparkService.query_pending_transfers:output_type -> spark.QueryTransfersResponse
	68,  // 190: spark.SparkService.query_all_transfers:output_type -> spark.QueryTransfersResponse
	138, // 191: spark.SparkService.claim_transfer_tweak_keys:output_type -> google.protobuf.Empty
	72,  // 192: spark.SparkService.claim_transfer_sign_refunds:output_type -> spark.ClaimTransferSignRefundsResponse
	74,  // 193: spark.SparkService.aggregate_nodes:output_type -> spark.AggregateNodesResponse
	138, // 194: spark.SparkService.store_preimage_share:output_type -> google.protobuf.Empty
	78,  // 195: spark.SparkService.get_signing_commitments:output_type -> spark.GetSigningCommitmentsResponse
	87,  // 196: spark.SparkService.cooperative_exit:output_type -> spark.CooperativeExitResponse
	84,  // 197: spark.SparkService.initiate_preimage_swap:output_type -> spark.InitiatePreimageSwapResponse
	109, // 198: spark.SparkService.provide_preimage:output_type -> spark.ProvidePreimageResponse
	61,  // 199: spark.SparkService.start_leaf_swap:output_type -> spark.StartTransferResponse
	89,  // 200: spark.SparkService.leaf_swap:output_type -> spark.CounterLeafSwapResponse
	89,  // 201: spark.SparkService.counter_leaf_swap:output_type -> spark.CounterLeafSwapResponse
	92,  // 202: spark.SparkService.refresh_timelock:output_type -> spark.RefreshTimelockResponse
	95,  // 203: spark.SparkService.extend_leaf:output_type -> spark.ExtendLeafResponse
	99,  // 204: spark.SparkService.prepare_tree_address:output_type -> spark.PrepareTreeAddressResponse
	103, // 205: spark.SparkService.create_tree:output_type -> spark.CreateTreeResponse
	105, // 206: spark.SparkService.get_signing_operator_list:output_type -> spark.GetSigningOperatorListResponse
	113, // 207: spark.SparkService.query_nodes:output_type -> spark.QueryNodesResponse
	120, // 208: spark.SparkService.query_balance:output_type -> spark.QueryBalanceResponse
	107, // 209: spark.SparkService.query_user_signed_refunds:output_type -> spark.QueryUserSignedRefundsResponse
	34,  // 210: spark.SparkService.start_token_transaction:output_type -> spark.StartTokenTransactionResponse
	39,  // 211: spark.SparkService.sign_token_transaction:output_type -> spark.SignTokenTransactionResponse
	138, // 212: spark.SparkService.finalize_token_transaction:output_type -> google.protobuf.Empty
	44,  // 213: spark.SparkService.freeze_tokens:output_type -> spark.FreezeTokensResponse
	49,  // 214: spark.SparkService.query_token_outputs:output_type -> spark.QueryTokenOutputsResponse
	47,  // 215: spark.SparkService.query_token_transactions:output_type -> spark.QueryTokenTransactionsResponse
	138, // 216: spark.SparkService.cancel_signed_token_transaction:output_type -> google.protobuf.Empty
	138, // 217: spark.SparkService.return_lightning_payment:output_type -> google.protobuf.Empty
	118, // 218: spark.SparkService.query_unused_deposit_addresses:output_type -> spark.QueryUnusedDepositAddressesResponse
	6,   // 219: spark.SparkService.subscribe_to_events:output_type -> spark.SubscribeToEventsResponse
	182, // [182:220] is the sub-list for method output_type
	144, // [144:182] is the sub-list for method input_type
	144, // [144:144] is the sub-list for extension type_name
	144, // [144:144] is the sub-list for extension extendee
	0,   // [0:144] is the sub-list for field type_name
}

func init() { file_spark_proto_init() }
func file_spark_proto_init() {
	if File_spark_proto != nil {
		return
	}
	file_spark_proto_msgTypes[1].OneofWrappers = []any{
		(*SubscribeToEventsResponse_Transfer)(nil),
		(*SubscribeToEventsResponse_Deposit)(nil),
		(*SubscribeToEventsResponse_Connected)(nil),
	}
	file_spark_proto_msgTypes[6].OneofWrappers = []any{}
	file_spark_proto_msgTypes[23].OneofWrappers = []any{}
	file_spark_proto_msgTypes[24].OneofWrappers = []any{
		(*TokenTransaction_MintInput)(nil),
		(*TokenTransaction_TransferInput)(nil),
	}
	file_spark_proto_msgTypes[46].OneofWrappers = []any{}
	file_spark_proto_msgTypes[62].OneofWrappers = []any{
		(*TransferFilter_ReceiverIdentityPublicKey)(nil),
		(*TransferFilter_SenderIdentityPublicKey)(nil),
		(*TransferFilter_SenderOrReceiverIdentityPublicKey)(nil),
	}
	file_spark_proto_msgTypes[92].OneofWrappers = []any{
		(*PrepareTreeAddressRequest_ParentNodeOutput)(nil),
		(*PrepareTreeAddressRequest_OnChainUtxo)(nil),
	}
	file_spark_proto_msgTypes[96].OneofWrappers = []any{
		(*CreateTreeRequest_ParentNodeOutput)(nil),
		(*CreateTreeRequest_OnChainUtxo)(nil),
	}
	file_spark_proto_msgTypes[107].OneofWrappers = []any{
		(*QueryNodesRequest_OwnerIdentityPubkey)(nil),
		(*QueryNodesRequest_NodeIds)(nil),
	}
	file_spark_proto_msgTypes[112].OneofWrappers = []any{}
	type x struct{}
	out := protoimpl.TypeBuilder{
		File: protoimpl.DescBuilder{
			GoPackagePath: reflect.TypeOf(x{}).PkgPath(),
			RawDescriptor: unsafe.Slice(unsafe.StringData(file_spark_proto_rawDesc), len(file_spark_proto_rawDesc)),
			NumEnums:      5,
			NumMessages:   130,
			NumExtensions: 0,
			NumServices:   1,
		},
		GoTypes:           file_spark_proto_goTypes,
		DependencyIndexes: file_spark_proto_depIdxs,
		EnumInfos:         file_spark_proto_enumTypes,
		MessageInfos:      file_spark_proto_msgTypes,
	}.Build()
	File_spark_proto = out.File
	file_spark_proto_goTypes = nil
	file_spark_proto_depIdxs = nil
}
