// Code generated by protoc-gen-validate. DO NOT EDIT.
// source: spark_internal.proto

package spark_internal

import (
	"bytes"
	"errors"
	"fmt"
	"net"
	"net/mail"
	"net/url"
	"regexp"
	"sort"
	"strings"
	"time"
	"unicode/utf8"

	"google.golang.org/protobuf/types/known/anypb"

	spark "github.com/lightsparkdev/spark/proto/spark"
)

// ensure the imports are used
var (
	_ = bytes.MinRead
	_ = errors.New("")
	_ = fmt.Print
	_ = utf8.UTFMax
	_ = (*regexp.Regexp)(nil)
	_ = (*strings.Reader)(nil)
	_ = net.IPv4len
	_ = time.Duration(0)
	_ = (*url.URL)(nil)
	_ = (*mail.Address)(nil)
	_ = anypb.Any{}
	_ = sort.Sort

	_ = spark.Network(0)
)

// Validate checks the field values on MarkKeysharesAsUsedRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *MarkKeysharesAsUsedRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on MarkKeysharesAsUsedRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// MarkKeysharesAsUsedRequestMultiError, or nil if none found.
func (m *MarkKeysharesAsUsedRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *MarkKeysharesAsUsedRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(errors) > 0 {
		return MarkKeysharesAsUsedRequestMultiError(errors)
	}

	return nil
}

// MarkKeysharesAsUsedRequestMultiError is an error wrapping multiple
// validation errors returned by MarkKeysharesAsUsedRequest.ValidateAll() if
// the designated constraints aren't met.
type MarkKeysharesAsUsedRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m MarkKeysharesAsUsedRequestMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m MarkKeysharesAsUsedRequestMultiError) AllErrors() []error { return m }

// MarkKeysharesAsUsedRequestValidationError is the validation error returned
// by MarkKeysharesAsUsedRequest.Validate if the designated constraints aren't met.
type MarkKeysharesAsUsedRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e MarkKeysharesAsUsedRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e MarkKeysharesAsUsedRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e MarkKeysharesAsUsedRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e MarkKeysharesAsUsedRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e MarkKeysharesAsUsedRequestValidationError) ErrorName() string {
	return "MarkKeysharesAsUsedRequestValidationError"
}

// Error satisfies the builtin error interface
func (e MarkKeysharesAsUsedRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sMarkKeysharesAsUsedRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = MarkKeysharesAsUsedRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = MarkKeysharesAsUsedRequestValidationError{}

// Validate checks the field values on MarkKeyshareForDepositAddressRequest
// with the rules defined in the proto definition for this message. If any
// rules are violated, the first error encountered is returned, or nil if
// there are no violations.
func (m *MarkKeyshareForDepositAddressRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on MarkKeyshareForDepositAddressRequest
// with the rules defined in the proto definition for this message. If any
// rules are violated, the result is a list of violation errors wrapped in
// MarkKeyshareForDepositAddressRequestMultiError, or nil if none found.
func (m *MarkKeyshareForDepositAddressRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *MarkKeyshareForDepositAddressRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for KeyshareId

	// no validation rules for Address

	// no validation rules for OwnerIdentityPublicKey

	// no validation rules for OwnerSigningPublicKey

	if m.IsStatic != nil {
		// no validation rules for IsStatic
	}

	if len(errors) > 0 {
		return MarkKeyshareForDepositAddressRequestMultiError(errors)
	}

	return nil
}

// MarkKeyshareForDepositAddressRequestMultiError is an error wrapping multiple
// validation errors returned by
// MarkKeyshareForDepositAddressRequest.ValidateAll() if the designated
// constraints aren't met.
type MarkKeyshareForDepositAddressRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m MarkKeyshareForDepositAddressRequestMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m MarkKeyshareForDepositAddressRequestMultiError) AllErrors() []error { return m }

// MarkKeyshareForDepositAddressRequestValidationError is the validation error
// returned by MarkKeyshareForDepositAddressRequest.Validate if the designated
// constraints aren't met.
type MarkKeyshareForDepositAddressRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e MarkKeyshareForDepositAddressRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e MarkKeyshareForDepositAddressRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e MarkKeyshareForDepositAddressRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e MarkKeyshareForDepositAddressRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e MarkKeyshareForDepositAddressRequestValidationError) ErrorName() string {
	return "MarkKeyshareForDepositAddressRequestValidationError"
}

// Error satisfies the builtin error interface
func (e MarkKeyshareForDepositAddressRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sMarkKeyshareForDepositAddressRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = MarkKeyshareForDepositAddressRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = MarkKeyshareForDepositAddressRequestValidationError{}

// Validate checks the field values on MarkKeyshareForDepositAddressResponse
// with the rules defined in the proto definition for this message. If any
// rules are violated, the first error encountered is returned, or nil if
// there are no violations.
func (m *MarkKeyshareForDepositAddressResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on MarkKeyshareForDepositAddressResponse
// with the rules defined in the proto definition for this message. If any
// rules are violated, the result is a list of violation errors wrapped in
// MarkKeyshareForDepositAddressResponseMultiError, or nil if none found.
func (m *MarkKeyshareForDepositAddressResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *MarkKeyshareForDepositAddressResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for AddressSignature

	if len(errors) > 0 {
		return MarkKeyshareForDepositAddressResponseMultiError(errors)
	}

	return nil
}

// MarkKeyshareForDepositAddressResponseMultiError is an error wrapping
// multiple validation errors returned by
// MarkKeyshareForDepositAddressResponse.ValidateAll() if the designated
// constraints aren't met.
type MarkKeyshareForDepositAddressResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m MarkKeyshareForDepositAddressResponseMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m MarkKeyshareForDepositAddressResponseMultiError) AllErrors() []error { return m }

// MarkKeyshareForDepositAddressResponseValidationError is the validation error
// returned by MarkKeyshareForDepositAddressResponse.Validate if the
// designated constraints aren't met.
type MarkKeyshareForDepositAddressResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e MarkKeyshareForDepositAddressResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e MarkKeyshareForDepositAddressResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e MarkKeyshareForDepositAddressResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e MarkKeyshareForDepositAddressResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e MarkKeyshareForDepositAddressResponseValidationError) ErrorName() string {
	return "MarkKeyshareForDepositAddressResponseValidationError"
}

// Error satisfies the builtin error interface
func (e MarkKeyshareForDepositAddressResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sMarkKeyshareForDepositAddressResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = MarkKeyshareForDepositAddressResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = MarkKeyshareForDepositAddressResponseValidationError{}

// Validate checks the field values on FrostRound1Request with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *FrostRound1Request) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on FrostRound1Request with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// FrostRound1RequestMultiError, or nil if none found.
func (m *FrostRound1Request) ValidateAll() error {
	return m.validate(true)
}

func (m *FrostRound1Request) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(errors) > 0 {
		return FrostRound1RequestMultiError(errors)
	}

	return nil
}

// FrostRound1RequestMultiError is an error wrapping multiple validation errors
// returned by FrostRound1Request.ValidateAll() if the designated constraints
// aren't met.
type FrostRound1RequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m FrostRound1RequestMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m FrostRound1RequestMultiError) AllErrors() []error { return m }

// FrostRound1RequestValidationError is the validation error returned by
// FrostRound1Request.Validate if the designated constraints aren't met.
type FrostRound1RequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e FrostRound1RequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e FrostRound1RequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e FrostRound1RequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e FrostRound1RequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e FrostRound1RequestValidationError) ErrorName() string {
	return "FrostRound1RequestValidationError"
}

// Error satisfies the builtin error interface
func (e FrostRound1RequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sFrostRound1Request.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = FrostRound1RequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = FrostRound1RequestValidationError{}

// Validate checks the field values on FrostRound1Response with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *FrostRound1Response) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on FrostRound1Response with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// FrostRound1ResponseMultiError, or nil if none found.
func (m *FrostRound1Response) ValidateAll() error {
	return m.validate(true)
}

func (m *FrostRound1Response) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetSigningCommitments() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, FrostRound1ResponseValidationError{
						field:  fmt.Sprintf("SigningCommitments[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, FrostRound1ResponseValidationError{
						field:  fmt.Sprintf("SigningCommitments[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return FrostRound1ResponseValidationError{
					field:  fmt.Sprintf("SigningCommitments[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return FrostRound1ResponseMultiError(errors)
	}

	return nil
}

// FrostRound1ResponseMultiError is an error wrapping multiple validation
// errors returned by FrostRound1Response.ValidateAll() if the designated
// constraints aren't met.
type FrostRound1ResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m FrostRound1ResponseMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m FrostRound1ResponseMultiError) AllErrors() []error { return m }

// FrostRound1ResponseValidationError is the validation error returned by
// FrostRound1Response.Validate if the designated constraints aren't met.
type FrostRound1ResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e FrostRound1ResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e FrostRound1ResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e FrostRound1ResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e FrostRound1ResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e FrostRound1ResponseValidationError) ErrorName() string {
	return "FrostRound1ResponseValidationError"
}

// Error satisfies the builtin error interface
func (e FrostRound1ResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sFrostRound1Response.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = FrostRound1ResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = FrostRound1ResponseValidationError{}

// Validate checks the field values on SigningJob with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *SigningJob) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on SigningJob with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in SigningJobMultiError, or
// nil if none found.
func (m *SigningJob) ValidateAll() error {
	return m.validate(true)
}

func (m *SigningJob) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for JobId

	// no validation rules for Message

	// no validation rules for KeyshareId

	// no validation rules for VerifyingKey

	{
		sorted_keys := make([]string, len(m.GetCommitments()))
		i := 0
		for key := range m.GetCommitments() {
			sorted_keys[i] = key
			i++
		}
		sort.Slice(sorted_keys, func(i, j int) bool { return sorted_keys[i] < sorted_keys[j] })
		for _, key := range sorted_keys {
			val := m.GetCommitments()[key]
			_ = val

			// no validation rules for Commitments[key]

			if all {
				switch v := interface{}(val).(type) {
				case interface{ ValidateAll() error }:
					if err := v.ValidateAll(); err != nil {
						errors = append(errors, SigningJobValidationError{
							field:  fmt.Sprintf("Commitments[%v]", key),
							reason: "embedded message failed validation",
							cause:  err,
						})
					}
				case interface{ Validate() error }:
					if err := v.Validate(); err != nil {
						errors = append(errors, SigningJobValidationError{
							field:  fmt.Sprintf("Commitments[%v]", key),
							reason: "embedded message failed validation",
							cause:  err,
						})
					}
				}
			} else if v, ok := interface{}(val).(interface{ Validate() error }); ok {
				if err := v.Validate(); err != nil {
					return SigningJobValidationError{
						field:  fmt.Sprintf("Commitments[%v]", key),
						reason: "embedded message failed validation",
						cause:  err,
					}
				}
			}

		}
	}

	if all {
		switch v := interface{}(m.GetUserCommitments()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, SigningJobValidationError{
					field:  "UserCommitments",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, SigningJobValidationError{
					field:  "UserCommitments",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetUserCommitments()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return SigningJobValidationError{
				field:  "UserCommitments",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for AdaptorPublicKey

	if len(errors) > 0 {
		return SigningJobMultiError(errors)
	}

	return nil
}

// SigningJobMultiError is an error wrapping multiple validation errors
// returned by SigningJob.ValidateAll() if the designated constraints aren't met.
type SigningJobMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m SigningJobMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m SigningJobMultiError) AllErrors() []error { return m }

// SigningJobValidationError is the validation error returned by
// SigningJob.Validate if the designated constraints aren't met.
type SigningJobValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e SigningJobValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e SigningJobValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e SigningJobValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e SigningJobValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e SigningJobValidationError) ErrorName() string { return "SigningJobValidationError" }

// Error satisfies the builtin error interface
func (e SigningJobValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sSigningJob.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = SigningJobValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = SigningJobValidationError{}

// Validate checks the field values on FrostRound2Request with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *FrostRound2Request) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on FrostRound2Request with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// FrostRound2RequestMultiError, or nil if none found.
func (m *FrostRound2Request) ValidateAll() error {
	return m.validate(true)
}

func (m *FrostRound2Request) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetSigningJobs() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, FrostRound2RequestValidationError{
						field:  fmt.Sprintf("SigningJobs[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, FrostRound2RequestValidationError{
						field:  fmt.Sprintf("SigningJobs[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return FrostRound2RequestValidationError{
					field:  fmt.Sprintf("SigningJobs[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return FrostRound2RequestMultiError(errors)
	}

	return nil
}

// FrostRound2RequestMultiError is an error wrapping multiple validation errors
// returned by FrostRound2Request.ValidateAll() if the designated constraints
// aren't met.
type FrostRound2RequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m FrostRound2RequestMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m FrostRound2RequestMultiError) AllErrors() []error { return m }

// FrostRound2RequestValidationError is the validation error returned by
// FrostRound2Request.Validate if the designated constraints aren't met.
type FrostRound2RequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e FrostRound2RequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e FrostRound2RequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e FrostRound2RequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e FrostRound2RequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e FrostRound2RequestValidationError) ErrorName() string {
	return "FrostRound2RequestValidationError"
}

// Error satisfies the builtin error interface
func (e FrostRound2RequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sFrostRound2Request.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = FrostRound2RequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = FrostRound2RequestValidationError{}

// Validate checks the field values on FrostRound2Response with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *FrostRound2Response) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on FrostRound2Response with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// FrostRound2ResponseMultiError, or nil if none found.
func (m *FrostRound2Response) ValidateAll() error {
	return m.validate(true)
}

func (m *FrostRound2Response) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	{
		sorted_keys := make([]string, len(m.GetResults()))
		i := 0
		for key := range m.GetResults() {
			sorted_keys[i] = key
			i++
		}
		sort.Slice(sorted_keys, func(i, j int) bool { return sorted_keys[i] < sorted_keys[j] })
		for _, key := range sorted_keys {
			val := m.GetResults()[key]
			_ = val

			// no validation rules for Results[key]

			if all {
				switch v := interface{}(val).(type) {
				case interface{ ValidateAll() error }:
					if err := v.ValidateAll(); err != nil {
						errors = append(errors, FrostRound2ResponseValidationError{
							field:  fmt.Sprintf("Results[%v]", key),
							reason: "embedded message failed validation",
							cause:  err,
						})
					}
				case interface{ Validate() error }:
					if err := v.Validate(); err != nil {
						errors = append(errors, FrostRound2ResponseValidationError{
							field:  fmt.Sprintf("Results[%v]", key),
							reason: "embedded message failed validation",
							cause:  err,
						})
					}
				}
			} else if v, ok := interface{}(val).(interface{ Validate() error }); ok {
				if err := v.Validate(); err != nil {
					return FrostRound2ResponseValidationError{
						field:  fmt.Sprintf("Results[%v]", key),
						reason: "embedded message failed validation",
						cause:  err,
					}
				}
			}

		}
	}

	if len(errors) > 0 {
		return FrostRound2ResponseMultiError(errors)
	}

	return nil
}

// FrostRound2ResponseMultiError is an error wrapping multiple validation
// errors returned by FrostRound2Response.ValidateAll() if the designated
// constraints aren't met.
type FrostRound2ResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m FrostRound2ResponseMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m FrostRound2ResponseMultiError) AllErrors() []error { return m }

// FrostRound2ResponseValidationError is the validation error returned by
// FrostRound2Response.Validate if the designated constraints aren't met.
type FrostRound2ResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e FrostRound2ResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e FrostRound2ResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e FrostRound2ResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e FrostRound2ResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e FrostRound2ResponseValidationError) ErrorName() string {
	return "FrostRound2ResponseValidationError"
}

// Error satisfies the builtin error interface
func (e FrostRound2ResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sFrostRound2Response.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = FrostRound2ResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = FrostRound2ResponseValidationError{}

// Validate checks the field values on PrepareSplitKeysharesRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *PrepareSplitKeysharesRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on PrepareSplitKeysharesRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// PrepareSplitKeysharesRequestMultiError, or nil if none found.
func (m *PrepareSplitKeysharesRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *PrepareSplitKeysharesRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for NodeId

	// no validation rules for TargetKeyshareId

	// no validation rules for LastKeyshareId

	if len(errors) > 0 {
		return PrepareSplitKeysharesRequestMultiError(errors)
	}

	return nil
}

// PrepareSplitKeysharesRequestMultiError is an error wrapping multiple
// validation errors returned by PrepareSplitKeysharesRequest.ValidateAll() if
// the designated constraints aren't met.
type PrepareSplitKeysharesRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m PrepareSplitKeysharesRequestMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m PrepareSplitKeysharesRequestMultiError) AllErrors() []error { return m }

// PrepareSplitKeysharesRequestValidationError is the validation error returned
// by PrepareSplitKeysharesRequest.Validate if the designated constraints
// aren't met.
type PrepareSplitKeysharesRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e PrepareSplitKeysharesRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e PrepareSplitKeysharesRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e PrepareSplitKeysharesRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e PrepareSplitKeysharesRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e PrepareSplitKeysharesRequestValidationError) ErrorName() string {
	return "PrepareSplitKeysharesRequestValidationError"
}

// Error satisfies the builtin error interface
func (e PrepareSplitKeysharesRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sPrepareSplitKeysharesRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = PrepareSplitKeysharesRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = PrepareSplitKeysharesRequestValidationError{}

// Validate checks the field values on FinalizeTreeCreationRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *FinalizeTreeCreationRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on FinalizeTreeCreationRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// FinalizeTreeCreationRequestMultiError, or nil if none found.
func (m *FinalizeTreeCreationRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *FinalizeTreeCreationRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetNodes() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, FinalizeTreeCreationRequestValidationError{
						field:  fmt.Sprintf("Nodes[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, FinalizeTreeCreationRequestValidationError{
						field:  fmt.Sprintf("Nodes[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return FinalizeTreeCreationRequestValidationError{
					field:  fmt.Sprintf("Nodes[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	// no validation rules for Network

	if len(errors) > 0 {
		return FinalizeTreeCreationRequestMultiError(errors)
	}

	return nil
}

// FinalizeTreeCreationRequestMultiError is an error wrapping multiple
// validation errors returned by FinalizeTreeCreationRequest.ValidateAll() if
// the designated constraints aren't met.
type FinalizeTreeCreationRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m FinalizeTreeCreationRequestMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m FinalizeTreeCreationRequestMultiError) AllErrors() []error { return m }

// FinalizeTreeCreationRequestValidationError is the validation error returned
// by FinalizeTreeCreationRequest.Validate if the designated constraints
// aren't met.
type FinalizeTreeCreationRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e FinalizeTreeCreationRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e FinalizeTreeCreationRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e FinalizeTreeCreationRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e FinalizeTreeCreationRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e FinalizeTreeCreationRequestValidationError) ErrorName() string {
	return "FinalizeTreeCreationRequestValidationError"
}

// Error satisfies the builtin error interface
func (e FinalizeTreeCreationRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sFinalizeTreeCreationRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = FinalizeTreeCreationRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = FinalizeTreeCreationRequestValidationError{}

// Validate checks the field values on FinalizeNodesAggregationRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *FinalizeNodesAggregationRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on FinalizeNodesAggregationRequest with
// the rules defined in the proto definition for this message. If any rules
// are violated, the result is a list of violation errors wrapped in
// FinalizeNodesAggregationRequestMultiError, or nil if none found.
func (m *FinalizeNodesAggregationRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *FinalizeNodesAggregationRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetNodes() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, FinalizeNodesAggregationRequestValidationError{
						field:  fmt.Sprintf("Nodes[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, FinalizeNodesAggregationRequestValidationError{
						field:  fmt.Sprintf("Nodes[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return FinalizeNodesAggregationRequestValidationError{
					field:  fmt.Sprintf("Nodes[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return FinalizeNodesAggregationRequestMultiError(errors)
	}

	return nil
}

// FinalizeNodesAggregationRequestMultiError is an error wrapping multiple
// validation errors returned by FinalizeNodesAggregationRequest.ValidateAll()
// if the designated constraints aren't met.
type FinalizeNodesAggregationRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m FinalizeNodesAggregationRequestMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m FinalizeNodesAggregationRequestMultiError) AllErrors() []error { return m }

// FinalizeNodesAggregationRequestValidationError is the validation error
// returned by FinalizeNodesAggregationRequest.Validate if the designated
// constraints aren't met.
type FinalizeNodesAggregationRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e FinalizeNodesAggregationRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e FinalizeNodesAggregationRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e FinalizeNodesAggregationRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e FinalizeNodesAggregationRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e FinalizeNodesAggregationRequestValidationError) ErrorName() string {
	return "FinalizeNodesAggregationRequestValidationError"
}

// Error satisfies the builtin error interface
func (e FinalizeNodesAggregationRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sFinalizeNodesAggregationRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = FinalizeNodesAggregationRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = FinalizeNodesAggregationRequestValidationError{}

// Validate checks the field values on FinalizeTransferRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *FinalizeTransferRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on FinalizeTransferRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// FinalizeTransferRequestMultiError, or nil if none found.
func (m *FinalizeTransferRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *FinalizeTransferRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for TransferId

	for idx, item := range m.GetNodes() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, FinalizeTransferRequestValidationError{
						field:  fmt.Sprintf("Nodes[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, FinalizeTransferRequestValidationError{
						field:  fmt.Sprintf("Nodes[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return FinalizeTransferRequestValidationError{
					field:  fmt.Sprintf("Nodes[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if all {
		switch v := interface{}(m.GetTimestamp()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, FinalizeTransferRequestValidationError{
					field:  "Timestamp",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, FinalizeTransferRequestValidationError{
					field:  "Timestamp",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetTimestamp()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return FinalizeTransferRequestValidationError{
				field:  "Timestamp",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return FinalizeTransferRequestMultiError(errors)
	}

	return nil
}

// FinalizeTransferRequestMultiError is an error wrapping multiple validation
// errors returned by FinalizeTransferRequest.ValidateAll() if the designated
// constraints aren't met.
type FinalizeTransferRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m FinalizeTransferRequestMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m FinalizeTransferRequestMultiError) AllErrors() []error { return m }

// FinalizeTransferRequestValidationError is the validation error returned by
// FinalizeTransferRequest.Validate if the designated constraints aren't met.
type FinalizeTransferRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e FinalizeTransferRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e FinalizeTransferRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e FinalizeTransferRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e FinalizeTransferRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e FinalizeTransferRequestValidationError) ErrorName() string {
	return "FinalizeTransferRequestValidationError"
}

// Error satisfies the builtin error interface
func (e FinalizeTransferRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sFinalizeTransferRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = FinalizeTransferRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = FinalizeTransferRequestValidationError{}

// Validate checks the field values on FinalizeRefreshTimelockRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *FinalizeRefreshTimelockRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on FinalizeRefreshTimelockRequest with
// the rules defined in the proto definition for this message. If any rules
// are violated, the result is a list of violation errors wrapped in
// FinalizeRefreshTimelockRequestMultiError, or nil if none found.
func (m *FinalizeRefreshTimelockRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *FinalizeRefreshTimelockRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetNodes() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, FinalizeRefreshTimelockRequestValidationError{
						field:  fmt.Sprintf("Nodes[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, FinalizeRefreshTimelockRequestValidationError{
						field:  fmt.Sprintf("Nodes[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return FinalizeRefreshTimelockRequestValidationError{
					field:  fmt.Sprintf("Nodes[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return FinalizeRefreshTimelockRequestMultiError(errors)
	}

	return nil
}

// FinalizeRefreshTimelockRequestMultiError is an error wrapping multiple
// validation errors returned by FinalizeRefreshTimelockRequest.ValidateAll()
// if the designated constraints aren't met.
type FinalizeRefreshTimelockRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m FinalizeRefreshTimelockRequestMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m FinalizeRefreshTimelockRequestMultiError) AllErrors() []error { return m }

// FinalizeRefreshTimelockRequestValidationError is the validation error
// returned by FinalizeRefreshTimelockRequest.Validate if the designated
// constraints aren't met.
type FinalizeRefreshTimelockRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e FinalizeRefreshTimelockRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e FinalizeRefreshTimelockRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e FinalizeRefreshTimelockRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e FinalizeRefreshTimelockRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e FinalizeRefreshTimelockRequestValidationError) ErrorName() string {
	return "FinalizeRefreshTimelockRequestValidationError"
}

// Error satisfies the builtin error interface
func (e FinalizeRefreshTimelockRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sFinalizeRefreshTimelockRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = FinalizeRefreshTimelockRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = FinalizeRefreshTimelockRequestValidationError{}

// Validate checks the field values on FinalizeExtendLeafRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *FinalizeExtendLeafRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on FinalizeExtendLeafRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// FinalizeExtendLeafRequestMultiError, or nil if none found.
func (m *FinalizeExtendLeafRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *FinalizeExtendLeafRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetNode()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, FinalizeExtendLeafRequestValidationError{
					field:  "Node",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, FinalizeExtendLeafRequestValidationError{
					field:  "Node",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetNode()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return FinalizeExtendLeafRequestValidationError{
				field:  "Node",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return FinalizeExtendLeafRequestMultiError(errors)
	}

	return nil
}

// FinalizeExtendLeafRequestMultiError is an error wrapping multiple validation
// errors returned by FinalizeExtendLeafRequest.ValidateAll() if the
// designated constraints aren't met.
type FinalizeExtendLeafRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m FinalizeExtendLeafRequestMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m FinalizeExtendLeafRequestMultiError) AllErrors() []error { return m }

// FinalizeExtendLeafRequestValidationError is the validation error returned by
// FinalizeExtendLeafRequest.Validate if the designated constraints aren't met.
type FinalizeExtendLeafRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e FinalizeExtendLeafRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e FinalizeExtendLeafRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e FinalizeExtendLeafRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e FinalizeExtendLeafRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e FinalizeExtendLeafRequestValidationError) ErrorName() string {
	return "FinalizeExtendLeafRequestValidationError"
}

// Error satisfies the builtin error interface
func (e FinalizeExtendLeafRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sFinalizeExtendLeafRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = FinalizeExtendLeafRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = FinalizeExtendLeafRequestValidationError{}

// Validate checks the field values on TreeNode with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *TreeNode) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on TreeNode with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in TreeNodeMultiError, or nil
// if none found.
func (m *TreeNode) ValidateAll() error {
	return m.validate(true)
}

func (m *TreeNode) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Id

	// no validation rules for Value

	// no validation rules for VerifyingPubkey

	// no validation rules for OwnerIdentityPubkey

	// no validation rules for OwnerSigningPubkey

	// no validation rules for RawTx

	// no validation rules for RawRefundTx

	// no validation rules for TreeId

	// no validation rules for SigningKeyshareId

	// no validation rules for Vout

	// no validation rules for RefundTimelock

	if m.ParentNodeId != nil {
		// no validation rules for ParentNodeId
	}

	if len(errors) > 0 {
		return TreeNodeMultiError(errors)
	}

	return nil
}

// TreeNodeMultiError is an error wrapping multiple validation errors returned
// by TreeNode.ValidateAll() if the designated constraints aren't met.
type TreeNodeMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m TreeNodeMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m TreeNodeMultiError) AllErrors() []error { return m }

// TreeNodeValidationError is the validation error returned by
// TreeNode.Validate if the designated constraints aren't met.
type TreeNodeValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e TreeNodeValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e TreeNodeValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e TreeNodeValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e TreeNodeValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e TreeNodeValidationError) ErrorName() string { return "TreeNodeValidationError" }

// Error satisfies the builtin error interface
func (e TreeNodeValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sTreeNode.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = TreeNodeValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = TreeNodeValidationError{}

// Validate checks the field values on InitiatePreimageSwapResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *InitiatePreimageSwapResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on InitiatePreimageSwapResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// InitiatePreimageSwapResponseMultiError, or nil if none found.
func (m *InitiatePreimageSwapResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *InitiatePreimageSwapResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for PreimageShare

	if len(errors) > 0 {
		return InitiatePreimageSwapResponseMultiError(errors)
	}

	return nil
}

// InitiatePreimageSwapResponseMultiError is an error wrapping multiple
// validation errors returned by InitiatePreimageSwapResponse.ValidateAll() if
// the designated constraints aren't met.
type InitiatePreimageSwapResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m InitiatePreimageSwapResponseMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m InitiatePreimageSwapResponseMultiError) AllErrors() []error { return m }

// InitiatePreimageSwapResponseValidationError is the validation error returned
// by InitiatePreimageSwapResponse.Validate if the designated constraints
// aren't met.
type InitiatePreimageSwapResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e InitiatePreimageSwapResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e InitiatePreimageSwapResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e InitiatePreimageSwapResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e InitiatePreimageSwapResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e InitiatePreimageSwapResponseValidationError) ErrorName() string {
	return "InitiatePreimageSwapResponseValidationError"
}

// Error satisfies the builtin error interface
func (e InitiatePreimageSwapResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sInitiatePreimageSwapResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = InitiatePreimageSwapResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = InitiatePreimageSwapResponseValidationError{}

// Validate checks the field values on PrepareTreeAddressNode with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *PrepareTreeAddressNode) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on PrepareTreeAddressNode with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// PrepareTreeAddressNodeMultiError, or nil if none found.
func (m *PrepareTreeAddressNode) ValidateAll() error {
	return m.validate(true)
}

func (m *PrepareTreeAddressNode) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for SigningKeyshareId

	// no validation rules for UserPublicKey

	for idx, item := range m.GetChildren() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, PrepareTreeAddressNodeValidationError{
						field:  fmt.Sprintf("Children[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, PrepareTreeAddressNodeValidationError{
						field:  fmt.Sprintf("Children[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return PrepareTreeAddressNodeValidationError{
					field:  fmt.Sprintf("Children[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return PrepareTreeAddressNodeMultiError(errors)
	}

	return nil
}

// PrepareTreeAddressNodeMultiError is an error wrapping multiple validation
// errors returned by PrepareTreeAddressNode.ValidateAll() if the designated
// constraints aren't met.
type PrepareTreeAddressNodeMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m PrepareTreeAddressNodeMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m PrepareTreeAddressNodeMultiError) AllErrors() []error { return m }

// PrepareTreeAddressNodeValidationError is the validation error returned by
// PrepareTreeAddressNode.Validate if the designated constraints aren't met.
type PrepareTreeAddressNodeValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e PrepareTreeAddressNodeValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e PrepareTreeAddressNodeValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e PrepareTreeAddressNodeValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e PrepareTreeAddressNodeValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e PrepareTreeAddressNodeValidationError) ErrorName() string {
	return "PrepareTreeAddressNodeValidationError"
}

// Error satisfies the builtin error interface
func (e PrepareTreeAddressNodeValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sPrepareTreeAddressNode.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = PrepareTreeAddressNodeValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = PrepareTreeAddressNodeValidationError{}

// Validate checks the field values on PrepareTreeAddressRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *PrepareTreeAddressRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on PrepareTreeAddressRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// PrepareTreeAddressRequestMultiError, or nil if none found.
func (m *PrepareTreeAddressRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *PrepareTreeAddressRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for TargetKeyshareId

	if all {
		switch v := interface{}(m.GetNode()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, PrepareTreeAddressRequestValidationError{
					field:  "Node",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, PrepareTreeAddressRequestValidationError{
					field:  "Node",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetNode()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return PrepareTreeAddressRequestValidationError{
				field:  "Node",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for UserIdentityPublicKey

	// no validation rules for Network

	if len(errors) > 0 {
		return PrepareTreeAddressRequestMultiError(errors)
	}

	return nil
}

// PrepareTreeAddressRequestMultiError is an error wrapping multiple validation
// errors returned by PrepareTreeAddressRequest.ValidateAll() if the
// designated constraints aren't met.
type PrepareTreeAddressRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m PrepareTreeAddressRequestMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m PrepareTreeAddressRequestMultiError) AllErrors() []error { return m }

// PrepareTreeAddressRequestValidationError is the validation error returned by
// PrepareTreeAddressRequest.Validate if the designated constraints aren't met.
type PrepareTreeAddressRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e PrepareTreeAddressRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e PrepareTreeAddressRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e PrepareTreeAddressRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e PrepareTreeAddressRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e PrepareTreeAddressRequestValidationError) ErrorName() string {
	return "PrepareTreeAddressRequestValidationError"
}

// Error satisfies the builtin error interface
func (e PrepareTreeAddressRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sPrepareTreeAddressRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = PrepareTreeAddressRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = PrepareTreeAddressRequestValidationError{}

// Validate checks the field values on PrepareTreeAddressResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *PrepareTreeAddressResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on PrepareTreeAddressResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// PrepareTreeAddressResponseMultiError, or nil if none found.
func (m *PrepareTreeAddressResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *PrepareTreeAddressResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Signatures

	if len(errors) > 0 {
		return PrepareTreeAddressResponseMultiError(errors)
	}

	return nil
}

// PrepareTreeAddressResponseMultiError is an error wrapping multiple
// validation errors returned by PrepareTreeAddressResponse.ValidateAll() if
// the designated constraints aren't met.
type PrepareTreeAddressResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m PrepareTreeAddressResponseMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m PrepareTreeAddressResponseMultiError) AllErrors() []error { return m }

// PrepareTreeAddressResponseValidationError is the validation error returned
// by PrepareTreeAddressResponse.Validate if the designated constraints aren't met.
type PrepareTreeAddressResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e PrepareTreeAddressResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e PrepareTreeAddressResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e PrepareTreeAddressResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e PrepareTreeAddressResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e PrepareTreeAddressResponseValidationError) ErrorName() string {
	return "PrepareTreeAddressResponseValidationError"
}

// Error satisfies the builtin error interface
func (e PrepareTreeAddressResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sPrepareTreeAddressResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = PrepareTreeAddressResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = PrepareTreeAddressResponseValidationError{}

// Validate checks the field values on InitiateTransferLeaf with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *InitiateTransferLeaf) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on InitiateTransferLeaf with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// InitiateTransferLeafMultiError, or nil if none found.
func (m *InitiateTransferLeaf) ValidateAll() error {
	return m.validate(true)
}

func (m *InitiateTransferLeaf) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for LeafId

	// no validation rules for RawRefundTx

	if len(errors) > 0 {
		return InitiateTransferLeafMultiError(errors)
	}

	return nil
}

// InitiateTransferLeafMultiError is an error wrapping multiple validation
// errors returned by InitiateTransferLeaf.ValidateAll() if the designated
// constraints aren't met.
type InitiateTransferLeafMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m InitiateTransferLeafMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m InitiateTransferLeafMultiError) AllErrors() []error { return m }

// InitiateTransferLeafValidationError is the validation error returned by
// InitiateTransferLeaf.Validate if the designated constraints aren't met.
type InitiateTransferLeafValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e InitiateTransferLeafValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e InitiateTransferLeafValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e InitiateTransferLeafValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e InitiateTransferLeafValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e InitiateTransferLeafValidationError) ErrorName() string {
	return "InitiateTransferLeafValidationError"
}

// Error satisfies the builtin error interface
func (e InitiateTransferLeafValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sInitiateTransferLeaf.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = InitiateTransferLeafValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = InitiateTransferLeafValidationError{}

// Validate checks the field values on InitiateTransferRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *InitiateTransferRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on InitiateTransferRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// InitiateTransferRequestMultiError, or nil if none found.
func (m *InitiateTransferRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *InitiateTransferRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for TransferId

	// no validation rules for SenderIdentityPublicKey

	// no validation rules for ReceiverIdentityPublicKey

	if all {
		switch v := interface{}(m.GetExpiryTime()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, InitiateTransferRequestValidationError{
					field:  "ExpiryTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, InitiateTransferRequestValidationError{
					field:  "ExpiryTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetExpiryTime()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return InitiateTransferRequestValidationError{
				field:  "ExpiryTime",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	for idx, item := range m.GetLeaves() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, InitiateTransferRequestValidationError{
						field:  fmt.Sprintf("Leaves[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, InitiateTransferRequestValidationError{
						field:  fmt.Sprintf("Leaves[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return InitiateTransferRequestValidationError{
					field:  fmt.Sprintf("Leaves[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	{
		sorted_keys := make([]string, len(m.GetSenderKeyTweakProofs()))
		i := 0
		for key := range m.GetSenderKeyTweakProofs() {
			sorted_keys[i] = key
			i++
		}
		sort.Slice(sorted_keys, func(i, j int) bool { return sorted_keys[i] < sorted_keys[j] })
		for _, key := range sorted_keys {
			val := m.GetSenderKeyTweakProofs()[key]
			_ = val

			// no validation rules for SenderKeyTweakProofs[key]

			if all {
				switch v := interface{}(val).(type) {
				case interface{ ValidateAll() error }:
					if err := v.ValidateAll(); err != nil {
						errors = append(errors, InitiateTransferRequestValidationError{
							field:  fmt.Sprintf("SenderKeyTweakProofs[%v]", key),
							reason: "embedded message failed validation",
							cause:  err,
						})
					}
				case interface{ Validate() error }:
					if err := v.Validate(); err != nil {
						errors = append(errors, InitiateTransferRequestValidationError{
							field:  fmt.Sprintf("SenderKeyTweakProofs[%v]", key),
							reason: "embedded message failed validation",
							cause:  err,
						})
					}
				}
			} else if v, ok := interface{}(val).(interface{ Validate() error }); ok {
				if err := v.Validate(); err != nil {
					return InitiateTransferRequestValidationError{
						field:  fmt.Sprintf("SenderKeyTweakProofs[%v]", key),
						reason: "embedded message failed validation",
						cause:  err,
					}
				}
			}

		}
	}

	// no validation rules for Type

	if len(errors) > 0 {
		return InitiateTransferRequestMultiError(errors)
	}

	return nil
}

// InitiateTransferRequestMultiError is an error wrapping multiple validation
// errors returned by InitiateTransferRequest.ValidateAll() if the designated
// constraints aren't met.
type InitiateTransferRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m InitiateTransferRequestMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m InitiateTransferRequestMultiError) AllErrors() []error { return m }

// InitiateTransferRequestValidationError is the validation error returned by
// InitiateTransferRequest.Validate if the designated constraints aren't met.
type InitiateTransferRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e InitiateTransferRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e InitiateTransferRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e InitiateTransferRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e InitiateTransferRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e InitiateTransferRequestValidationError) ErrorName() string {
	return "InitiateTransferRequestValidationError"
}

// Error satisfies the builtin error interface
func (e InitiateTransferRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sInitiateTransferRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = InitiateTransferRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = InitiateTransferRequestValidationError{}

// Validate checks the field values on InitiateCooperativeExitRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *InitiateCooperativeExitRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on InitiateCooperativeExitRequest with
// the rules defined in the proto definition for this message. If any rules
// are violated, the result is a list of violation errors wrapped in
// InitiateCooperativeExitRequestMultiError, or nil if none found.
func (m *InitiateCooperativeExitRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *InitiateCooperativeExitRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetTransfer()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, InitiateCooperativeExitRequestValidationError{
					field:  "Transfer",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, InitiateCooperativeExitRequestValidationError{
					field:  "Transfer",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetTransfer()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return InitiateCooperativeExitRequestValidationError{
				field:  "Transfer",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for ExitId

	// no validation rules for ExitTxid

	if len(errors) > 0 {
		return InitiateCooperativeExitRequestMultiError(errors)
	}

	return nil
}

// InitiateCooperativeExitRequestMultiError is an error wrapping multiple
// validation errors returned by InitiateCooperativeExitRequest.ValidateAll()
// if the designated constraints aren't met.
type InitiateCooperativeExitRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m InitiateCooperativeExitRequestMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m InitiateCooperativeExitRequestMultiError) AllErrors() []error { return m }

// InitiateCooperativeExitRequestValidationError is the validation error
// returned by InitiateCooperativeExitRequest.Validate if the designated
// constraints aren't met.
type InitiateCooperativeExitRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e InitiateCooperativeExitRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e InitiateCooperativeExitRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e InitiateCooperativeExitRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e InitiateCooperativeExitRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e InitiateCooperativeExitRequestValidationError) ErrorName() string {
	return "InitiateCooperativeExitRequestValidationError"
}

// Error satisfies the builtin error interface
func (e InitiateCooperativeExitRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sInitiateCooperativeExitRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = InitiateCooperativeExitRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = InitiateCooperativeExitRequestValidationError{}

// Validate checks the field values on UpdatePreimageRequestRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *UpdatePreimageRequestRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UpdatePreimageRequestRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// UpdatePreimageRequestRequestMultiError, or nil if none found.
func (m *UpdatePreimageRequestRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *UpdatePreimageRequestRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for PreimageRequestId

	// no validation rules for Preimage

	// no validation rules for IdentityPublicKey

	if len(errors) > 0 {
		return UpdatePreimageRequestRequestMultiError(errors)
	}

	return nil
}

// UpdatePreimageRequestRequestMultiError is an error wrapping multiple
// validation errors returned by UpdatePreimageRequestRequest.ValidateAll() if
// the designated constraints aren't met.
type UpdatePreimageRequestRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UpdatePreimageRequestRequestMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UpdatePreimageRequestRequestMultiError) AllErrors() []error { return m }

// UpdatePreimageRequestRequestValidationError is the validation error returned
// by UpdatePreimageRequestRequest.Validate if the designated constraints
// aren't met.
type UpdatePreimageRequestRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UpdatePreimageRequestRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UpdatePreimageRequestRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UpdatePreimageRequestRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UpdatePreimageRequestRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UpdatePreimageRequestRequestValidationError) ErrorName() string {
	return "UpdatePreimageRequestRequestValidationError"
}

// Error satisfies the builtin error interface
func (e UpdatePreimageRequestRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUpdatePreimageRequestRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UpdatePreimageRequestRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UpdatePreimageRequestRequestValidationError{}

// Validate checks the field values on StartTokenTransactionInternalRequest
// with the rules defined in the proto definition for this message. If any
// rules are violated, the first error encountered is returned, or nil if
// there are no violations.
func (m *StartTokenTransactionInternalRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on StartTokenTransactionInternalRequest
// with the rules defined in the proto definition for this message. If any
// rules are violated, the result is a list of violation errors wrapped in
// StartTokenTransactionInternalRequestMultiError, or nil if none found.
func (m *StartTokenTransactionInternalRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *StartTokenTransactionInternalRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetFinalTokenTransaction()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, StartTokenTransactionInternalRequestValidationError{
					field:  "FinalTokenTransaction",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, StartTokenTransactionInternalRequestValidationError{
					field:  "FinalTokenTransaction",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetFinalTokenTransaction()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return StartTokenTransactionInternalRequestValidationError{
				field:  "FinalTokenTransaction",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetTokenTransactionSignatures()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, StartTokenTransactionInternalRequestValidationError{
					field:  "TokenTransactionSignatures",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, StartTokenTransactionInternalRequestValidationError{
					field:  "TokenTransactionSignatures",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetTokenTransactionSignatures()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return StartTokenTransactionInternalRequestValidationError{
				field:  "TokenTransactionSignatures",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for CoordinatorPublicKey

	if len(errors) > 0 {
		return StartTokenTransactionInternalRequestMultiError(errors)
	}

	return nil
}

// StartTokenTransactionInternalRequestMultiError is an error wrapping multiple
// validation errors returned by
// StartTokenTransactionInternalRequest.ValidateAll() if the designated
// constraints aren't met.
type StartTokenTransactionInternalRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m StartTokenTransactionInternalRequestMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m StartTokenTransactionInternalRequestMultiError) AllErrors() []error { return m }

// StartTokenTransactionInternalRequestValidationError is the validation error
// returned by StartTokenTransactionInternalRequest.Validate if the designated
// constraints aren't met.
type StartTokenTransactionInternalRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e StartTokenTransactionInternalRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e StartTokenTransactionInternalRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e StartTokenTransactionInternalRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e StartTokenTransactionInternalRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e StartTokenTransactionInternalRequestValidationError) ErrorName() string {
	return "StartTokenTransactionInternalRequestValidationError"
}

// Error satisfies the builtin error interface
func (e StartTokenTransactionInternalRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sStartTokenTransactionInternalRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = StartTokenTransactionInternalRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = StartTokenTransactionInternalRequestValidationError{}

// Validate checks the field values on StartTokenTransactionInternalResponse
// with the rules defined in the proto definition for this message. If any
// rules are violated, the first error encountered is returned, or nil if
// there are no violations.
func (m *StartTokenTransactionInternalResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on StartTokenTransactionInternalResponse
// with the rules defined in the proto definition for this message. If any
// rules are violated, the result is a list of violation errors wrapped in
// StartTokenTransactionInternalResponseMultiError, or nil if none found.
func (m *StartTokenTransactionInternalResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *StartTokenTransactionInternalResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetFinalTokenTransaction()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, StartTokenTransactionInternalResponseValidationError{
					field:  "FinalTokenTransaction",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, StartTokenTransactionInternalResponseValidationError{
					field:  "FinalTokenTransaction",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetFinalTokenTransaction()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return StartTokenTransactionInternalResponseValidationError{
				field:  "FinalTokenTransaction",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return StartTokenTransactionInternalResponseMultiError(errors)
	}

	return nil
}

// StartTokenTransactionInternalResponseMultiError is an error wrapping
// multiple validation errors returned by
// StartTokenTransactionInternalResponse.ValidateAll() if the designated
// constraints aren't met.
type StartTokenTransactionInternalResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m StartTokenTransactionInternalResponseMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m StartTokenTransactionInternalResponseMultiError) AllErrors() []error { return m }

// StartTokenTransactionInternalResponseValidationError is the validation error
// returned by StartTokenTransactionInternalResponse.Validate if the
// designated constraints aren't met.
type StartTokenTransactionInternalResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e StartTokenTransactionInternalResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e StartTokenTransactionInternalResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e StartTokenTransactionInternalResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e StartTokenTransactionInternalResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e StartTokenTransactionInternalResponseValidationError) ErrorName() string {
	return "StartTokenTransactionInternalResponseValidationError"
}

// Error satisfies the builtin error interface
func (e StartTokenTransactionInternalResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sStartTokenTransactionInternalResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = StartTokenTransactionInternalResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = StartTokenTransactionInternalResponseValidationError{}

// Validate checks the field values on InitiateSettleReceiverKeyTweakRequest
// with the rules defined in the proto definition for this message. If any
// rules are violated, the first error encountered is returned, or nil if
// there are no violations.
func (m *InitiateSettleReceiverKeyTweakRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on InitiateSettleReceiverKeyTweakRequest
// with the rules defined in the proto definition for this message. If any
// rules are violated, the result is a list of violation errors wrapped in
// InitiateSettleReceiverKeyTweakRequestMultiError, or nil if none found.
func (m *InitiateSettleReceiverKeyTweakRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *InitiateSettleReceiverKeyTweakRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for TransferId

	{
		sorted_keys := make([]string, len(m.GetKeyTweakProofs()))
		i := 0
		for key := range m.GetKeyTweakProofs() {
			sorted_keys[i] = key
			i++
		}
		sort.Slice(sorted_keys, func(i, j int) bool { return sorted_keys[i] < sorted_keys[j] })
		for _, key := range sorted_keys {
			val := m.GetKeyTweakProofs()[key]
			_ = val

			// no validation rules for KeyTweakProofs[key]

			if all {
				switch v := interface{}(val).(type) {
				case interface{ ValidateAll() error }:
					if err := v.ValidateAll(); err != nil {
						errors = append(errors, InitiateSettleReceiverKeyTweakRequestValidationError{
							field:  fmt.Sprintf("KeyTweakProofs[%v]", key),
							reason: "embedded message failed validation",
							cause:  err,
						})
					}
				case interface{ Validate() error }:
					if err := v.Validate(); err != nil {
						errors = append(errors, InitiateSettleReceiverKeyTweakRequestValidationError{
							field:  fmt.Sprintf("KeyTweakProofs[%v]", key),
							reason: "embedded message failed validation",
							cause:  err,
						})
					}
				}
			} else if v, ok := interface{}(val).(interface{ Validate() error }); ok {
				if err := v.Validate(); err != nil {
					return InitiateSettleReceiverKeyTweakRequestValidationError{
						field:  fmt.Sprintf("KeyTweakProofs[%v]", key),
						reason: "embedded message failed validation",
						cause:  err,
					}
				}
			}

		}
	}

	if len(errors) > 0 {
		return InitiateSettleReceiverKeyTweakRequestMultiError(errors)
	}

	return nil
}

// InitiateSettleReceiverKeyTweakRequestMultiError is an error wrapping
// multiple validation errors returned by
// InitiateSettleReceiverKeyTweakRequest.ValidateAll() if the designated
// constraints aren't met.
type InitiateSettleReceiverKeyTweakRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m InitiateSettleReceiverKeyTweakRequestMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m InitiateSettleReceiverKeyTweakRequestMultiError) AllErrors() []error { return m }

// InitiateSettleReceiverKeyTweakRequestValidationError is the validation error
// returned by InitiateSettleReceiverKeyTweakRequest.Validate if the
// designated constraints aren't met.
type InitiateSettleReceiverKeyTweakRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e InitiateSettleReceiverKeyTweakRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e InitiateSettleReceiverKeyTweakRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e InitiateSettleReceiverKeyTweakRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e InitiateSettleReceiverKeyTweakRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e InitiateSettleReceiverKeyTweakRequestValidationError) ErrorName() string {
	return "InitiateSettleReceiverKeyTweakRequestValidationError"
}

// Error satisfies the builtin error interface
func (e InitiateSettleReceiverKeyTweakRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sInitiateSettleReceiverKeyTweakRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = InitiateSettleReceiverKeyTweakRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = InitiateSettleReceiverKeyTweakRequestValidationError{}

// Validate checks the field values on SettleReceiverKeyTweakRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *SettleReceiverKeyTweakRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on SettleReceiverKeyTweakRequest with
// the rules defined in the proto definition for this message. If any rules
// are violated, the result is a list of violation errors wrapped in
// SettleReceiverKeyTweakRequestMultiError, or nil if none found.
func (m *SettleReceiverKeyTweakRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *SettleReceiverKeyTweakRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for TransferId

	// no validation rules for TweakKey

	if len(errors) > 0 {
		return SettleReceiverKeyTweakRequestMultiError(errors)
	}

	return nil
}

// SettleReceiverKeyTweakRequestMultiError is an error wrapping multiple
// validation errors returned by SettleReceiverKeyTweakRequest.ValidateAll()
// if the designated constraints aren't met.
type SettleReceiverKeyTweakRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m SettleReceiverKeyTweakRequestMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m SettleReceiverKeyTweakRequestMultiError) AllErrors() []error { return m }

// SettleReceiverKeyTweakRequestValidationError is the validation error
// returned by SettleReceiverKeyTweakRequest.Validate if the designated
// constraints aren't met.
type SettleReceiverKeyTweakRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e SettleReceiverKeyTweakRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e SettleReceiverKeyTweakRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e SettleReceiverKeyTweakRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e SettleReceiverKeyTweakRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e SettleReceiverKeyTweakRequestValidationError) ErrorName() string {
	return "SettleReceiverKeyTweakRequestValidationError"
}

// Error satisfies the builtin error interface
func (e SettleReceiverKeyTweakRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sSettleReceiverKeyTweakRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = SettleReceiverKeyTweakRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = SettleReceiverKeyTweakRequestValidationError{}
